function Gm(t) {
  return Object.keys(t).reduce((r, n) => {
    const u = t[n];
    return r[n] = Object.assign({}, u), jd(u.value) && !Zm(u.value) && !Array.isArray(u.value) && (r[n].value = Object.assign({}, u.value)), Array.isArray(u.value) && (r[n].value = u.value.slice(0)), r;
  }, {});
}
function qm(t) {
  return t ? Object.keys(t).reduce((r, n) => {
    const u = t[n];
    return r[n] = jd(u) && "value" in u ? u : {
      value: u
    }, r[n].attribute || (r[n].attribute = Hm(n)), r[n].parse = "parse" in r[n] ? r[n].parse : typeof r[n].value != "string", r;
  }, {}) : {};
}
function Xm(t) {
  return Object.keys(t).reduce((r, n) => (r[n] = t[n].value, r), {});
}
function zm(t, e) {
  const r = Gm(e);
  return Object.keys(e).forEach((u) => {
    const y = r[u], b = t.getAttribute(y.attribute), h = t[u];
    b != null && (y.value = y.parse ? Vd(b) : b), h != null && (y.value = Array.isArray(h) ? h.slice(0) : h), y.reflect && Ic(t, y.attribute, y.value, !!y.parse), Object.defineProperty(t, u, {
      get() {
        return y.value;
      },
      set(d) {
        const m = y.value;
        y.value = d, y.reflect && Ic(this, y.attribute, y.value, !!y.parse);
        for (let p = 0, _ = this.__propertyChangedCallbacks.length; p < _; p++)
          this.__propertyChangedCallbacks[p](u, d, m);
      },
      enumerable: !0,
      configurable: !0
    });
  }), r;
}
function Vd(t) {
  if (t)
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
}
function Ic(t, e, r, n) {
  if (r == null || r === !1) return t.removeAttribute(e);
  let u = n ? JSON.stringify(r) : r;
  t.__updating[e] = !0, u === "true" && (u = ""), t.setAttribute(e, u), Promise.resolve().then(() => delete t.__updating[e]);
}
function Hm(t) {
  return t.replace(/\.?([A-Z]+)/g, (e, r) => "-" + r.toLowerCase()).replace("_", "-").replace(/^-/, "");
}
function jd(t) {
  return t != null && (typeof t == "object" || typeof t == "function");
}
function Zm(t) {
  return Object.prototype.toString.call(t) === "[object Function]";
}
function Wm(t) {
  return typeof t == "function" && t.toString().indexOf("class") === 0;
}
let Eu;
function Ym(t, e) {
  const r = Object.keys(e);
  return class extends t {
    static get observedAttributes() {
      return r.map((u) => e[u].attribute);
    }
    constructor() {
      super(), this.__initialized = !1, this.__released = !1, this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = {};
    }
    connectedCallback() {
      if (this.__initialized) return;
      this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = zm(this, e);
      const u = Xm(this.props), y = this.Component, b = Eu;
      try {
        Eu = this, this.__initialized = !0, Wm(y) ? new y(u, {
          element: this
        }) : y(u, {
          element: this
        });
      } finally {
        Eu = b;
      }
    }
    async disconnectedCallback() {
      if (await Promise.resolve(), this.isConnected) return;
      this.__propertyChangedCallbacks.length = 0;
      let u = null;
      for (; u = this.__releaseCallbacks.pop(); ) u(this);
      delete this.__initialized, this.__released = !0;
    }
    attributeChangedCallback(u, y, b) {
      if (this.__initialized && !this.__updating[u] && (u = this.lookupProp(u), u in e)) {
        if (b == null && !this[u]) return;
        this[u] = e[u].parse ? Vd(b) : b;
      }
    }
    lookupProp(u) {
      if (e)
        return r.find((y) => u === y || u === e[y].attribute);
    }
    get renderRoot() {
      return this.shadowRoot || this.attachShadow({
        mode: "open"
      });
    }
    addReleaseCallback(u) {
      this.__releaseCallbacks.push(u);
    }
    addPropertyChangedCallback(u) {
      this.__propertyChangedCallbacks.push(u);
    }
  };
}
function Jm(t, e = {}, r = {}) {
  const {
    BaseElement: n = HTMLElement,
    extension: u,
    customElements: y = window.customElements
  } = r;
  return (b) => {
    let h = y.get(t);
    return h ? (h.prototype.Component = b, h) : (h = Ym(n, qm(e)), h.prototype.Component = b, h.prototype.registeredTag = t, y.define(t, h, u), h);
  };
}
const Qm = (t, e) => t === e, Uu = Symbol("solid-proxy"), ey = typeof Proxy == "function", Dl = {
  equals: Qm
};
let Fd = zd;
const wn = 1, Pl = 2, $d = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var gr = null;
let vu = null, ty = null, Nt = null, fr = null, Xi = null, Hl = 0;
function ry(t, e) {
  const r = Nt, n = gr, u = t.length === 0, y = e === void 0 ? n : e, b = u ? $d : {
    owned: null,
    cleanups: null,
    context: y ? y.context : null,
    owner: y
  }, h = u ? t : () => t(() => Ya(() => Ha(b)));
  gr = b, Nt = null;
  try {
    return Qa(h, !0);
  } finally {
    Nt = r, gr = n;
  }
}
function Xa(t, e) {
  e = e ? Object.assign({}, Dl, e) : Dl;
  const r = {
    value: t,
    observers: null,
    observerSlots: null,
    comparator: e.equals || void 0
  }, n = (u) => (typeof u == "function" && (u = u(r.value)), Xd(r, u));
  return [qd.bind(r), n];
}
function kr(t, e, r) {
  const n = qu(t, e, !1, wn);
  Ja(n);
}
function Gd(t, e, r) {
  Fd = sy;
  const n = qu(t, e, !1, wn);
  n.user = !0, Xi ? Xi.push(n) : Ja(n);
}
function pi(t, e, r) {
  r = r ? Object.assign({}, Dl, r) : Dl;
  const n = qu(t, e, !0, 0);
  return n.observers = null, n.observerSlots = null, n.comparator = r.equals || void 0, Ja(n), qd.bind(n);
}
function Ya(t) {
  if (Nt === null) return t();
  const e = Nt;
  Nt = null;
  try {
    return t();
  } finally {
    Nt = e;
  }
}
function iy(t) {
  Gd(() => Ya(t));
}
function qd() {
  if (this.sources && this.state)
    if (this.state === wn) Ja(this);
    else {
      const t = fr;
      fr = null, Qa(() => Il(this), !1), fr = t;
    }
  if (Nt) {
    const t = this.observers ? this.observers.length : 0;
    Nt.sources ? (Nt.sources.push(this), Nt.sourceSlots.push(t)) : (Nt.sources = [this], Nt.sourceSlots = [t]), this.observers ? (this.observers.push(Nt), this.observerSlots.push(Nt.sources.length - 1)) : (this.observers = [Nt], this.observerSlots = [Nt.sources.length - 1]);
  }
  return this.value;
}
function Xd(t, e, r) {
  let n = t.value;
  return (!t.comparator || !t.comparator(n, e)) && (t.value = e, t.observers && t.observers.length && Qa(() => {
    for (let u = 0; u < t.observers.length; u += 1) {
      const y = t.observers[u], b = vu && vu.running;
      b && vu.disposed.has(y), (b ? !y.tState : !y.state) && (y.pure ? fr.push(y) : Xi.push(y), y.observers && Hd(y)), b || (y.state = wn);
    }
    if (fr.length > 1e6)
      throw fr = [], new Error();
  }, !1)), e;
}
function Ja(t) {
  if (!t.fn) return;
  Ha(t);
  const e = Hl;
  ny(
    t,
    t.value,
    e
  );
}
function ny(t, e, r) {
  let n;
  const u = gr, y = Nt;
  Nt = gr = t;
  try {
    n = t.fn(e);
  } catch (b) {
    return t.pure && (t.state = wn, t.owned && t.owned.forEach(Ha), t.owned = null), t.updatedAt = r + 1, Zd(b);
  } finally {
    Nt = y, gr = u;
  }
  (!t.updatedAt || t.updatedAt <= r) && (t.updatedAt != null && "observers" in t ? Xd(t, n) : t.value = n, t.updatedAt = r);
}
function qu(t, e, r, n = wn, u) {
  const y = {
    fn: t,
    state: n,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: e,
    owner: gr,
    context: gr ? gr.context : null,
    pure: r
  };
  return gr === null || gr !== $d && (gr.owned ? gr.owned.push(y) : gr.owned = [y]), y;
}
function Bl(t) {
  if (t.state === 0) return;
  if (t.state === Pl) return Il(t);
  if (t.suspense && Ya(t.suspense.inFallback)) return t.suspense.effects.push(t);
  const e = [t];
  for (; (t = t.owner) && (!t.updatedAt || t.updatedAt < Hl); )
    t.state && e.push(t);
  for (let r = e.length - 1; r >= 0; r--)
    if (t = e[r], t.state === wn)
      Ja(t);
    else if (t.state === Pl) {
      const n = fr;
      fr = null, Qa(() => Il(t, e[0]), !1), fr = n;
    }
}
function Qa(t, e) {
  if (fr) return t();
  let r = !1;
  e || (fr = []), Xi ? r = !0 : Xi = [], Hl++;
  try {
    const n = t();
    return ay(r), n;
  } catch (n) {
    r || (Xi = null), fr = null, Zd(n);
  }
}
function ay(t) {
  if (fr && (zd(fr), fr = null), t) return;
  const e = Xi;
  Xi = null, e.length && Qa(() => Fd(e), !1);
}
function zd(t) {
  for (let e = 0; e < t.length; e++) Bl(t[e]);
}
function sy(t) {
  let e, r = 0;
  for (e = 0; e < t.length; e++) {
    const n = t[e];
    n.user ? t[r++] = n : Bl(n);
  }
  for (e = 0; e < r; e++) Bl(t[e]);
}
function Il(t, e) {
  t.state = 0;
  for (let r = 0; r < t.sources.length; r += 1) {
    const n = t.sources[r];
    if (n.sources) {
      const u = n.state;
      u === wn ? n !== e && (!n.updatedAt || n.updatedAt < Hl) && Bl(n) : u === Pl && Il(n, e);
    }
  }
}
function Hd(t) {
  for (let e = 0; e < t.observers.length; e += 1) {
    const r = t.observers[e];
    r.state || (r.state = Pl, r.pure ? fr.push(r) : Xi.push(r), r.observers && Hd(r));
  }
}
function Ha(t) {
  let e;
  if (t.sources)
    for (; t.sources.length; ) {
      const r = t.sources.pop(), n = t.sourceSlots.pop(), u = r.observers;
      if (u && u.length) {
        const y = u.pop(), b = r.observerSlots.pop();
        n < u.length && (y.sourceSlots[b] = n, u[n] = y, r.observerSlots[n] = b);
      }
    }
  if (t.tOwned) {
    for (e = t.tOwned.length - 1; e >= 0; e--) Ha(t.tOwned[e]);
    delete t.tOwned;
  }
  if (t.owned) {
    for (e = t.owned.length - 1; e >= 0; e--) Ha(t.owned[e]);
    t.owned = null;
  }
  if (t.cleanups) {
    for (e = t.cleanups.length - 1; e >= 0; e--) t.cleanups[e]();
    t.cleanups = null;
  }
  t.state = 0;
}
function oy(t) {
  return t instanceof Error ? t : new Error(typeof t == "string" ? t : "Unknown error", {
    cause: t
  });
}
function Zd(t, e = gr) {
  throw oy(t);
}
function Wd(t, e) {
  return Ya(() => t(e || {}));
}
function Rl() {
  return !0;
}
const ly = {
  get(t, e, r) {
    return e === Uu ? r : t.get(e);
  },
  has(t, e) {
    return e === Uu ? !0 : t.has(e);
  },
  set: Rl,
  deleteProperty: Rl,
  getOwnPropertyDescriptor(t, e) {
    return {
      configurable: !0,
      enumerable: !0,
      get() {
        return t.get(e);
      },
      set: Rl,
      deleteProperty: Rl
    };
  },
  ownKeys(t) {
    return t.keys();
  }
};
function Ru(t) {
  return (t = typeof t == "function" ? t() : t) ? t : {};
}
function uy() {
  for (let t = 0, e = this.length; t < e; ++t) {
    const r = this[t]();
    if (r !== void 0) return r;
  }
}
function cy(...t) {
  let e = !1;
  for (let b = 0; b < t.length; b++) {
    const h = t[b];
    e = e || !!h && Uu in h, t[b] = typeof h == "function" ? (e = !0, pi(h)) : h;
  }
  if (ey && e)
    return new Proxy(
      {
        get(b) {
          for (let h = t.length - 1; h >= 0; h--) {
            const d = Ru(t[h])[b];
            if (d !== void 0) return d;
          }
        },
        has(b) {
          for (let h = t.length - 1; h >= 0; h--)
            if (b in Ru(t[h])) return !0;
          return !1;
        },
        keys() {
          const b = [];
          for (let h = 0; h < t.length; h++)
            b.push(...Object.keys(Ru(t[h])));
          return [...new Set(b)];
        }
      },
      ly
    );
  const r = {}, n = /* @__PURE__ */ Object.create(null);
  for (let b = t.length - 1; b >= 0; b--) {
    const h = t[b];
    if (!h) continue;
    const d = Object.getOwnPropertyNames(h);
    for (let m = d.length - 1; m >= 0; m--) {
      const p = d[m];
      if (p === "__proto__" || p === "constructor") continue;
      const _ = Object.getOwnPropertyDescriptor(h, p);
      if (!n[p])
        n[p] = _.get ? {
          enumerable: !0,
          configurable: !0,
          get: uy.bind(r[p] = [_.get.bind(h)])
        } : _.value !== void 0 ? _ : void 0;
      else {
        const B = r[p];
        B && (_.get ? B.push(_.get.bind(h)) : _.value !== void 0 && B.push(() => _.value));
      }
    }
  }
  const u = {}, y = Object.keys(n);
  for (let b = y.length - 1; b >= 0; b--) {
    const h = y[b], d = n[h];
    d && d.get ? Object.defineProperty(u, h, d) : u[h] = d ? d.value : void 0;
  }
  return u;
}
function dy(t, e, r) {
  let n = r.length, u = e.length, y = n, b = 0, h = 0, d = e[u - 1].nextSibling, m = null;
  for (; b < u || h < y; ) {
    if (e[b] === r[h]) {
      b++, h++;
      continue;
    }
    for (; e[u - 1] === r[y - 1]; )
      u--, y--;
    if (u === b) {
      const p = y < n ? h ? r[h - 1].nextSibling : r[y - h] : d;
      for (; h < y; ) t.insertBefore(r[h++], p);
    } else if (y === h)
      for (; b < u; )
        (!m || !m.has(e[b])) && e[b].remove(), b++;
    else if (e[b] === r[y - 1] && r[h] === e[u - 1]) {
      const p = e[--u].nextSibling;
      t.insertBefore(r[h++], e[b++].nextSibling), t.insertBefore(r[--y], p), e[u] = r[y];
    } else {
      if (!m) {
        m = /* @__PURE__ */ new Map();
        let _ = h;
        for (; _ < y; ) m.set(r[_], _++);
      }
      const p = m.get(e[b]);
      if (p != null)
        if (h < p && p < y) {
          let _ = b, B = 1, N;
          for (; ++_ < u && _ < y && !((N = m.get(e[_])) == null || N !== p + B); )
            B++;
          if (B > p - h) {
            const X = e[b];
            for (; h < p; ) t.insertBefore(r[h++], X);
          } else t.replaceChild(r[h++], e[b++]);
        } else b++;
      else e[b++].remove();
    }
  }
}
const Uc = "_$DX_DELEGATE";
function mr(t, e, r) {
  let n;
  const u = () => {
    const b = document.createElement("template");
    return b.innerHTML = t, b.content.firstChild;
  }, y = () => (n || (n = u())).cloneNode(!0);
  return y.cloneNode = y, y;
}
function Yd(t, e = window.document) {
  const r = e[Uc] || (e[Uc] = /* @__PURE__ */ new Set());
  for (let n = 0, u = t.length; n < u; n++) {
    const y = t[n];
    r.has(y) || (r.add(y), e.addEventListener(y, fy));
  }
}
function Ht(t, e, r) {
  r == null ? t.removeAttribute(e) : t.setAttribute(e, r);
}
function Ou(t, e) {
  e == null ? t.removeAttribute("class") : t.className = e;
}
function Ku(t, e, r) {
  return Ya(() => t(e, r));
}
function yt(t, e, r, n) {
  if (r !== void 0 && !n && (n = []), typeof e != "function") return Ul(t, e, n, r);
  kr((u) => Ul(t, e(), u, r), n);
}
function fy(t) {
  let e = t.target;
  const r = `$$${t.type}`, n = t.target, u = t.currentTarget, y = (d) => Object.defineProperty(t, "target", {
    configurable: !0,
    value: d
  }), b = () => {
    const d = e[r];
    if (d && !e.disabled) {
      const m = e[`${r}Data`];
      if (m !== void 0 ? d.call(e, m, t) : d.call(e, t), t.cancelBubble) return;
    }
    return e.host && typeof e.host != "string" && !e.host._$host && e.contains(t.target) && y(e.host), !0;
  }, h = () => {
    for (; b() && (e = e._$host || e.parentNode || e.host); ) ;
  };
  if (Object.defineProperty(t, "currentTarget", {
    configurable: !0,
    get() {
      return e || document;
    }
  }), t.composedPath) {
    const d = t.composedPath();
    y(d[0]);
    for (let m = 0; m < d.length - 2 && (e = d[m], !!b()); m++) {
      if (e._$host) {
        e = e._$host, h();
        break;
      }
      if (e.parentNode === u)
        break;
    }
  } else h();
  y(n);
}
function Ul(t, e, r, n, u) {
  for (; typeof r == "function"; ) r = r();
  if (e === r) return r;
  const y = typeof e, b = n !== void 0;
  if (t = b && r[0] && r[0].parentNode || t, y === "string" || y === "number") {
    if (y === "number" && (e = e.toString(), e === r))
      return r;
    if (b) {
      let h = r[0];
      h && h.nodeType === 3 ? h.data !== e && (h.data = e) : h = document.createTextNode(e), r = sa(t, r, n, h);
    } else
      r !== "" && typeof r == "string" ? r = t.firstChild.data = e : r = t.textContent = e;
  } else if (e == null || y === "boolean")
    r = sa(t, r, n);
  else {
    if (y === "function")
      return kr(() => {
        let h = e();
        for (; typeof h == "function"; ) h = h();
        r = Ul(t, h, r, n);
      }), () => r;
    if (Array.isArray(e)) {
      const h = [], d = r && Array.isArray(r);
      if (Mu(h, e, r, u))
        return kr(() => r = Ul(t, h, r, n, !0)), () => r;
      if (h.length === 0) {
        if (r = sa(t, r, n), b) return r;
      } else d ? r.length === 0 ? Oc(t, h, n) : dy(t, r, h) : (r && sa(t), Oc(t, h));
      r = h;
    } else if (e.nodeType) {
      if (Array.isArray(r)) {
        if (b) return r = sa(t, r, n, e);
        sa(t, r, null, e);
      } else r == null || r === "" || !t.firstChild ? t.appendChild(e) : t.replaceChild(e, t.firstChild);
      r = e;
    }
  }
  return r;
}
function Mu(t, e, r, n) {
  let u = !1;
  for (let y = 0, b = e.length; y < b; y++) {
    let h = e[y], d = r && r[t.length], m;
    if (!(h == null || h === !0 || h === !1)) if ((m = typeof h) == "object" && h.nodeType)
      t.push(h);
    else if (Array.isArray(h))
      u = Mu(t, h, d) || u;
    else if (m === "function")
      if (n) {
        for (; typeof h == "function"; ) h = h();
        u = Mu(
          t,
          Array.isArray(h) ? h : [h],
          Array.isArray(d) ? d : [d]
        ) || u;
      } else
        t.push(h), u = !0;
    else {
      const p = String(h);
      d && d.nodeType === 3 && d.data === p ? t.push(d) : t.push(document.createTextNode(p));
    }
  }
  return u;
}
function Oc(t, e, r = null) {
  for (let n = 0, u = e.length; n < u; n++) t.insertBefore(e[n], r);
}
function sa(t, e, r, n) {
  if (r === void 0) return t.textContent = "";
  const u = n || document.createTextNode("");
  if (e.length) {
    let y = !1;
    for (let b = e.length - 1; b >= 0; b--) {
      const h = e[b];
      if (u !== h) {
        const d = h.parentNode === t;
        !y && !b ? d ? t.replaceChild(u, h) : t.insertBefore(u, r) : d && h.remove();
      } else y = !0;
    }
  } else t.insertBefore(u, r);
  return [u];
}
function py(t) {
  const e = Object.keys(t), r = {};
  for (let n = 0; n < e.length; n++) {
    const [u, y] = Xa(t[e[n]]);
    Object.defineProperty(r, e[n], {
      get: u,
      set(b) {
        y(() => b);
      }
    });
  }
  return r;
}
function hy(t) {
  if (t.assignedSlot && t.assignedSlot._$owner) return t.assignedSlot._$owner;
  let e = t.parentNode;
  for (; e && !e._$owner && !(e.assignedSlot && e.assignedSlot._$owner); )
    e = e.parentNode;
  return e && e.assignedSlot ? e.assignedSlot._$owner : t._$owner;
}
function my(t) {
  return (e, r) => {
    const { element: n } = r;
    return ry((u) => {
      const y = py(e);
      n.addPropertyChangedCallback((h, d) => y[h] = d), n.addReleaseCallback(() => {
        n.renderRoot.textContent = "", u();
      });
      const b = t(y, r);
      return yt(n.renderRoot, b);
    }, hy(n));
  };
}
function yy(t, e, r) {
  return arguments.length === 2 && (r = e, e = {}), Jm(t, e)(my(r));
}
const by = '*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.visible{visibility:visible}.fixed{position:fixed}.right-5{right:1.25rem}.top-5{top:1.25rem}.col-span-2{grid-column:span 2 / span 2}.mx-1{margin-left:.25rem;margin-right:.25rem}.mx-auto{margin-left:auto;margin-right:auto}.mb-1{margin-bottom:.25rem}.mb-8{margin-bottom:2rem}.ml-10{margin-left:2.5rem}.mr-1{margin-right:.25rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.block{display:block}.inline{display:inline}.flex{display:flex}.grid{display:grid}.h-10{height:2.5rem}.h-14{height:3.5rem}.h-2{height:.5rem}.h-4{height:1rem}.h-full{height:100%}.max-h-\\[350px\\]{max-height:350px}.max-h-\\[90vh\\]{max-height:90vh}.w-10{width:2.5rem}.w-14{width:3.5rem}.w-4{width:1rem}.w-full{width:100%}.max-w-\\[400px\\]{max-width:400px}.max-w-\\[calc\\(365px-96px\\)\\]{max-width:269px}.max-w-\\[calc\\(390px-96px\\)\\]{max-width:294px}.max-w-screen-sm{max-width:640px}.flex-1{flex:1 1 0%}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-1{gap:.25rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.whitespace-pre-wrap{white-space:pre-wrap}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.rounded-md{border-radius:.375rem}.rounded-t-md{border-top-left-radius:.375rem;border-top-right-radius:.375rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-slate-300{--tw-border-opacity: 1;border-color:rgb(203 213 225 / var(--tw-border-opacity))}.bg-blue-500{--tw-bg-opacity: 1;background-color:rgb(59 130 246 / var(--tw-bg-opacity))}.bg-gray-900{--tw-bg-opacity: 1;background-color:rgb(17 24 39 / var(--tw-bg-opacity))}.bg-slate-100{--tw-bg-opacity: 1;background-color:rgb(241 245 249 / var(--tw-bg-opacity))}.bg-slate-200{--tw-bg-opacity: 1;background-color:rgb(226 232 240 / var(--tw-bg-opacity))}.bg-slate-900{--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity))}.object-cover{-o-object-fit:cover;object-fit:cover}.p-3{padding:.75rem}.p-4{padding:1rem}.px-4{padding-left:1rem;padding-right:1rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.pr-6{padding-right:1.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-blue-500{--tw-text-opacity: 1;color:rgb(59 130 246 / var(--tw-text-opacity))}.text-slate-500{--tw-text-opacity: 1;color:rgb(100 116 139 / var(--tw-text-opacity))}.text-slate-600{--tw-text-opacity: 1;color:rgb(71 85 105 / var(--tw-text-opacity))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.underline{text-decoration-line:underline}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop\\:bg-gray-800::backdrop{--tw-bg-opacity: 1;background-color:rgb(31 41 55 / var(--tw-bg-opacity))}.backdrop\\:opacity-90::backdrop{opacity:.9}.hover\\:bg-blue-700:hover{--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity))}.hover\\:underline:hover{text-decoration-line:underline}.dark\\:border-slate-800:where(.dark,.dark *){--tw-border-opacity: 1;border-color:rgb(30 41 59 / var(--tw-border-opacity))}.dark\\:bg-slate-800:where(.dark,.dark *){--tw-bg-opacity: 1;background-color:rgb(30 41 59 / var(--tw-bg-opacity))}.dark\\:text-slate-400:where(.dark,.dark *){--tw-text-opacity: 1;color:rgb(148 163 184 / var(--tw-text-opacity))}.dark\\:text-white:where(.dark,.dark *){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}';
var de = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function gy(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Jd(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var u = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, u.get ? u : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var Xu = {}, ra = {}, zu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DisallowedDomainError = t.UnsupportedDomainError = t.ReservedHandleError = t.InvalidHandleError = t.isValidTld = t.isValidHandle = t.normalizeAndEnsureValidHandle = t.normalizeHandle = t.ensureValidHandleRegex = t.ensureValidHandle = t.DISALLOWED_TLDS = t.INVALID_HANDLE = void 0, t.INVALID_HANDLE = "handle.invalid", t.DISALLOWED_TLDS = [
    ".local",
    ".arpa",
    ".invalid",
    ".localhost",
    ".internal",
    ".example",
    ".alt",
    // policy could concievably change on ".onion" some day
    ".onion"
    // NOTE: .test is allowed in testing and devopment. In practical terms
    // "should" "never" actually resolve and get registered in production
  ];
  const e = (_) => {
    if (!/^[a-zA-Z0-9.-]*$/.test(_))
      throw new h("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
    if (_.length > 253)
      throw new h("Handle is too long (253 chars max)");
    const B = _.split(".");
    if (B.length < 2)
      throw new h("Handle domain needs at least two parts");
    for (let N = 0; N < B.length; N++) {
      const X = B[N];
      if (X.length < 1)
        throw new h("Handle parts can not be empty");
      if (X.length > 63)
        throw new h("Handle part too long (max 63 chars)");
      if (X.endsWith("-") || X.startsWith("-"))
        throw new h("Handle parts can not start or end with hyphens");
      if (N + 1 == B.length && !/^[a-zA-Z]/.test(X))
        throw new h("Handle final component (TLD) must start with ASCII letter");
    }
  };
  t.ensureValidHandle = e;
  const r = (_) => {
    if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(_))
      throw new h("Handle didn't validate via regex");
    if (_.length > 253)
      throw new h("Handle is too long (253 chars max)");
  };
  t.ensureValidHandleRegex = r;
  const n = (_) => _.toLowerCase();
  t.normalizeHandle = n;
  const u = (_) => {
    const B = (0, t.normalizeHandle)(_);
    return (0, t.ensureValidHandle)(B), B;
  };
  t.normalizeAndEnsureValidHandle = u;
  const y = (_) => {
    try {
      (0, t.ensureValidHandle)(_);
    } catch (B) {
      if (B instanceof h)
        return !1;
      throw B;
    }
    return !0;
  };
  t.isValidHandle = y;
  const b = (_) => !t.DISALLOWED_TLDS.some((B) => _.endsWith(B));
  t.isValidTld = b;
  class h extends Error {
  }
  t.InvalidHandleError = h;
  class d extends Error {
  }
  t.ReservedHandleError = d;
  class m extends Error {
  }
  t.UnsupportedDomainError = m;
  class p extends Error {
  }
  t.DisallowedDomainError = p;
})(zu);
var zi = {};
Object.defineProperty(zi, "__esModule", { value: !0 });
zi.InvalidDidError = zi.ensureValidDidRegex = zi.ensureValidDid = void 0;
const xy = (t) => {
  if (!/^[a-zA-Z0-9._:%-]*$/.test(t))
    throw new $i("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
  const e = t.split(":");
  if (e.length < 3)
    throw new $i("DID requires prefix, method, and method-specific content");
  if (e[0] != "did")
    throw new $i('DID requires "did:" prefix');
  if (!/^[a-z]+$/.test(e[1]))
    throw new $i("DID method must be lower-case letters");
  if (t.endsWith(":") || t.endsWith("%"))
    throw new $i('DID can not end with ":" or "%"');
  if (t.length > 2 * 1024)
    throw new $i("DID is too long (2048 chars max)");
};
zi.ensureValidDid = xy;
const Ey = (t) => {
  if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(t))
    throw new $i("DID didn't validate via regex");
  if (t.length > 2 * 1024)
    throw new $i("DID is too long (2048 chars max)");
};
zi.ensureValidDidRegex = Ey;
class $i extends Error {
}
zi.InvalidDidError = $i;
var Hu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidNsidError = t.ensureValidNsidRegex = t.ensureValidNsid = t.NSID = void 0;
  class e {
    static parse(b) {
      return new e(b);
    }
    static create(b, h) {
      const d = [...b.split(".").reverse(), h].join(".");
      return new e(d);
    }
    static isValid(b) {
      try {
        return e.parse(b), !0;
      } catch {
        return !1;
      }
    }
    constructor(b) {
      Object.defineProperty(this, "segments", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: []
      }), (0, t.ensureValidNsid)(b), this.segments = b.split(".");
    }
    get authority() {
      return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
    }
    get name() {
      return this.segments.at(this.segments.length - 1);
    }
    toString() {
      return this.segments.join(".");
    }
  }
  t.NSID = e;
  const r = (y) => {
    const b = y;
    if (!/^[a-zA-Z0-9.-]*$/.test(b))
      throw new u("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
    if (b.length > 317)
      throw new u("NSID is too long (317 chars max)");
    const h = b.split(".");
    if (h.length < 3)
      throw new u("NSID needs at least three parts");
    for (let d = 0; d < h.length; d++) {
      const m = h[d];
      if (m.length < 1)
        throw new u("NSID parts can not be empty");
      if (m.length > 63)
        throw new u("NSID part too long (max 63 chars)");
      if (m.endsWith("-") || m.startsWith("-"))
        throw new u("NSID parts can not start or end with hyphen");
      if (/^[0-9]/.test(m) && d == 0)
        throw new u("NSID first part may not start with a digit");
      if (!/^[a-zA-Z]+$/.test(m) && d + 1 == h.length)
        throw new u("NSID name part must be only letters");
    }
  };
  t.ensureValidNsid = r;
  const n = (y) => {
    if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(y))
      throw new u("NSID didn't validate via regex");
    if (y.length > 317)
      throw new u("NSID is too long (317 chars max)");
  };
  t.ensureValidNsidRegex = n;
  class u extends Error {
  }
  t.InvalidNsidError = u;
})(Hu);
var Qd = {}, da = {};
Object.defineProperty(da, "__esModule", { value: !0 });
da.ensureValidAtUriRegex = da.ensureValidAtUri = void 0;
const ef = zu, tf = zi, rf = Hu, vy = (t) => {
  const e = t.split("#");
  if (e.length > 2)
    throw new Error('ATURI can have at most one "#", separating fragment out');
  const r = e[1] || null;
  if (t = e[0], !/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(t))
    throw new Error("Disallowed characters in ATURI (ASCII)");
  const n = t.split("/");
  if (n.length >= 3 && (n[0] != "at:" || n[1].length != 0))
    throw new Error('ATURI must start with "at://"');
  if (n.length < 3)
    throw new Error("ATURI requires at least method and authority sections");
  try {
    n[2].startsWith("did:") ? (0, tf.ensureValidDid)(n[2]) : (0, ef.ensureValidHandle)(n[2]);
  } catch {
    throw new Error("ATURI authority must be a valid handle or DID");
  }
  if (n.length >= 4) {
    if (n[3].length == 0)
      throw new Error("ATURI can not have a slash after authority without a path segment");
    try {
      (0, rf.ensureValidNsid)(n[3]);
    } catch {
      throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
    }
  }
  if (n.length >= 5 && n[4].length == 0)
    throw new Error("ATURI can not have a slash after collection, unless record key is provided");
  if (n.length >= 6)
    throw new Error("ATURI path can have at most two parts, and no trailing slash");
  if (e.length >= 2 && r == null)
    throw new Error("ATURI fragment must be non-empty and start with slash");
  if (r != null) {
    if (r.length == 0 || r[0] != "/")
      throw new Error("ATURI fragment must be non-empty and start with slash");
    if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(r))
      throw new Error("Disallowed characters in ATURI fragment (ASCII)");
  }
  if (t.length > 8 * 1024)
    throw new Error("ATURI is far too long");
};
da.ensureValidAtUri = vy;
const Ry = (t) => {
  const e = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/, r = t.match(e);
  if (!r || !r.groups)
    throw new Error("ATURI didn't validate via regex");
  const n = r.groups;
  try {
    (0, ef.ensureValidHandleRegex)(n.authority);
  } catch {
    try {
      (0, tf.ensureValidDidRegex)(n.authority);
    } catch {
      throw new Error("ATURI authority must be a valid handle or DID");
    }
  }
  if (n.collection)
    try {
      (0, rf.ensureValidNsidRegex)(n.collection);
    } catch {
      throw new Error("ATURI collection path segment must be a valid NSID");
    }
  if (t.length > 8 * 1024)
    throw new Error("ATURI is far too long");
};
da.ensureValidAtUriRegex = Ry;
(function(t) {
  var e = de && de.__createBinding || (Object.create ? function(h, d, m, p) {
    p === void 0 && (p = m);
    var _ = Object.getOwnPropertyDescriptor(d, m);
    (!_ || ("get" in _ ? !d.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return d[m];
    } }), Object.defineProperty(h, p, _);
  } : function(h, d, m, p) {
    p === void 0 && (p = m), h[p] = d[m];
  }), r = de && de.__exportStar || function(h, d) {
    for (var m in h) m !== "default" && !Object.prototype.hasOwnProperty.call(d, m) && e(d, h, m);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AtUri = t.ATP_URI_REGEX = void 0, r(da, t), t.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
  /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
  const n = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
  class u {
    constructor(d, m) {
      Object.defineProperty(this, "hash", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "host", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "pathname", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "searchParams", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      });
      let p;
      if (m) {
        if (p = y(m), !p)
          throw new Error(`Invalid at uri: ${m}`);
        const _ = b(d);
        if (!_)
          throw new Error(`Invalid path: ${d}`);
        Object.assign(p, _);
      } else if (p = y(d), !p)
        throw new Error(`Invalid at uri: ${d}`);
      this.hash = p.hash, this.host = p.host, this.pathname = p.pathname, this.searchParams = p.searchParams;
    }
    static make(d, m, p) {
      let _ = d;
      return m && (_ += "/" + m), p && (_ += "/" + p), new u(_);
    }
    get protocol() {
      return "at:";
    }
    get origin() {
      return `at://${this.host}`;
    }
    get hostname() {
      return this.host;
    }
    set hostname(d) {
      this.host = d;
    }
    get search() {
      return this.searchParams.toString();
    }
    set search(d) {
      this.searchParams = new URLSearchParams(d);
    }
    get collection() {
      return this.pathname.split("/").filter(Boolean)[0] || "";
    }
    set collection(d) {
      const m = this.pathname.split("/").filter(Boolean);
      m[0] = d, this.pathname = m.join("/");
    }
    get rkey() {
      return this.pathname.split("/").filter(Boolean)[1] || "";
    }
    set rkey(d) {
      const m = this.pathname.split("/").filter(Boolean);
      m[0] || (m[0] = "undefined"), m[1] = d, this.pathname = m.join("/");
    }
    get href() {
      return this.toString();
    }
    toString() {
      let d = this.pathname || "/";
      d.startsWith("/") || (d = `/${d}`);
      let m = this.searchParams.toString();
      m && !m.startsWith("?") && (m = `?${m}`);
      let p = this.hash;
      return p && !p.startsWith("#") && (p = `#${p}`), `at://${this.host}${d}${m}${p}`;
    }
  }
  t.AtUri = u;
  function y(h) {
    const d = t.ATP_URI_REGEX.exec(h);
    if (d)
      return {
        hash: d[5] || "",
        host: d[2] || "",
        pathname: d[3] || "",
        searchParams: new URLSearchParams(d[4] || "")
      };
  }
  function b(h) {
    const d = n.exec(h);
    if (d)
      return {
        hash: d[3] || "",
        pathname: d[1] || "",
        searchParams: new URLSearchParams(d[2] || "")
      };
  }
})(Qd);
var nf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidTidError = t.isValidTid = t.ensureValidTid = void 0;
  const e = (u) => {
    if (u.length != 13)
      throw new n("TID must be 13 characters");
    if (!/^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/.test(u))
      throw new n("TID syntax not valid (regex)");
  };
  t.ensureValidTid = e;
  const r = (u) => {
    try {
      (0, t.ensureValidTid)(u);
    } catch (y) {
      if (y instanceof n)
        return !1;
      throw y;
    }
    return !0;
  };
  t.isValidTid = r;
  class n extends Error {
  }
  t.InvalidTidError = n;
})(nf);
var af = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidRecordKeyError = t.isValidRecordKey = t.ensureValidRecordKey = void 0;
  const e = (u) => {
    if (u.length > 512 || u.length < 1)
      throw new n("record key must be 1 to 512 characters");
    if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(u))
      throw new n("record key syntax not valid (regex)");
    if (u == "." || u == "..")
      throw new n('record key can not be "." or ".."');
  };
  t.ensureValidRecordKey = e;
  const r = (u) => {
    try {
      (0, t.ensureValidRecordKey)(u);
    } catch (y) {
      if (y instanceof n)
        return !1;
      throw y;
    }
    return !0;
  };
  t.isValidRecordKey = r;
  class n extends Error {
  }
  t.InvalidRecordKeyError = n;
})(af);
var sf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidDatetimeError = t.normalizeDatetimeAlways = t.normalizeDatetime = t.isValidDatetime = t.ensureValidDatetime = void 0;
  const e = (b) => {
    const h = new Date(b);
    if (isNaN(h.getTime()))
      throw new y("datetime did not parse as ISO 8601");
    if (h.toISOString().startsWith("-"))
      throw new y("datetime normalized to a negative time");
    if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(b))
      throw new y("datetime didn't validate via regex");
    if (b.length > 64)
      throw new y("datetime is too long (64 chars max)");
    if (b.endsWith("-00:00"))
      throw new y('datetime can not use "-00:00" for UTC timezone');
    if (b.startsWith("000"))
      throw new y("datetime so close to year zero not allowed");
  };
  t.ensureValidDatetime = e;
  const r = (b) => {
    try {
      (0, t.ensureValidDatetime)(b);
    } catch (h) {
      if (h instanceof y)
        return !1;
      throw h;
    }
    return !0;
  };
  t.isValidDatetime = r;
  const n = (b) => {
    if ((0, t.isValidDatetime)(b)) {
      const m = new Date(b).toISOString();
      if ((0, t.isValidDatetime)(m))
        return m;
    }
    if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(b)) {
      const m = /* @__PURE__ */ new Date(b + "Z");
      if (!isNaN(m.getTime())) {
        const p = m.toISOString();
        if ((0, t.isValidDatetime)(p))
          return p;
      }
    }
    const h = new Date(b);
    if (isNaN(h.getTime()))
      throw new y("datetime did not parse as any timestamp format");
    const d = h.toISOString();
    if ((0, t.isValidDatetime)(d))
      return d;
    throw new y("datetime normalized to invalid timestamp string");
  };
  t.normalizeDatetime = n;
  const u = (b) => {
    try {
      return (0, t.normalizeDatetime)(b);
    } catch (h) {
      if (h instanceof y)
        return (/* @__PURE__ */ new Date(0)).toISOString();
      throw h;
    }
  };
  t.normalizeDatetimeAlways = u;
  class y extends Error {
  }
  t.InvalidDatetimeError = y;
})(sf);
(function(t) {
  var e = de && de.__createBinding || (Object.create ? function(n, u, y, b) {
    b === void 0 && (b = y);
    var h = Object.getOwnPropertyDescriptor(u, y);
    (!h || ("get" in h ? !u.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return u[y];
    } }), Object.defineProperty(n, b, h);
  } : function(n, u, y, b) {
    b === void 0 && (b = y), n[b] = u[y];
  }), r = de && de.__exportStar || function(n, u) {
    for (var y in n) y !== "default" && !Object.prototype.hasOwnProperty.call(u, y) && e(u, n, y);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(zu, t), r(zi, t), r(Hu, t), r(Qd, t), r(nf, t), r(af, t), r(sf, t);
})(ra);
var es = {}, Tn = {}, ia = {}, Nu = {}, Ai = {}, Zl = {}, ts = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.getParsedType = t.ZodParsedType = t.objectUtil = t.util = void 0;
  var e;
  (function(n) {
    n.assertEqual = (h) => h;
    function u(h) {
    }
    n.assertIs = u;
    function y(h) {
      throw new Error();
    }
    n.assertNever = y, n.arrayToEnum = (h) => {
      const d = {};
      for (const m of h)
        d[m] = m;
      return d;
    }, n.getValidEnumValues = (h) => {
      const d = n.objectKeys(h).filter((p) => typeof h[h[p]] != "number"), m = {};
      for (const p of d)
        m[p] = h[p];
      return n.objectValues(m);
    }, n.objectValues = (h) => n.objectKeys(h).map(function(d) {
      return h[d];
    }), n.objectKeys = typeof Object.keys == "function" ? (h) => Object.keys(h) : (h) => {
      const d = [];
      for (const m in h)
        Object.prototype.hasOwnProperty.call(h, m) && d.push(m);
      return d;
    }, n.find = (h, d) => {
      for (const m of h)
        if (d(m))
          return m;
    }, n.isInteger = typeof Number.isInteger == "function" ? (h) => Number.isInteger(h) : (h) => typeof h == "number" && isFinite(h) && Math.floor(h) === h;
    function b(h, d = " | ") {
      return h.map((m) => typeof m == "string" ? `'${m}'` : m).join(d);
    }
    n.joinValues = b, n.jsonStringifyReplacer = (h, d) => typeof d == "bigint" ? d.toString() : d;
  })(e = t.util || (t.util = {})), function(n) {
    n.mergeShapes = (u, y) => ({
      ...u,
      ...y
      // second overwrites first
    });
  }(t.objectUtil || (t.objectUtil = {})), t.ZodParsedType = e.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const r = (n) => {
    switch (typeof n) {
      case "undefined":
        return t.ZodParsedType.undefined;
      case "string":
        return t.ZodParsedType.string;
      case "number":
        return isNaN(n) ? t.ZodParsedType.nan : t.ZodParsedType.number;
      case "boolean":
        return t.ZodParsedType.boolean;
      case "function":
        return t.ZodParsedType.function;
      case "bigint":
        return t.ZodParsedType.bigint;
      case "symbol":
        return t.ZodParsedType.symbol;
      case "object":
        return Array.isArray(n) ? t.ZodParsedType.array : n === null ? t.ZodParsedType.null : n.then && typeof n.then == "function" && n.catch && typeof n.catch == "function" ? t.ZodParsedType.promise : typeof Map < "u" && n instanceof Map ? t.ZodParsedType.map : typeof Set < "u" && n instanceof Set ? t.ZodParsedType.set : typeof Date < "u" && n instanceof Date ? t.ZodParsedType.date : t.ZodParsedType.object;
      default:
        return t.ZodParsedType.unknown;
    }
  };
  t.getParsedType = r;
})(ts);
var _i = {};
Object.defineProperty(_i, "__esModule", { value: !0 });
_i.ZodError = _i.quotelessJson = _i.ZodIssueCode = void 0;
const of = ts;
_i.ZodIssueCode = of.util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const Ay = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
_i.quotelessJson = Ay;
class Za extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r = e || function(y) {
      return y.message;
    }, n = { _errors: [] }, u = (y) => {
      for (const b of y.issues)
        if (b.code === "invalid_union")
          b.unionErrors.map(u);
        else if (b.code === "invalid_return_type")
          u(b.returnTypeError);
        else if (b.code === "invalid_arguments")
          u(b.argumentsError);
        else if (b.path.length === 0)
          n._errors.push(r(b));
        else {
          let h = n, d = 0;
          for (; d < b.path.length; ) {
            const m = b.path[d];
            d === b.path.length - 1 ? (h[m] = h[m] || { _errors: [] }, h[m]._errors.push(r(b))) : h[m] = h[m] || { _errors: [] }, h = h[m], d++;
          }
        }
    };
    return u(this), n;
  }
  static assert(e) {
    if (!(e instanceof Za))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, of.util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n = [];
    for (const u of this.issues)
      u.path.length > 0 ? (r[u.path[0]] = r[u.path[0]] || [], r[u.path[0]].push(e(u))) : n.push(e(u));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
_i.ZodError = Za;
Za.create = (t) => new Za(t);
Object.defineProperty(Zl, "__esModule", { value: !0 });
const Pn = ts, lr = _i, _y = (t, e) => {
  let r;
  switch (t.code) {
    case lr.ZodIssueCode.invalid_type:
      t.received === Pn.ZodParsedType.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case lr.ZodIssueCode.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, Pn.util.jsonStringifyReplacer)}`;
      break;
    case lr.ZodIssueCode.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Pn.util.joinValues(t.keys, ", ")}`;
      break;
    case lr.ZodIssueCode.invalid_union:
      r = "Invalid input";
      break;
    case lr.ZodIssueCode.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Pn.util.joinValues(t.options)}`;
      break;
    case lr.ZodIssueCode.invalid_enum_value:
      r = `Invalid enum value. Expected ${Pn.util.joinValues(t.options)}, received '${t.received}'`;
      break;
    case lr.ZodIssueCode.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case lr.ZodIssueCode.invalid_return_type:
      r = "Invalid function return type";
      break;
    case lr.ZodIssueCode.invalid_date:
      r = "Invalid date";
      break;
    case lr.ZodIssueCode.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : Pn.util.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case lr.ZodIssueCode.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case lr.ZodIssueCode.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case lr.ZodIssueCode.custom:
      r = "Invalid input";
      break;
    case lr.ZodIssueCode.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case lr.ZodIssueCode.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case lr.ZodIssueCode.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, Pn.util.assertNever(t);
  }
  return { message: r };
};
Zl.default = _y;
var wy = de && de.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Ai, "__esModule", { value: !0 });
Ai.getErrorMap = Ai.setErrorMap = Ai.defaultErrorMap = void 0;
const lf = wy(Zl);
Ai.defaultErrorMap = lf.default;
let uf = lf.default;
function Ty(t) {
  uf = t;
}
Ai.setErrorMap = Ty;
function Sy() {
  return uf;
}
Ai.getErrorMap = Sy;
var Zu = {};
(function(t) {
  var e = de && de.__importDefault || function(N) {
    return N && N.__esModule ? N : { default: N };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.isAsync = t.isValid = t.isDirty = t.isAborted = t.OK = t.DIRTY = t.INVALID = t.ParseStatus = t.addIssueToContext = t.EMPTY_PATH = t.makeIssue = void 0;
  const r = Ai, n = e(Zl), u = (N) => {
    const { data: X, path: te, errorMaps: re, issueData: J } = N, F = [...te, ...J.path || []], z = {
      ...J,
      path: F
    };
    if (J.message !== void 0)
      return {
        ...J,
        path: F,
        message: J.message
      };
    let ee = "";
    const ye = re.filter((xe) => !!xe).slice().reverse();
    for (const xe of ye)
      ee = xe(z, { data: X, defaultError: ee }).message;
    return {
      ...J,
      path: F,
      message: ee
    };
  };
  t.makeIssue = u, t.EMPTY_PATH = [];
  function y(N, X) {
    const te = (0, r.getErrorMap)(), re = (0, t.makeIssue)({
      issueData: X,
      data: N.data,
      path: N.path,
      errorMaps: [
        N.common.contextualErrorMap,
        N.schemaErrorMap,
        te,
        te === n.default ? void 0 : n.default
        // then global default map
      ].filter((J) => !!J)
    });
    N.common.issues.push(re);
  }
  t.addIssueToContext = y;
  class b {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(X, te) {
      const re = [];
      for (const J of te) {
        if (J.status === "aborted")
          return t.INVALID;
        J.status === "dirty" && X.dirty(), re.push(J.value);
      }
      return { status: X.value, value: re };
    }
    static async mergeObjectAsync(X, te) {
      const re = [];
      for (const J of te) {
        const F = await J.key, z = await J.value;
        re.push({
          key: F,
          value: z
        });
      }
      return b.mergeObjectSync(X, re);
    }
    static mergeObjectSync(X, te) {
      const re = {};
      for (const J of te) {
        const { key: F, value: z } = J;
        if (F.status === "aborted" || z.status === "aborted")
          return t.INVALID;
        F.status === "dirty" && X.dirty(), z.status === "dirty" && X.dirty(), F.value !== "__proto__" && (typeof z.value < "u" || J.alwaysSet) && (re[F.value] = z.value);
      }
      return { status: X.value, value: re };
    }
  }
  t.ParseStatus = b, t.INVALID = Object.freeze({
    status: "aborted"
  });
  const h = (N) => ({ status: "dirty", value: N });
  t.DIRTY = h;
  const d = (N) => ({ status: "valid", value: N });
  t.OK = d;
  const m = (N) => N.status === "aborted";
  t.isAborted = m;
  const p = (N) => N.status === "dirty";
  t.isDirty = p;
  const _ = (N) => N.status === "valid";
  t.isValid = _;
  const B = (N) => typeof Promise < "u" && N instanceof Promise;
  t.isAsync = B;
})(Zu);
var cf = {};
Object.defineProperty(cf, "__esModule", { value: !0 });
var df = {}, ff = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.errorUtil = void 0, function(e) {
    e.errToObj = (r) => typeof r == "string" ? { message: r } : r || {}, e.toString = (r) => typeof r == "string" ? r : r?.message;
  }(t.errorUtil || (t.errorUtil = {}));
})(ff);
(function(t) {
  var e = de && de.__classPrivateFieldGet || function(O, c, R, L) {
    if (R === "a" && !L) throw new TypeError("Private accessor was defined without a getter");
    if (typeof c == "function" ? O !== c || !L : !c.has(O)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return R === "m" ? L : R === "a" ? L.call(O) : L ? L.value : c.get(O);
  }, r = de && de.__classPrivateFieldSet || function(O, c, R, L, K) {
    if (L === "m") throw new TypeError("Private method is not writable");
    if (L === "a" && !K) throw new TypeError("Private accessor was defined without a setter");
    if (typeof c == "function" ? O !== c || !K : !c.has(O)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return L === "a" ? K.call(O, R) : K ? K.value = R : c.set(O, R), R;
  }, n, u;
  Object.defineProperty(t, "__esModule", { value: !0 }), t.boolean = t.bigint = t.array = t.any = t.coerce = t.ZodFirstPartyTypeKind = t.late = t.ZodSchema = t.Schema = t.custom = t.ZodReadonly = t.ZodPipeline = t.ZodBranded = t.BRAND = t.ZodNaN = t.ZodCatch = t.ZodDefault = t.ZodNullable = t.ZodOptional = t.ZodTransformer = t.ZodEffects = t.ZodPromise = t.ZodNativeEnum = t.ZodEnum = t.ZodLiteral = t.ZodLazy = t.ZodFunction = t.ZodSet = t.ZodMap = t.ZodRecord = t.ZodTuple = t.ZodIntersection = t.ZodDiscriminatedUnion = t.ZodUnion = t.ZodObject = t.ZodArray = t.ZodVoid = t.ZodNever = t.ZodUnknown = t.ZodAny = t.ZodNull = t.ZodUndefined = t.ZodSymbol = t.ZodDate = t.ZodBoolean = t.ZodBigInt = t.ZodNumber = t.ZodString = t.datetimeRegex = t.ZodType = void 0, t.NEVER = t.void = t.unknown = t.union = t.undefined = t.tuple = t.transformer = t.symbol = t.string = t.strictObject = t.set = t.record = t.promise = t.preprocess = t.pipeline = t.ostring = t.optional = t.onumber = t.oboolean = t.object = t.number = t.nullable = t.null = t.never = t.nativeEnum = t.nan = t.map = t.literal = t.lazy = t.intersection = t.instanceof = t.function = t.enum = t.effect = t.discriminatedUnion = t.date = void 0;
  const y = Ai, b = ff, h = Zu, d = ts, m = _i;
  class p {
    constructor(c, R, L, K) {
      this._cachedPath = [], this.parent = c, this.data = R, this._path = L, this._key = K;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const _ = (O, c) => {
    if ((0, h.isValid)(c))
      return { success: !0, data: c.value };
    if (!O.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        const R = new m.ZodError(O.common.issues);
        return this._error = R, this._error;
      }
    };
  };
  function B(O) {
    if (!O)
      return {};
    const { errorMap: c, invalid_type_error: R, required_error: L, description: K } = O;
    if (c && (R || L))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return c ? { errorMap: c, description: K } : { errorMap: (ce, se) => {
      var _e, we;
      const { message: Oe } = O;
      return ce.code === "invalid_enum_value" ? { message: Oe ?? se.defaultError } : typeof se.data > "u" ? { message: (_e = Oe ?? L) !== null && _e !== void 0 ? _e : se.defaultError } : ce.code !== "invalid_type" ? { message: se.defaultError } : { message: (we = Oe ?? R) !== null && we !== void 0 ? we : se.defaultError };
    }, description: K };
  }
  class N {
    constructor(c) {
      this.spa = this.safeParseAsync, this._def = c, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(c) {
      return (0, d.getParsedType)(c.data);
    }
    _getOrReturnCtx(c, R) {
      return R || {
        common: c.parent.common,
        data: c.data,
        parsedType: (0, d.getParsedType)(c.data),
        schemaErrorMap: this._def.errorMap,
        path: c.path,
        parent: c.parent
      };
    }
    _processInputParams(c) {
      return {
        status: new h.ParseStatus(),
        ctx: {
          common: c.parent.common,
          data: c.data,
          parsedType: (0, d.getParsedType)(c.data),
          schemaErrorMap: this._def.errorMap,
          path: c.path,
          parent: c.parent
        }
      };
    }
    _parseSync(c) {
      const R = this._parse(c);
      if ((0, h.isAsync)(R))
        throw new Error("Synchronous parse encountered promise.");
      return R;
    }
    _parseAsync(c) {
      const R = this._parse(c);
      return Promise.resolve(R);
    }
    parse(c, R) {
      const L = this.safeParse(c, R);
      if (L.success)
        return L.data;
      throw L.error;
    }
    safeParse(c, R) {
      var L;
      const K = {
        common: {
          issues: [],
          async: (L = R?.async) !== null && L !== void 0 ? L : !1,
          contextualErrorMap: R?.errorMap
        },
        path: R?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: c,
        parsedType: (0, d.getParsedType)(c)
      }, V = this._parseSync({ data: c, path: K.path, parent: K });
      return _(K, V);
    }
    async parseAsync(c, R) {
      const L = await this.safeParseAsync(c, R);
      if (L.success)
        return L.data;
      throw L.error;
    }
    async safeParseAsync(c, R) {
      const L = {
        common: {
          issues: [],
          contextualErrorMap: R?.errorMap,
          async: !0
        },
        path: R?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: c,
        parsedType: (0, d.getParsedType)(c)
      }, K = this._parse({ data: c, path: L.path, parent: L }), V = await ((0, h.isAsync)(K) ? K : Promise.resolve(K));
      return _(L, V);
    }
    refine(c, R) {
      const L = (K) => typeof R == "string" || typeof R > "u" ? { message: R } : typeof R == "function" ? R(K) : R;
      return this._refinement((K, V) => {
        const ce = c(K), se = () => V.addIssue({
          code: m.ZodIssueCode.custom,
          ...L(K)
        });
        return typeof Promise < "u" && ce instanceof Promise ? ce.then((_e) => _e ? !0 : (se(), !1)) : ce ? !0 : (se(), !1);
      });
    }
    refinement(c, R) {
      return this._refinement((L, K) => c(L) ? !0 : (K.addIssue(typeof R == "function" ? R(L, K) : R), !1));
    }
    _refinement(c) {
      return new U({
        schema: this,
        typeName: Q.ZodEffects,
        effect: { type: "refinement", refinement: c }
      });
    }
    superRefine(c) {
      return this._refinement(c);
    }
    optional() {
      return q.create(this, this._def);
    }
    nullable() {
      return G.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return mt.create(this, this._def);
    }
    promise() {
      return P.create(this, this._def);
    }
    or(c) {
      return Gt.create([this, c], this._def);
    }
    and(c) {
      return Ot.create(this, c, this._def);
    }
    transform(c) {
      return new U({
        ...B(this._def),
        schema: this,
        typeName: Q.ZodEffects,
        effect: { type: "transform", transform: c }
      });
    }
    default(c) {
      const R = typeof c == "function" ? c : () => c;
      return new W({
        ...B(this._def),
        innerType: this,
        defaultValue: R,
        typeName: Q.ZodDefault
      });
    }
    brand() {
      return new ue({
        typeName: Q.ZodBranded,
        type: this,
        ...B(this._def)
      });
    }
    catch(c) {
      const R = typeof c == "function" ? c : () => c;
      return new ie({
        ...B(this._def),
        innerType: this,
        catchValue: R,
        typeName: Q.ZodCatch
      });
    }
    describe(c) {
      const R = this.constructor;
      return new R({
        ...this._def,
        description: c
      });
    }
    pipe(c) {
      return ae.create(this, c);
    }
    readonly() {
      return me.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  t.ZodType = N, t.Schema = N, t.ZodSchema = N;
  const X = /^c[^\s-]{8,}$/i, te = /^[0-9a-z]+$/, re = /^[0-9A-HJKMNP-TV-Z]{26}$/, J = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, F = /^[a-z0-9_-]{21}$/i, z = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, ee = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, ye = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  let xe;
  const Ee = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ae = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, De = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Ue = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Ve = new RegExp(`^${Ue}$`);
  function tt(O) {
    let c = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return O.precision ? c = `${c}\\.\\d{${O.precision}}` : O.precision == null && (c = `${c}(\\.\\d+)?`), c;
  }
  function dt(O) {
    return new RegExp(`^${tt(O)}$`);
  }
  function ft(O) {
    let c = `${Ue}T${tt(O)}`;
    const R = [];
    return R.push(O.local ? "Z?" : "Z"), O.offset && R.push("([+-]\\d{2}:?\\d{2})"), c = `${c}(${R.join("|")})`, new RegExp(`^${c}$`);
  }
  t.datetimeRegex = ft;
  function $t(O, c) {
    return !!((c === "v4" || !c) && Ee.test(O) || (c === "v6" || !c) && Ae.test(O));
  }
  class ze extends N {
    _parse(c) {
      if (this._def.coerce && (c.data = String(c.data)), this._getType(c) !== d.ZodParsedType.string) {
        const V = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(V, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.string,
          received: V.parsedType
        }), h.INVALID;
      }
      const L = new h.ParseStatus();
      let K;
      for (const V of this._def.checks)
        if (V.kind === "min")
          c.data.length < V.value && (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
            code: m.ZodIssueCode.too_small,
            minimum: V.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: V.message
          }), L.dirty());
        else if (V.kind === "max")
          c.data.length > V.value && (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
            code: m.ZodIssueCode.too_big,
            maximum: V.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: V.message
          }), L.dirty());
        else if (V.kind === "length") {
          const ce = c.data.length > V.value, se = c.data.length < V.value;
          (ce || se) && (K = this._getOrReturnCtx(c, K), ce ? (0, h.addIssueToContext)(K, {
            code: m.ZodIssueCode.too_big,
            maximum: V.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: V.message
          }) : se && (0, h.addIssueToContext)(K, {
            code: m.ZodIssueCode.too_small,
            minimum: V.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: V.message
          }), L.dirty());
        } else if (V.kind === "email")
          ee.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
            validation: "email",
            code: m.ZodIssueCode.invalid_string,
            message: V.message
          }), L.dirty());
        else if (V.kind === "emoji")
          xe || (xe = new RegExp(ye, "u")), xe.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
            validation: "emoji",
            code: m.ZodIssueCode.invalid_string,
            message: V.message
          }), L.dirty());
        else if (V.kind === "uuid")
          J.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
            validation: "uuid",
            code: m.ZodIssueCode.invalid_string,
            message: V.message
          }), L.dirty());
        else if (V.kind === "nanoid")
          F.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
            validation: "nanoid",
            code: m.ZodIssueCode.invalid_string,
            message: V.message
          }), L.dirty());
        else if (V.kind === "cuid")
          X.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
            validation: "cuid",
            code: m.ZodIssueCode.invalid_string,
            message: V.message
          }), L.dirty());
        else if (V.kind === "cuid2")
          te.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
            validation: "cuid2",
            code: m.ZodIssueCode.invalid_string,
            message: V.message
          }), L.dirty());
        else if (V.kind === "ulid")
          re.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
            validation: "ulid",
            code: m.ZodIssueCode.invalid_string,
            message: V.message
          }), L.dirty());
        else if (V.kind === "url")
          try {
            new URL(c.data);
          } catch {
            K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
              validation: "url",
              code: m.ZodIssueCode.invalid_string,
              message: V.message
            }), L.dirty();
          }
        else V.kind === "regex" ? (V.regex.lastIndex = 0, V.regex.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          validation: "regex",
          code: m.ZodIssueCode.invalid_string,
          message: V.message
        }), L.dirty())) : V.kind === "trim" ? c.data = c.data.trim() : V.kind === "includes" ? c.data.includes(V.value, V.position) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          code: m.ZodIssueCode.invalid_string,
          validation: { includes: V.value, position: V.position },
          message: V.message
        }), L.dirty()) : V.kind === "toLowerCase" ? c.data = c.data.toLowerCase() : V.kind === "toUpperCase" ? c.data = c.data.toUpperCase() : V.kind === "startsWith" ? c.data.startsWith(V.value) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          code: m.ZodIssueCode.invalid_string,
          validation: { startsWith: V.value },
          message: V.message
        }), L.dirty()) : V.kind === "endsWith" ? c.data.endsWith(V.value) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          code: m.ZodIssueCode.invalid_string,
          validation: { endsWith: V.value },
          message: V.message
        }), L.dirty()) : V.kind === "datetime" ? ft(V).test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          code: m.ZodIssueCode.invalid_string,
          validation: "datetime",
          message: V.message
        }), L.dirty()) : V.kind === "date" ? Ve.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          code: m.ZodIssueCode.invalid_string,
          validation: "date",
          message: V.message
        }), L.dirty()) : V.kind === "time" ? dt(V).test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          code: m.ZodIssueCode.invalid_string,
          validation: "time",
          message: V.message
        }), L.dirty()) : V.kind === "duration" ? z.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          validation: "duration",
          code: m.ZodIssueCode.invalid_string,
          message: V.message
        }), L.dirty()) : V.kind === "ip" ? $t(c.data, V.version) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          validation: "ip",
          code: m.ZodIssueCode.invalid_string,
          message: V.message
        }), L.dirty()) : V.kind === "base64" ? De.test(c.data) || (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          validation: "base64",
          code: m.ZodIssueCode.invalid_string,
          message: V.message
        }), L.dirty()) : d.util.assertNever(V);
      return { status: L.value, value: c.data };
    }
    _regex(c, R, L) {
      return this.refinement((K) => c.test(K), {
        validation: R,
        code: m.ZodIssueCode.invalid_string,
        ...b.errorUtil.errToObj(L)
      });
    }
    _addCheck(c) {
      return new ze({
        ...this._def,
        checks: [...this._def.checks, c]
      });
    }
    email(c) {
      return this._addCheck({ kind: "email", ...b.errorUtil.errToObj(c) });
    }
    url(c) {
      return this._addCheck({ kind: "url", ...b.errorUtil.errToObj(c) });
    }
    emoji(c) {
      return this._addCheck({ kind: "emoji", ...b.errorUtil.errToObj(c) });
    }
    uuid(c) {
      return this._addCheck({ kind: "uuid", ...b.errorUtil.errToObj(c) });
    }
    nanoid(c) {
      return this._addCheck({ kind: "nanoid", ...b.errorUtil.errToObj(c) });
    }
    cuid(c) {
      return this._addCheck({ kind: "cuid", ...b.errorUtil.errToObj(c) });
    }
    cuid2(c) {
      return this._addCheck({ kind: "cuid2", ...b.errorUtil.errToObj(c) });
    }
    ulid(c) {
      return this._addCheck({ kind: "ulid", ...b.errorUtil.errToObj(c) });
    }
    base64(c) {
      return this._addCheck({ kind: "base64", ...b.errorUtil.errToObj(c) });
    }
    ip(c) {
      return this._addCheck({ kind: "ip", ...b.errorUtil.errToObj(c) });
    }
    datetime(c) {
      var R, L;
      return typeof c == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: c
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof c?.precision > "u" ? null : c?.precision,
        offset: (R = c?.offset) !== null && R !== void 0 ? R : !1,
        local: (L = c?.local) !== null && L !== void 0 ? L : !1,
        ...b.errorUtil.errToObj(c?.message)
      });
    }
    date(c) {
      return this._addCheck({ kind: "date", message: c });
    }
    time(c) {
      return typeof c == "string" ? this._addCheck({
        kind: "time",
        precision: null,
        message: c
      }) : this._addCheck({
        kind: "time",
        precision: typeof c?.precision > "u" ? null : c?.precision,
        ...b.errorUtil.errToObj(c?.message)
      });
    }
    duration(c) {
      return this._addCheck({ kind: "duration", ...b.errorUtil.errToObj(c) });
    }
    regex(c, R) {
      return this._addCheck({
        kind: "regex",
        regex: c,
        ...b.errorUtil.errToObj(R)
      });
    }
    includes(c, R) {
      return this._addCheck({
        kind: "includes",
        value: c,
        position: R?.position,
        ...b.errorUtil.errToObj(R?.message)
      });
    }
    startsWith(c, R) {
      return this._addCheck({
        kind: "startsWith",
        value: c,
        ...b.errorUtil.errToObj(R)
      });
    }
    endsWith(c, R) {
      return this._addCheck({
        kind: "endsWith",
        value: c,
        ...b.errorUtil.errToObj(R)
      });
    }
    min(c, R) {
      return this._addCheck({
        kind: "min",
        value: c,
        ...b.errorUtil.errToObj(R)
      });
    }
    max(c, R) {
      return this._addCheck({
        kind: "max",
        value: c,
        ...b.errorUtil.errToObj(R)
      });
    }
    length(c, R) {
      return this._addCheck({
        kind: "length",
        value: c,
        ...b.errorUtil.errToObj(R)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(c) {
      return this.min(1, b.errorUtil.errToObj(c));
    }
    trim() {
      return new ze({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ze({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ze({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((c) => c.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((c) => c.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((c) => c.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((c) => c.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((c) => c.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((c) => c.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((c) => c.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((c) => c.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((c) => c.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((c) => c.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((c) => c.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((c) => c.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((c) => c.kind === "ip");
    }
    get isBase64() {
      return !!this._def.checks.find((c) => c.kind === "base64");
    }
    get minLength() {
      let c = null;
      for (const R of this._def.checks)
        R.kind === "min" && (c === null || R.value > c) && (c = R.value);
      return c;
    }
    get maxLength() {
      let c = null;
      for (const R of this._def.checks)
        R.kind === "max" && (c === null || R.value < c) && (c = R.value);
      return c;
    }
  }
  t.ZodString = ze, ze.create = (O) => {
    var c;
    return new ze({
      checks: [],
      typeName: Q.ZodString,
      coerce: (c = O?.coerce) !== null && c !== void 0 ? c : !1,
      ...B(O)
    });
  };
  function Tt(O, c) {
    const R = (O.toString().split(".")[1] || "").length, L = (c.toString().split(".")[1] || "").length, K = R > L ? R : L, V = parseInt(O.toFixed(K).replace(".", "")), ce = parseInt(c.toFixed(K).replace(".", ""));
    return V % ce / Math.pow(10, K);
  }
  class pt extends N {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(c) {
      if (this._def.coerce && (c.data = Number(c.data)), this._getType(c) !== d.ZodParsedType.number) {
        const V = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(V, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.number,
          received: V.parsedType
        }), h.INVALID;
      }
      let L;
      const K = new h.ParseStatus();
      for (const V of this._def.checks)
        V.kind === "int" ? d.util.isInteger(c.data) || (L = this._getOrReturnCtx(c, L), (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: V.message
        }), K.dirty()) : V.kind === "min" ? (V.inclusive ? c.data < V.value : c.data <= V.value) && (L = this._getOrReturnCtx(c, L), (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.too_small,
          minimum: V.value,
          type: "number",
          inclusive: V.inclusive,
          exact: !1,
          message: V.message
        }), K.dirty()) : V.kind === "max" ? (V.inclusive ? c.data > V.value : c.data >= V.value) && (L = this._getOrReturnCtx(c, L), (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.too_big,
          maximum: V.value,
          type: "number",
          inclusive: V.inclusive,
          exact: !1,
          message: V.message
        }), K.dirty()) : V.kind === "multipleOf" ? Tt(c.data, V.value) !== 0 && (L = this._getOrReturnCtx(c, L), (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.not_multiple_of,
          multipleOf: V.value,
          message: V.message
        }), K.dirty()) : V.kind === "finite" ? Number.isFinite(c.data) || (L = this._getOrReturnCtx(c, L), (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.not_finite,
          message: V.message
        }), K.dirty()) : d.util.assertNever(V);
      return { status: K.value, value: c.data };
    }
    gte(c, R) {
      return this.setLimit("min", c, !0, b.errorUtil.toString(R));
    }
    gt(c, R) {
      return this.setLimit("min", c, !1, b.errorUtil.toString(R));
    }
    lte(c, R) {
      return this.setLimit("max", c, !0, b.errorUtil.toString(R));
    }
    lt(c, R) {
      return this.setLimit("max", c, !1, b.errorUtil.toString(R));
    }
    setLimit(c, R, L, K) {
      return new pt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: c,
            value: R,
            inclusive: L,
            message: b.errorUtil.toString(K)
          }
        ]
      });
    }
    _addCheck(c) {
      return new pt({
        ...this._def,
        checks: [...this._def.checks, c]
      });
    }
    int(c) {
      return this._addCheck({
        kind: "int",
        message: b.errorUtil.toString(c)
      });
    }
    positive(c) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: b.errorUtil.toString(c)
      });
    }
    negative(c) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: b.errorUtil.toString(c)
      });
    }
    nonpositive(c) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: b.errorUtil.toString(c)
      });
    }
    nonnegative(c) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: b.errorUtil.toString(c)
      });
    }
    multipleOf(c, R) {
      return this._addCheck({
        kind: "multipleOf",
        value: c,
        message: b.errorUtil.toString(R)
      });
    }
    finite(c) {
      return this._addCheck({
        kind: "finite",
        message: b.errorUtil.toString(c)
      });
    }
    safe(c) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: b.errorUtil.toString(c)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: b.errorUtil.toString(c)
      });
    }
    get minValue() {
      let c = null;
      for (const R of this._def.checks)
        R.kind === "min" && (c === null || R.value > c) && (c = R.value);
      return c;
    }
    get maxValue() {
      let c = null;
      for (const R of this._def.checks)
        R.kind === "max" && (c === null || R.value < c) && (c = R.value);
      return c;
    }
    get isInt() {
      return !!this._def.checks.find((c) => c.kind === "int" || c.kind === "multipleOf" && d.util.isInteger(c.value));
    }
    get isFinite() {
      let c = null, R = null;
      for (const L of this._def.checks) {
        if (L.kind === "finite" || L.kind === "int" || L.kind === "multipleOf")
          return !0;
        L.kind === "min" ? (R === null || L.value > R) && (R = L.value) : L.kind === "max" && (c === null || L.value < c) && (c = L.value);
      }
      return Number.isFinite(R) && Number.isFinite(c);
    }
  }
  t.ZodNumber = pt, pt.create = (O) => new pt({
    checks: [],
    typeName: Q.ZodNumber,
    coerce: O?.coerce || !1,
    ...B(O)
  });
  class st extends N {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(c) {
      if (this._def.coerce && (c.data = BigInt(c.data)), this._getType(c) !== d.ZodParsedType.bigint) {
        const V = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(V, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.bigint,
          received: V.parsedType
        }), h.INVALID;
      }
      let L;
      const K = new h.ParseStatus();
      for (const V of this._def.checks)
        V.kind === "min" ? (V.inclusive ? c.data < V.value : c.data <= V.value) && (L = this._getOrReturnCtx(c, L), (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.too_small,
          type: "bigint",
          minimum: V.value,
          inclusive: V.inclusive,
          message: V.message
        }), K.dirty()) : V.kind === "max" ? (V.inclusive ? c.data > V.value : c.data >= V.value) && (L = this._getOrReturnCtx(c, L), (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.too_big,
          type: "bigint",
          maximum: V.value,
          inclusive: V.inclusive,
          message: V.message
        }), K.dirty()) : V.kind === "multipleOf" ? c.data % V.value !== BigInt(0) && (L = this._getOrReturnCtx(c, L), (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.not_multiple_of,
          multipleOf: V.value,
          message: V.message
        }), K.dirty()) : d.util.assertNever(V);
      return { status: K.value, value: c.data };
    }
    gte(c, R) {
      return this.setLimit("min", c, !0, b.errorUtil.toString(R));
    }
    gt(c, R) {
      return this.setLimit("min", c, !1, b.errorUtil.toString(R));
    }
    lte(c, R) {
      return this.setLimit("max", c, !0, b.errorUtil.toString(R));
    }
    lt(c, R) {
      return this.setLimit("max", c, !1, b.errorUtil.toString(R));
    }
    setLimit(c, R, L, K) {
      return new st({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: c,
            value: R,
            inclusive: L,
            message: b.errorUtil.toString(K)
          }
        ]
      });
    }
    _addCheck(c) {
      return new st({
        ...this._def,
        checks: [...this._def.checks, c]
      });
    }
    positive(c) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: b.errorUtil.toString(c)
      });
    }
    negative(c) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: b.errorUtil.toString(c)
      });
    }
    nonpositive(c) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: b.errorUtil.toString(c)
      });
    }
    nonnegative(c) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: b.errorUtil.toString(c)
      });
    }
    multipleOf(c, R) {
      return this._addCheck({
        kind: "multipleOf",
        value: c,
        message: b.errorUtil.toString(R)
      });
    }
    get minValue() {
      let c = null;
      for (const R of this._def.checks)
        R.kind === "min" && (c === null || R.value > c) && (c = R.value);
      return c;
    }
    get maxValue() {
      let c = null;
      for (const R of this._def.checks)
        R.kind === "max" && (c === null || R.value < c) && (c = R.value);
      return c;
    }
  }
  t.ZodBigInt = st, st.create = (O) => {
    var c;
    return new st({
      checks: [],
      typeName: Q.ZodBigInt,
      coerce: (c = O?.coerce) !== null && c !== void 0 ? c : !1,
      ...B(O)
    });
  };
  class rt extends N {
    _parse(c) {
      if (this._def.coerce && (c.data = !!c.data), this._getType(c) !== d.ZodParsedType.boolean) {
        const L = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.boolean,
          received: L.parsedType
        }), h.INVALID;
      }
      return (0, h.OK)(c.data);
    }
  }
  t.ZodBoolean = rt, rt.create = (O) => new rt({
    typeName: Q.ZodBoolean,
    coerce: O?.coerce || !1,
    ...B(O)
  });
  class ht extends N {
    _parse(c) {
      if (this._def.coerce && (c.data = new Date(c.data)), this._getType(c) !== d.ZodParsedType.date) {
        const V = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(V, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.date,
          received: V.parsedType
        }), h.INVALID;
      }
      if (isNaN(c.data.getTime())) {
        const V = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(V, {
          code: m.ZodIssueCode.invalid_date
        }), h.INVALID;
      }
      const L = new h.ParseStatus();
      let K;
      for (const V of this._def.checks)
        V.kind === "min" ? c.data.getTime() < V.value && (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          code: m.ZodIssueCode.too_small,
          message: V.message,
          inclusive: !0,
          exact: !1,
          minimum: V.value,
          type: "date"
        }), L.dirty()) : V.kind === "max" ? c.data.getTime() > V.value && (K = this._getOrReturnCtx(c, K), (0, h.addIssueToContext)(K, {
          code: m.ZodIssueCode.too_big,
          message: V.message,
          inclusive: !0,
          exact: !1,
          maximum: V.value,
          type: "date"
        }), L.dirty()) : d.util.assertNever(V);
      return {
        status: L.value,
        value: new Date(c.data.getTime())
      };
    }
    _addCheck(c) {
      return new ht({
        ...this._def,
        checks: [...this._def.checks, c]
      });
    }
    min(c, R) {
      return this._addCheck({
        kind: "min",
        value: c.getTime(),
        message: b.errorUtil.toString(R)
      });
    }
    max(c, R) {
      return this._addCheck({
        kind: "max",
        value: c.getTime(),
        message: b.errorUtil.toString(R)
      });
    }
    get minDate() {
      let c = null;
      for (const R of this._def.checks)
        R.kind === "min" && (c === null || R.value > c) && (c = R.value);
      return c != null ? new Date(c) : null;
    }
    get maxDate() {
      let c = null;
      for (const R of this._def.checks)
        R.kind === "max" && (c === null || R.value < c) && (c = R.value);
      return c != null ? new Date(c) : null;
    }
  }
  t.ZodDate = ht, ht.create = (O) => new ht({
    checks: [],
    coerce: O?.coerce || !1,
    typeName: Q.ZodDate,
    ...B(O)
  });
  class Fe extends N {
    _parse(c) {
      if (this._getType(c) !== d.ZodParsedType.symbol) {
        const L = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.symbol,
          received: L.parsedType
        }), h.INVALID;
      }
      return (0, h.OK)(c.data);
    }
  }
  t.ZodSymbol = Fe, Fe.create = (O) => new Fe({
    typeName: Q.ZodSymbol,
    ...B(O)
  });
  class tr extends N {
    _parse(c) {
      if (this._getType(c) !== d.ZodParsedType.undefined) {
        const L = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.undefined,
          received: L.parsedType
        }), h.INVALID;
      }
      return (0, h.OK)(c.data);
    }
  }
  t.ZodUndefined = tr, tr.create = (O) => new tr({
    typeName: Q.ZodUndefined,
    ...B(O)
  });
  class it extends N {
    _parse(c) {
      if (this._getType(c) !== d.ZodParsedType.null) {
        const L = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.null,
          received: L.parsedType
        }), h.INVALID;
      }
      return (0, h.OK)(c.data);
    }
  }
  t.ZodNull = it, it.create = (O) => new it({
    typeName: Q.ZodNull,
    ...B(O)
  });
  class yr extends N {
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(c) {
      return (0, h.OK)(c.data);
    }
  }
  t.ZodAny = yr, yr.create = (O) => new yr({
    typeName: Q.ZodAny,
    ...B(O)
  });
  class St extends N {
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(c) {
      return (0, h.OK)(c.data);
    }
  }
  t.ZodUnknown = St, St.create = (O) => new St({
    typeName: Q.ZodUnknown,
    ...B(O)
  });
  class xt extends N {
    _parse(c) {
      const R = this._getOrReturnCtx(c);
      return (0, h.addIssueToContext)(R, {
        code: m.ZodIssueCode.invalid_type,
        expected: d.ZodParsedType.never,
        received: R.parsedType
      }), h.INVALID;
    }
  }
  t.ZodNever = xt, xt.create = (O) => new xt({
    typeName: Q.ZodNever,
    ...B(O)
  });
  class Ct extends N {
    _parse(c) {
      if (this._getType(c) !== d.ZodParsedType.undefined) {
        const L = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.void,
          received: L.parsedType
        }), h.INVALID;
      }
      return (0, h.OK)(c.data);
    }
  }
  t.ZodVoid = Ct, Ct.create = (O) => new Ct({
    typeName: Q.ZodVoid,
    ...B(O)
  });
  class mt extends N {
    _parse(c) {
      const { ctx: R, status: L } = this._processInputParams(c), K = this._def;
      if (R.parsedType !== d.ZodParsedType.array)
        return (0, h.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.array,
          received: R.parsedType
        }), h.INVALID;
      if (K.exactLength !== null) {
        const ce = R.data.length > K.exactLength.value, se = R.data.length < K.exactLength.value;
        (ce || se) && ((0, h.addIssueToContext)(R, {
          code: ce ? m.ZodIssueCode.too_big : m.ZodIssueCode.too_small,
          minimum: se ? K.exactLength.value : void 0,
          maximum: ce ? K.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: K.exactLength.message
        }), L.dirty());
      }
      if (K.minLength !== null && R.data.length < K.minLength.value && ((0, h.addIssueToContext)(R, {
        code: m.ZodIssueCode.too_small,
        minimum: K.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: K.minLength.message
      }), L.dirty()), K.maxLength !== null && R.data.length > K.maxLength.value && ((0, h.addIssueToContext)(R, {
        code: m.ZodIssueCode.too_big,
        maximum: K.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: K.maxLength.message
      }), L.dirty()), R.common.async)
        return Promise.all([...R.data].map((ce, se) => K.type._parseAsync(new p(R, ce, R.path, se)))).then((ce) => h.ParseStatus.mergeArray(L, ce));
      const V = [...R.data].map((ce, se) => K.type._parseSync(new p(R, ce, R.path, se)));
      return h.ParseStatus.mergeArray(L, V);
    }
    get element() {
      return this._def.type;
    }
    min(c, R) {
      return new mt({
        ...this._def,
        minLength: { value: c, message: b.errorUtil.toString(R) }
      });
    }
    max(c, R) {
      return new mt({
        ...this._def,
        maxLength: { value: c, message: b.errorUtil.toString(R) }
      });
    }
    length(c, R) {
      return new mt({
        ...this._def,
        exactLength: { value: c, message: b.errorUtil.toString(R) }
      });
    }
    nonempty(c) {
      return this.min(1, c);
    }
  }
  t.ZodArray = mt, mt.create = (O, c) => new mt({
    type: O,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: Q.ZodArray,
    ...B(c)
  });
  function Ut(O) {
    if (O instanceof Ze) {
      const c = {};
      for (const R in O.shape) {
        const L = O.shape[R];
        c[R] = q.create(Ut(L));
      }
      return new Ze({
        ...O._def,
        shape: () => c
      });
    } else return O instanceof mt ? new mt({
      ...O._def,
      type: Ut(O.element)
    }) : O instanceof q ? q.create(Ut(O.unwrap())) : O instanceof G ? G.create(Ut(O.unwrap())) : O instanceof _r ? _r.create(O.items.map((c) => Ut(c))) : O;
  }
  class Ze extends N {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const c = this._def.shape(), R = d.util.objectKeys(c);
      return this._cached = { shape: c, keys: R };
    }
    _parse(c) {
      if (this._getType(c) !== d.ZodParsedType.object) {
        const we = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(we, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.object,
          received: we.parsedType
        }), h.INVALID;
      }
      const { status: L, ctx: K } = this._processInputParams(c), { shape: V, keys: ce } = this._getCached(), se = [];
      if (!(this._def.catchall instanceof xt && this._def.unknownKeys === "strip"))
        for (const we in K.data)
          ce.includes(we) || se.push(we);
      const _e = [];
      for (const we of ce) {
        const Oe = V[we], wr = K.data[we];
        _e.push({
          key: { status: "valid", value: we },
          value: Oe._parse(new p(K, wr, K.path, we)),
          alwaysSet: we in K.data
        });
      }
      if (this._def.catchall instanceof xt) {
        const we = this._def.unknownKeys;
        if (we === "passthrough")
          for (const Oe of se)
            _e.push({
              key: { status: "valid", value: Oe },
              value: { status: "valid", value: K.data[Oe] }
            });
        else if (we === "strict")
          se.length > 0 && ((0, h.addIssueToContext)(K, {
            code: m.ZodIssueCode.unrecognized_keys,
            keys: se
          }), L.dirty());
        else if (we !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const we = this._def.catchall;
        for (const Oe of se) {
          const wr = K.data[Oe];
          _e.push({
            key: { status: "valid", value: Oe },
            value: we._parse(
              new p(K, wr, K.path, Oe)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: Oe in K.data
          });
        }
      }
      return K.common.async ? Promise.resolve().then(async () => {
        const we = [];
        for (const Oe of _e) {
          const wr = await Oe.key, gl = await Oe.value;
          we.push({
            key: wr,
            value: gl,
            alwaysSet: Oe.alwaysSet
          });
        }
        return we;
      }).then((we) => h.ParseStatus.mergeObjectSync(L, we)) : h.ParseStatus.mergeObjectSync(L, _e);
    }
    get shape() {
      return this._def.shape();
    }
    strict(c) {
      return b.errorUtil.errToObj, new Ze({
        ...this._def,
        unknownKeys: "strict",
        ...c !== void 0 ? {
          errorMap: (R, L) => {
            var K, V, ce, se;
            const _e = (ce = (V = (K = this._def).errorMap) === null || V === void 0 ? void 0 : V.call(K, R, L).message) !== null && ce !== void 0 ? ce : L.defaultError;
            return R.code === "unrecognized_keys" ? {
              message: (se = b.errorUtil.errToObj(c).message) !== null && se !== void 0 ? se : _e
            } : {
              message: _e
            };
          }
        } : {}
      });
    }
    strip() {
      return new Ze({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new Ze({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(c) {
      return new Ze({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...c
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(c) {
      return new Ze({
        unknownKeys: c._def.unknownKeys,
        catchall: c._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...c._def.shape()
        }),
        typeName: Q.ZodObject
      });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(c, R) {
      return this.augment({ [c]: R });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(c) {
      return new Ze({
        ...this._def,
        catchall: c
      });
    }
    pick(c) {
      const R = {};
      return d.util.objectKeys(c).forEach((L) => {
        c[L] && this.shape[L] && (R[L] = this.shape[L]);
      }), new Ze({
        ...this._def,
        shape: () => R
      });
    }
    omit(c) {
      const R = {};
      return d.util.objectKeys(this.shape).forEach((L) => {
        c[L] || (R[L] = this.shape[L]);
      }), new Ze({
        ...this._def,
        shape: () => R
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return Ut(this);
    }
    partial(c) {
      const R = {};
      return d.util.objectKeys(this.shape).forEach((L) => {
        const K = this.shape[L];
        c && !c[L] ? R[L] = K : R[L] = K.optional();
      }), new Ze({
        ...this._def,
        shape: () => R
      });
    }
    required(c) {
      const R = {};
      return d.util.objectKeys(this.shape).forEach((L) => {
        if (c && !c[L])
          R[L] = this.shape[L];
        else {
          let V = this.shape[L];
          for (; V instanceof q; )
            V = V._def.innerType;
          R[L] = V;
        }
      }), new Ze({
        ...this._def,
        shape: () => R
      });
    }
    keyof() {
      return g(d.util.objectKeys(this.shape));
    }
  }
  t.ZodObject = Ze, Ze.create = (O, c) => new Ze({
    shape: () => O,
    unknownKeys: "strip",
    catchall: xt.create(),
    typeName: Q.ZodObject,
    ...B(c)
  }), Ze.strictCreate = (O, c) => new Ze({
    shape: () => O,
    unknownKeys: "strict",
    catchall: xt.create(),
    typeName: Q.ZodObject,
    ...B(c)
  }), Ze.lazycreate = (O, c) => new Ze({
    shape: O,
    unknownKeys: "strip",
    catchall: xt.create(),
    typeName: Q.ZodObject,
    ...B(c)
  });
  class Gt extends N {
    _parse(c) {
      const { ctx: R } = this._processInputParams(c), L = this._def.options;
      function K(V) {
        for (const se of V)
          if (se.result.status === "valid")
            return se.result;
        for (const se of V)
          if (se.result.status === "dirty")
            return R.common.issues.push(...se.ctx.common.issues), se.result;
        const ce = V.map((se) => new m.ZodError(se.ctx.common.issues));
        return (0, h.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_union,
          unionErrors: ce
        }), h.INVALID;
      }
      if (R.common.async)
        return Promise.all(L.map(async (V) => {
          const ce = {
            ...R,
            common: {
              ...R.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await V._parseAsync({
              data: R.data,
              path: R.path,
              parent: ce
            }),
            ctx: ce
          };
        })).then(K);
      {
        let V;
        const ce = [];
        for (const _e of L) {
          const we = {
            ...R,
            common: {
              ...R.common,
              issues: []
            },
            parent: null
          }, Oe = _e._parseSync({
            data: R.data,
            path: R.path,
            parent: we
          });
          if (Oe.status === "valid")
            return Oe;
          Oe.status === "dirty" && !V && (V = { result: Oe, ctx: we }), we.common.issues.length && ce.push(we.common.issues);
        }
        if (V)
          return R.common.issues.push(...V.ctx.common.issues), V.result;
        const se = ce.map((_e) => new m.ZodError(_e));
        return (0, h.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_union,
          unionErrors: se
        }), h.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  t.ZodUnion = Gt, Gt.create = (O, c) => new Gt({
    options: O,
    typeName: Q.ZodUnion,
    ...B(c)
  });
  const Ye = (O) => O instanceof A ? Ye(O.schema) : O instanceof U ? Ye(O.innerType()) : O instanceof j ? [O.value] : O instanceof T ? O.options : O instanceof D ? d.util.objectValues(O.enum) : O instanceof W ? Ye(O._def.innerType) : O instanceof tr ? [void 0] : O instanceof it ? [null] : O instanceof q ? [void 0, ...Ye(O.unwrap())] : O instanceof G ? [null, ...Ye(O.unwrap())] : O instanceof ue || O instanceof me ? Ye(O.unwrap()) : O instanceof ie ? Ye(O._def.innerType) : [];
  class Et extends N {
    _parse(c) {
      const { ctx: R } = this._processInputParams(c);
      if (R.parsedType !== d.ZodParsedType.object)
        return (0, h.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.object,
          received: R.parsedType
        }), h.INVALID;
      const L = this.discriminator, K = R.data[L], V = this.optionsMap.get(K);
      return V ? R.common.async ? V._parseAsync({
        data: R.data,
        path: R.path,
        parent: R
      }) : V._parseSync({
        data: R.data,
        path: R.path,
        parent: R
      }) : ((0, h.addIssueToContext)(R, {
        code: m.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [L]
      }), h.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(c, R, L) {
      const K = /* @__PURE__ */ new Map();
      for (const V of R) {
        const ce = Ye(V.shape[c]);
        if (!ce.length)
          throw new Error(`A discriminator value for key \`${c}\` could not be extracted from all schema options`);
        for (const se of ce) {
          if (K.has(se))
            throw new Error(`Discriminator property ${String(c)} has duplicate value ${String(se)}`);
          K.set(se, V);
        }
      }
      return new Et({
        typeName: Q.ZodDiscriminatedUnion,
        discriminator: c,
        options: R,
        optionsMap: K,
        ...B(L)
      });
    }
  }
  t.ZodDiscriminatedUnion = Et;
  function Xr(O, c) {
    const R = (0, d.getParsedType)(O), L = (0, d.getParsedType)(c);
    if (O === c)
      return { valid: !0, data: O };
    if (R === d.ZodParsedType.object && L === d.ZodParsedType.object) {
      const K = d.util.objectKeys(c), V = d.util.objectKeys(O).filter((se) => K.indexOf(se) !== -1), ce = { ...O, ...c };
      for (const se of V) {
        const _e = Xr(O[se], c[se]);
        if (!_e.valid)
          return { valid: !1 };
        ce[se] = _e.data;
      }
      return { valid: !0, data: ce };
    } else if (R === d.ZodParsedType.array && L === d.ZodParsedType.array) {
      if (O.length !== c.length)
        return { valid: !1 };
      const K = [];
      for (let V = 0; V < O.length; V++) {
        const ce = O[V], se = c[V], _e = Xr(ce, se);
        if (!_e.valid)
          return { valid: !1 };
        K.push(_e.data);
      }
      return { valid: !0, data: K };
    } else return R === d.ZodParsedType.date && L === d.ZodParsedType.date && +O == +c ? { valid: !0, data: O } : { valid: !1 };
  }
  class Ot extends N {
    _parse(c) {
      const { status: R, ctx: L } = this._processInputParams(c), K = (V, ce) => {
        if ((0, h.isAborted)(V) || (0, h.isAborted)(ce))
          return h.INVALID;
        const se = Xr(V.value, ce.value);
        return se.valid ? (((0, h.isDirty)(V) || (0, h.isDirty)(ce)) && R.dirty(), { status: R.value, value: se.data }) : ((0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_intersection_types
        }), h.INVALID);
      };
      return L.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: L.data,
          path: L.path,
          parent: L
        }),
        this._def.right._parseAsync({
          data: L.data,
          path: L.path,
          parent: L
        })
      ]).then(([V, ce]) => K(V, ce)) : K(this._def.left._parseSync({
        data: L.data,
        path: L.path,
        parent: L
      }), this._def.right._parseSync({
        data: L.data,
        path: L.path,
        parent: L
      }));
    }
  }
  t.ZodIntersection = Ot, Ot.create = (O, c, R) => new Ot({
    left: O,
    right: c,
    typeName: Q.ZodIntersection,
    ...B(R)
  });
  class _r extends N {
    _parse(c) {
      const { status: R, ctx: L } = this._processInputParams(c);
      if (L.parsedType !== d.ZodParsedType.array)
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.array,
          received: L.parsedType
        }), h.INVALID;
      if (L.data.length < this._def.items.length)
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), h.INVALID;
      !this._def.rest && L.data.length > this._def.items.length && ((0, h.addIssueToContext)(L, {
        code: m.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), R.dirty());
      const V = [...L.data].map((ce, se) => {
        const _e = this._def.items[se] || this._def.rest;
        return _e ? _e._parse(new p(L, ce, L.path, se)) : null;
      }).filter((ce) => !!ce);
      return L.common.async ? Promise.all(V).then((ce) => h.ParseStatus.mergeArray(R, ce)) : h.ParseStatus.mergeArray(R, V);
    }
    get items() {
      return this._def.items;
    }
    rest(c) {
      return new _r({
        ...this._def,
        rest: c
      });
    }
  }
  t.ZodTuple = _r, _r.create = (O, c) => {
    if (!Array.isArray(O))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new _r({
      items: O,
      typeName: Q.ZodTuple,
      rest: null,
      ...B(c)
    });
  };
  class Ii extends N {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(c) {
      const { status: R, ctx: L } = this._processInputParams(c);
      if (L.parsedType !== d.ZodParsedType.object)
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.object,
          received: L.parsedType
        }), h.INVALID;
      const K = [], V = this._def.keyType, ce = this._def.valueType;
      for (const se in L.data)
        K.push({
          key: V._parse(new p(L, se, L.path, se)),
          value: ce._parse(new p(L, L.data[se], L.path, se)),
          alwaysSet: se in L.data
        });
      return L.common.async ? h.ParseStatus.mergeObjectAsync(R, K) : h.ParseStatus.mergeObjectSync(R, K);
    }
    get element() {
      return this._def.valueType;
    }
    static create(c, R, L) {
      return R instanceof N ? new Ii({
        keyType: c,
        valueType: R,
        typeName: Q.ZodRecord,
        ...B(L)
      }) : new Ii({
        keyType: ze.create(),
        valueType: c,
        typeName: Q.ZodRecord,
        ...B(R)
      });
    }
  }
  t.ZodRecord = Ii;
  class li extends N {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(c) {
      const { status: R, ctx: L } = this._processInputParams(c);
      if (L.parsedType !== d.ZodParsedType.map)
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.map,
          received: L.parsedType
        }), h.INVALID;
      const K = this._def.keyType, V = this._def.valueType, ce = [...L.data.entries()].map(([se, _e], we) => ({
        key: K._parse(new p(L, se, L.path, [we, "key"])),
        value: V._parse(new p(L, _e, L.path, [we, "value"]))
      }));
      if (L.common.async) {
        const se = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const _e of ce) {
            const we = await _e.key, Oe = await _e.value;
            if (we.status === "aborted" || Oe.status === "aborted")
              return h.INVALID;
            (we.status === "dirty" || Oe.status === "dirty") && R.dirty(), se.set(we.value, Oe.value);
          }
          return { status: R.value, value: se };
        });
      } else {
        const se = /* @__PURE__ */ new Map();
        for (const _e of ce) {
          const we = _e.key, Oe = _e.value;
          if (we.status === "aborted" || Oe.status === "aborted")
            return h.INVALID;
          (we.status === "dirty" || Oe.status === "dirty") && R.dirty(), se.set(we.value, Oe.value);
        }
        return { status: R.value, value: se };
      }
    }
  }
  t.ZodMap = li, li.create = (O, c, R) => new li({
    valueType: c,
    keyType: O,
    typeName: Q.ZodMap,
    ...B(R)
  });
  class zr extends N {
    _parse(c) {
      const { status: R, ctx: L } = this._processInputParams(c);
      if (L.parsedType !== d.ZodParsedType.set)
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.set,
          received: L.parsedType
        }), h.INVALID;
      const K = this._def;
      K.minSize !== null && L.data.size < K.minSize.value && ((0, h.addIssueToContext)(L, {
        code: m.ZodIssueCode.too_small,
        minimum: K.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: K.minSize.message
      }), R.dirty()), K.maxSize !== null && L.data.size > K.maxSize.value && ((0, h.addIssueToContext)(L, {
        code: m.ZodIssueCode.too_big,
        maximum: K.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: K.maxSize.message
      }), R.dirty());
      const V = this._def.valueType;
      function ce(_e) {
        const we = /* @__PURE__ */ new Set();
        for (const Oe of _e) {
          if (Oe.status === "aborted")
            return h.INVALID;
          Oe.status === "dirty" && R.dirty(), we.add(Oe.value);
        }
        return { status: R.value, value: we };
      }
      const se = [...L.data.values()].map((_e, we) => V._parse(new p(L, _e, L.path, we)));
      return L.common.async ? Promise.all(se).then((_e) => ce(_e)) : ce(se);
    }
    min(c, R) {
      return new zr({
        ...this._def,
        minSize: { value: c, message: b.errorUtil.toString(R) }
      });
    }
    max(c, R) {
      return new zr({
        ...this._def,
        maxSize: { value: c, message: b.errorUtil.toString(R) }
      });
    }
    size(c, R) {
      return this.min(c, R).max(c, R);
    }
    nonempty(c) {
      return this.min(1, c);
    }
  }
  t.ZodSet = zr, zr.create = (O, c) => new zr({
    valueType: O,
    minSize: null,
    maxSize: null,
    typeName: Q.ZodSet,
    ...B(c)
  });
  class Nr extends N {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(c) {
      const { ctx: R } = this._processInputParams(c);
      if (R.parsedType !== d.ZodParsedType.function)
        return (0, h.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.function,
          received: R.parsedType
        }), h.INVALID;
      function L(se, _e) {
        return (0, h.makeIssue)({
          data: se,
          path: R.path,
          errorMaps: [
            R.common.contextualErrorMap,
            R.schemaErrorMap,
            (0, y.getErrorMap)(),
            y.defaultErrorMap
          ].filter((we) => !!we),
          issueData: {
            code: m.ZodIssueCode.invalid_arguments,
            argumentsError: _e
          }
        });
      }
      function K(se, _e) {
        return (0, h.makeIssue)({
          data: se,
          path: R.path,
          errorMaps: [
            R.common.contextualErrorMap,
            R.schemaErrorMap,
            (0, y.getErrorMap)(),
            y.defaultErrorMap
          ].filter((we) => !!we),
          issueData: {
            code: m.ZodIssueCode.invalid_return_type,
            returnTypeError: _e
          }
        });
      }
      const V = { errorMap: R.common.contextualErrorMap }, ce = R.data;
      if (this._def.returns instanceof P) {
        const se = this;
        return (0, h.OK)(async function(..._e) {
          const we = new m.ZodError([]), Oe = await se._def.args.parseAsync(_e, V).catch((Va) => {
            throw we.addIssue(L(_e, Va)), we;
          }), wr = await Reflect.apply(ce, this, Oe);
          return await se._def.returns._def.type.parseAsync(wr, V).catch((Va) => {
            throw we.addIssue(K(wr, Va)), we;
          });
        });
      } else {
        const se = this;
        return (0, h.OK)(function(..._e) {
          const we = se._def.args.safeParse(_e, V);
          if (!we.success)
            throw new m.ZodError([L(_e, we.error)]);
          const Oe = Reflect.apply(ce, this, we.data), wr = se._def.returns.safeParse(Oe, V);
          if (!wr.success)
            throw new m.ZodError([K(Oe, wr.error)]);
          return wr.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...c) {
      return new Nr({
        ...this._def,
        args: _r.create(c).rest(St.create())
      });
    }
    returns(c) {
      return new Nr({
        ...this._def,
        returns: c
      });
    }
    implement(c) {
      return this.parse(c);
    }
    strictImplement(c) {
      return this.parse(c);
    }
    static create(c, R, L) {
      return new Nr({
        args: c || _r.create([]).rest(St.create()),
        returns: R || St.create(),
        typeName: Q.ZodFunction,
        ...B(L)
      });
    }
  }
  t.ZodFunction = Nr;
  class A extends N {
    get schema() {
      return this._def.getter();
    }
    _parse(c) {
      const { ctx: R } = this._processInputParams(c);
      return this._def.getter()._parse({ data: R.data, path: R.path, parent: R });
    }
  }
  t.ZodLazy = A, A.create = (O, c) => new A({
    getter: O,
    typeName: Q.ZodLazy,
    ...B(c)
  });
  class j extends N {
    _parse(c) {
      if (c.data !== this._def.value) {
        const R = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(R, {
          received: R.data,
          code: m.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), h.INVALID;
      }
      return { status: "valid", value: c.data };
    }
    get value() {
      return this._def.value;
    }
  }
  t.ZodLiteral = j, j.create = (O, c) => new j({
    value: O,
    typeName: Q.ZodLiteral,
    ...B(c)
  });
  function g(O, c) {
    return new T({
      values: O,
      typeName: Q.ZodEnum,
      ...B(c)
    });
  }
  class T extends N {
    constructor() {
      super(...arguments), n.set(this, void 0);
    }
    _parse(c) {
      if (typeof c.data != "string") {
        const R = this._getOrReturnCtx(c), L = this._def.values;
        return (0, h.addIssueToContext)(R, {
          expected: d.util.joinValues(L),
          received: R.parsedType,
          code: m.ZodIssueCode.invalid_type
        }), h.INVALID;
      }
      if (e(this, n, "f") || r(this, n, new Set(this._def.values), "f"), !e(this, n, "f").has(c.data)) {
        const R = this._getOrReturnCtx(c), L = this._def.values;
        return (0, h.addIssueToContext)(R, {
          received: R.data,
          code: m.ZodIssueCode.invalid_enum_value,
          options: L
        }), h.INVALID;
      }
      return (0, h.OK)(c.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const c = {};
      for (const R of this._def.values)
        c[R] = R;
      return c;
    }
    get Values() {
      const c = {};
      for (const R of this._def.values)
        c[R] = R;
      return c;
    }
    get Enum() {
      const c = {};
      for (const R of this._def.values)
        c[R] = R;
      return c;
    }
    extract(c, R = this._def) {
      return T.create(c, {
        ...this._def,
        ...R
      });
    }
    exclude(c, R = this._def) {
      return T.create(this.options.filter((L) => !c.includes(L)), {
        ...this._def,
        ...R
      });
    }
  }
  t.ZodEnum = T, n = /* @__PURE__ */ new WeakMap(), T.create = g;
  class D extends N {
    constructor() {
      super(...arguments), u.set(this, void 0);
    }
    _parse(c) {
      const R = d.util.getValidEnumValues(this._def.values), L = this._getOrReturnCtx(c);
      if (L.parsedType !== d.ZodParsedType.string && L.parsedType !== d.ZodParsedType.number) {
        const K = d.util.objectValues(R);
        return (0, h.addIssueToContext)(L, {
          expected: d.util.joinValues(K),
          received: L.parsedType,
          code: m.ZodIssueCode.invalid_type
        }), h.INVALID;
      }
      if (e(this, u, "f") || r(this, u, new Set(d.util.getValidEnumValues(this._def.values)), "f"), !e(this, u, "f").has(c.data)) {
        const K = d.util.objectValues(R);
        return (0, h.addIssueToContext)(L, {
          received: L.data,
          code: m.ZodIssueCode.invalid_enum_value,
          options: K
        }), h.INVALID;
      }
      return (0, h.OK)(c.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  t.ZodNativeEnum = D, u = /* @__PURE__ */ new WeakMap(), D.create = (O, c) => new D({
    values: O,
    typeName: Q.ZodNativeEnum,
    ...B(c)
  });
  class P extends N {
    unwrap() {
      return this._def.type;
    }
    _parse(c) {
      const { ctx: R } = this._processInputParams(c);
      if (R.parsedType !== d.ZodParsedType.promise && R.common.async === !1)
        return (0, h.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.promise,
          received: R.parsedType
        }), h.INVALID;
      const L = R.parsedType === d.ZodParsedType.promise ? R.data : Promise.resolve(R.data);
      return (0, h.OK)(L.then((K) => this._def.type.parseAsync(K, {
        path: R.path,
        errorMap: R.common.contextualErrorMap
      })));
    }
  }
  t.ZodPromise = P, P.create = (O, c) => new P({
    type: O,
    typeName: Q.ZodPromise,
    ...B(c)
  });
  class U extends N {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === Q.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(c) {
      const { status: R, ctx: L } = this._processInputParams(c), K = this._def.effect || null, V = {
        addIssue: (ce) => {
          (0, h.addIssueToContext)(L, ce), ce.fatal ? R.abort() : R.dirty();
        },
        get path() {
          return L.path;
        }
      };
      if (V.addIssue = V.addIssue.bind(V), K.type === "preprocess") {
        const ce = K.transform(L.data, V);
        if (L.common.async)
          return Promise.resolve(ce).then(async (se) => {
            if (R.value === "aborted")
              return h.INVALID;
            const _e = await this._def.schema._parseAsync({
              data: se,
              path: L.path,
              parent: L
            });
            return _e.status === "aborted" ? h.INVALID : _e.status === "dirty" || R.value === "dirty" ? (0, h.DIRTY)(_e.value) : _e;
          });
        {
          if (R.value === "aborted")
            return h.INVALID;
          const se = this._def.schema._parseSync({
            data: ce,
            path: L.path,
            parent: L
          });
          return se.status === "aborted" ? h.INVALID : se.status === "dirty" || R.value === "dirty" ? (0, h.DIRTY)(se.value) : se;
        }
      }
      if (K.type === "refinement") {
        const ce = (se) => {
          const _e = K.refinement(se, V);
          if (L.common.async)
            return Promise.resolve(_e);
          if (_e instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return se;
        };
        if (L.common.async === !1) {
          const se = this._def.schema._parseSync({
            data: L.data,
            path: L.path,
            parent: L
          });
          return se.status === "aborted" ? h.INVALID : (se.status === "dirty" && R.dirty(), ce(se.value), { status: R.value, value: se.value });
        } else
          return this._def.schema._parseAsync({ data: L.data, path: L.path, parent: L }).then((se) => se.status === "aborted" ? h.INVALID : (se.status === "dirty" && R.dirty(), ce(se.value).then(() => ({ status: R.value, value: se.value }))));
      }
      if (K.type === "transform")
        if (L.common.async === !1) {
          const ce = this._def.schema._parseSync({
            data: L.data,
            path: L.path,
            parent: L
          });
          if (!(0, h.isValid)(ce))
            return ce;
          const se = K.transform(ce.value, V);
          if (se instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: R.value, value: se };
        } else
          return this._def.schema._parseAsync({ data: L.data, path: L.path, parent: L }).then((ce) => (0, h.isValid)(ce) ? Promise.resolve(K.transform(ce.value, V)).then((se) => ({ status: R.value, value: se })) : ce);
      d.util.assertNever(K);
    }
  }
  t.ZodEffects = U, t.ZodTransformer = U, U.create = (O, c, R) => new U({
    schema: O,
    typeName: Q.ZodEffects,
    effect: c,
    ...B(R)
  }), U.createWithPreprocess = (O, c, R) => new U({
    schema: c,
    effect: { type: "preprocess", transform: O },
    typeName: Q.ZodEffects,
    ...B(R)
  });
  class q extends N {
    _parse(c) {
      return this._getType(c) === d.ZodParsedType.undefined ? (0, h.OK)(void 0) : this._def.innerType._parse(c);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  t.ZodOptional = q, q.create = (O, c) => new q({
    innerType: O,
    typeName: Q.ZodOptional,
    ...B(c)
  });
  class G extends N {
    _parse(c) {
      return this._getType(c) === d.ZodParsedType.null ? (0, h.OK)(null) : this._def.innerType._parse(c);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  t.ZodNullable = G, G.create = (O, c) => new G({
    innerType: O,
    typeName: Q.ZodNullable,
    ...B(c)
  });
  class W extends N {
    _parse(c) {
      const { ctx: R } = this._processInputParams(c);
      let L = R.data;
      return R.parsedType === d.ZodParsedType.undefined && (L = this._def.defaultValue()), this._def.innerType._parse({
        data: L,
        path: R.path,
        parent: R
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  t.ZodDefault = W, W.create = (O, c) => new W({
    innerType: O,
    typeName: Q.ZodDefault,
    defaultValue: typeof c.default == "function" ? c.default : () => c.default,
    ...B(c)
  });
  class ie extends N {
    _parse(c) {
      const { ctx: R } = this._processInputParams(c), L = {
        ...R,
        common: {
          ...R.common,
          issues: []
        }
      }, K = this._def.innerType._parse({
        data: L.data,
        path: L.path,
        parent: {
          ...L
        }
      });
      return (0, h.isAsync)(K) ? K.then((V) => ({
        status: "valid",
        value: V.status === "valid" ? V.value : this._def.catchValue({
          get error() {
            return new m.ZodError(L.common.issues);
          },
          input: L.data
        })
      })) : {
        status: "valid",
        value: K.status === "valid" ? K.value : this._def.catchValue({
          get error() {
            return new m.ZodError(L.common.issues);
          },
          input: L.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  t.ZodCatch = ie, ie.create = (O, c) => new ie({
    innerType: O,
    typeName: Q.ZodCatch,
    catchValue: typeof c.catch == "function" ? c.catch : () => c.catch,
    ...B(c)
  });
  class Y extends N {
    _parse(c) {
      if (this._getType(c) !== d.ZodParsedType.nan) {
        const L = this._getOrReturnCtx(c);
        return (0, h.addIssueToContext)(L, {
          code: m.ZodIssueCode.invalid_type,
          expected: d.ZodParsedType.nan,
          received: L.parsedType
        }), h.INVALID;
      }
      return { status: "valid", value: c.data };
    }
  }
  t.ZodNaN = Y, Y.create = (O) => new Y({
    typeName: Q.ZodNaN,
    ...B(O)
  }), t.BRAND = Symbol("zod_brand");
  class ue extends N {
    _parse(c) {
      const { ctx: R } = this._processInputParams(c), L = R.data;
      return this._def.type._parse({
        data: L,
        path: R.path,
        parent: R
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  t.ZodBranded = ue;
  class ae extends N {
    _parse(c) {
      const { status: R, ctx: L } = this._processInputParams(c);
      if (L.common.async)
        return (async () => {
          const V = await this._def.in._parseAsync({
            data: L.data,
            path: L.path,
            parent: L
          });
          return V.status === "aborted" ? h.INVALID : V.status === "dirty" ? (R.dirty(), (0, h.DIRTY)(V.value)) : this._def.out._parseAsync({
            data: V.value,
            path: L.path,
            parent: L
          });
        })();
      {
        const K = this._def.in._parseSync({
          data: L.data,
          path: L.path,
          parent: L
        });
        return K.status === "aborted" ? h.INVALID : K.status === "dirty" ? (R.dirty(), {
          status: "dirty",
          value: K.value
        }) : this._def.out._parseSync({
          data: K.value,
          path: L.path,
          parent: L
        });
      }
    }
    static create(c, R) {
      return new ae({
        in: c,
        out: R,
        typeName: Q.ZodPipeline
      });
    }
  }
  t.ZodPipeline = ae;
  class me extends N {
    _parse(c) {
      const R = this._def.innerType._parse(c), L = (K) => ((0, h.isValid)(K) && (K.value = Object.freeze(K.value)), K);
      return (0, h.isAsync)(R) ? R.then((K) => L(K)) : L(R);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  t.ZodReadonly = me, me.create = (O, c) => new me({
    innerType: O,
    typeName: Q.ZodReadonly,
    ...B(c)
  });
  function fe(O, c = {}, R) {
    return O ? yr.create().superRefine((L, K) => {
      var V, ce;
      if (!O(L)) {
        const se = typeof c == "function" ? c(L) : typeof c == "string" ? { message: c } : c, _e = (ce = (V = se.fatal) !== null && V !== void 0 ? V : R) !== null && ce !== void 0 ? ce : !0, we = typeof se == "string" ? { message: se } : se;
        K.addIssue({ code: "custom", ...we, fatal: _e });
      }
    }) : yr.create();
  }
  t.custom = fe, t.late = {
    object: Ze.lazycreate
  };
  var Q;
  (function(O) {
    O.ZodString = "ZodString", O.ZodNumber = "ZodNumber", O.ZodNaN = "ZodNaN", O.ZodBigInt = "ZodBigInt", O.ZodBoolean = "ZodBoolean", O.ZodDate = "ZodDate", O.ZodSymbol = "ZodSymbol", O.ZodUndefined = "ZodUndefined", O.ZodNull = "ZodNull", O.ZodAny = "ZodAny", O.ZodUnknown = "ZodUnknown", O.ZodNever = "ZodNever", O.ZodVoid = "ZodVoid", O.ZodArray = "ZodArray", O.ZodObject = "ZodObject", O.ZodUnion = "ZodUnion", O.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", O.ZodIntersection = "ZodIntersection", O.ZodTuple = "ZodTuple", O.ZodRecord = "ZodRecord", O.ZodMap = "ZodMap", O.ZodSet = "ZodSet", O.ZodFunction = "ZodFunction", O.ZodLazy = "ZodLazy", O.ZodLiteral = "ZodLiteral", O.ZodEnum = "ZodEnum", O.ZodEffects = "ZodEffects", O.ZodNativeEnum = "ZodNativeEnum", O.ZodOptional = "ZodOptional", O.ZodNullable = "ZodNullable", O.ZodDefault = "ZodDefault", O.ZodCatch = "ZodCatch", O.ZodPromise = "ZodPromise", O.ZodBranded = "ZodBranded", O.ZodPipeline = "ZodPipeline", O.ZodReadonly = "ZodReadonly";
  })(Q = t.ZodFirstPartyTypeKind || (t.ZodFirstPartyTypeKind = {}));
  const oe = (O, c = {
    message: `Input not instance of ${O.name}`
  }) => fe((R) => R instanceof O, c);
  t.instanceof = oe;
  const Ke = ze.create;
  t.string = Ke;
  const nt = pt.create;
  t.number = nt;
  const ot = Y.create;
  t.nan = ot;
  const qe = st.create;
  t.bigint = qe;
  const Je = rt.create;
  t.boolean = Je;
  const Le = ht.create;
  t.date = Le;
  const ct = Fe.create;
  t.symbol = ct;
  const Lt = tr.create;
  t.undefined = Lt;
  const ut = it.create;
  t.null = ut;
  const At = yr.create;
  t.any = At;
  const Kt = St.create;
  t.unknown = Kt;
  const rr = xt.create;
  t.never = rr;
  const Mt = Ct.create;
  t.void = Mt;
  const br = mt.create;
  t.array = br;
  const qt = Ze.create;
  t.object = qt;
  const ir = Ze.strictCreate;
  t.strictObject = ir;
  const Hr = Gt.create;
  t.union = Hr;
  const Zr = Et.create;
  t.discriminatedUnion = Zr;
  const Ui = Ot.create;
  t.intersection = Ui;
  const Xt = _r.create;
  t.tuple = Xt;
  const kt = Ii.create;
  t.record = kt;
  const Cr = li.create;
  t.map = Cr;
  const Wr = zr.create;
  t.set = Wr;
  const Vr = Nr.create;
  t.function = Vr;
  const Oi = A.create;
  t.lazy = Oi;
  const dn = j.create;
  t.literal = dn;
  const Ki = T.create;
  t.enum = Ki;
  const Mi = D.create;
  t.nativeEnum = Mi;
  const jr = P.create;
  t.promise = jr;
  const Yr = U.create;
  t.effect = Yr, t.transformer = Yr;
  const Jr = q.create;
  t.optional = Jr;
  const fn = G.create;
  t.nullable = fn;
  const Fr = U.createWithPreprocess;
  t.preprocess = Fr;
  const Ma = ae.create;
  t.pipeline = Ma;
  const kn = () => Ke().optional();
  t.ostring = kn;
  const Na = () => nt().optional();
  t.onumber = Na;
  const na = () => Je().optional();
  t.oboolean = na, t.coerce = {
    string: (O) => ze.create({ ...O, coerce: !0 }),
    number: (O) => pt.create({ ...O, coerce: !0 }),
    boolean: (O) => rt.create({
      ...O,
      coerce: !0
    }),
    bigint: (O) => st.create({ ...O, coerce: !0 }),
    date: (O) => ht.create({ ...O, coerce: !0 })
  }, t.NEVER = h.INVALID;
})(df);
(function(t) {
  var e = de && de.__createBinding || (Object.create ? function(n, u, y, b) {
    b === void 0 && (b = y), Object.defineProperty(n, b, { enumerable: !0, get: function() {
      return u[y];
    } });
  } : function(n, u, y, b) {
    b === void 0 && (b = y), n[b] = u[y];
  }), r = de && de.__exportStar || function(n, u) {
    for (var y in n) y !== "default" && !Object.prototype.hasOwnProperty.call(u, y) && e(u, n, y);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Ai, t), r(Zu, t), r(cf, t), r(ts, t), r(df, t), r(_i, t);
})(Nu);
(function(t) {
  var e = de && de.__createBinding || (Object.create ? function(b, h, d, m) {
    m === void 0 && (m = d), Object.defineProperty(b, m, { enumerable: !0, get: function() {
      return h[d];
    } });
  } : function(b, h, d, m) {
    m === void 0 && (m = d), b[m] = h[d];
  }), r = de && de.__setModuleDefault || (Object.create ? function(b, h) {
    Object.defineProperty(b, "default", { enumerable: !0, value: h });
  } : function(b, h) {
    b.default = h;
  }), n = de && de.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var h = {};
    if (b != null) for (var d in b) d !== "default" && Object.prototype.hasOwnProperty.call(b, d) && e(h, b, d);
    return r(h, b), h;
  }, u = de && de.__exportStar || function(b, h) {
    for (var d in b) d !== "default" && !Object.prototype.hasOwnProperty.call(h, d) && e(h, b, d);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.z = void 0;
  const y = n(Nu);
  t.z = y, u(Nu, t), t.default = y;
})(ia);
var wi = {};
Object.defineProperty(wi, "__esModule", { value: !0 });
wi.requiredPropertiesRefinement = wi.toConcreteTypes = wi.toLexUri = void 0;
const Au = ia;
function Cy(t, e) {
  if (t.split("#").length > 2)
    throw new Error("Uri can only have one hash segment");
  if (t.startsWith("lex:"))
    return t;
  if (t.startsWith("#")) {
    if (!e)
      throw new Error(`Unable to resolve uri without anchor: ${t}`);
    return `${e}${t}`;
  }
  return `lex:${t}`;
}
wi.toLexUri = Cy;
function Ly(t, e) {
  return e.type === "ref" ? [t.getDefOrThrow(e.ref)] : e.type === "union" ? e.refs.map((r) => t.getDefOrThrow(r)).flat() : [e];
}
wi.toConcreteTypes = Ly;
function ky(t, e) {
  if (t.required !== void 0) {
    if (!Array.isArray(t.required)) {
      e.addIssue({
        code: Au.z.ZodIssueCode.invalid_type,
        received: typeof t.required,
        expected: "array"
      });
      return;
    }
    if (t.properties === void 0) {
      t.required.length > 0 && e.addIssue({
        code: Au.z.ZodIssueCode.custom,
        message: "Required fields defined but no properties defined"
      });
      return;
    }
    for (const r of t.required)
      t.properties[r] === void 0 && e.addIssue({
        code: Au.z.ZodIssueCode.custom,
        message: `Required field "${r}" not defined`
      });
  }
}
wi.requiredPropertiesRefinement = ky;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.LexiconDefNotFoundError = t.InvalidLexiconError = t.ValidationError = t.parseLexiconDoc = t.isDiscriminatedObject = t.discriminatedObject = t.hasProp = t.isObj = t.isValidLexiconDoc = t.lexiconDoc = t.lexUserType = t.lexRecord = t.lexXrpcSubscription = t.lexXrpcProcedure = t.lexXrpcQuery = t.lexXrpcError = t.lexXrpcSubscriptionMessage = t.lexXrpcBody = t.lexXrpcParameters = t.lexObject = t.lexToken = t.lexPrimitiveArray = t.lexArray = t.lexBlob = t.lexRefVariant = t.lexRefUnion = t.lexRef = t.lexIpldType = t.lexCidLink = t.lexBytes = t.lexPrimitive = t.lexUnknown = t.lexString = t.lexStringFormat = t.lexInteger = t.lexBoolean = void 0;
  const e = ia, r = ra, n = wi;
  t.lexBoolean = e.z.object({
    type: e.z.literal("boolean"),
    description: e.z.string().optional(),
    default: e.z.boolean().optional(),
    const: e.z.boolean().optional()
  }).strict(), t.lexInteger = e.z.object({
    type: e.z.literal("integer"),
    description: e.z.string().optional(),
    default: e.z.number().int().optional(),
    minimum: e.z.number().int().optional(),
    maximum: e.z.number().int().optional(),
    enum: e.z.number().int().array().optional(),
    const: e.z.number().int().optional()
  }).strict(), t.lexStringFormat = e.z.enum([
    "datetime",
    "uri",
    "at-uri",
    "did",
    "handle",
    "at-identifier",
    "nsid",
    "cid",
    "language",
    "tid",
    "record-key"
  ]), t.lexString = e.z.object({
    type: e.z.literal("string"),
    format: t.lexStringFormat.optional(),
    description: e.z.string().optional(),
    default: e.z.string().optional(),
    minLength: e.z.number().int().optional(),
    maxLength: e.z.number().int().optional(),
    minGraphemes: e.z.number().int().optional(),
    maxGraphemes: e.z.number().int().optional(),
    enum: e.z.string().array().optional(),
    const: e.z.string().optional(),
    knownValues: e.z.string().array().optional()
  }).strict(), t.lexUnknown = e.z.object({
    type: e.z.literal("unknown"),
    description: e.z.string().optional()
  }).strict(), t.lexPrimitive = e.z.discriminatedUnion("type", [
    t.lexBoolean,
    t.lexInteger,
    t.lexString,
    t.lexUnknown
  ]), t.lexBytes = e.z.object({
    type: e.z.literal("bytes"),
    description: e.z.string().optional(),
    maxLength: e.z.number().optional(),
    minLength: e.z.number().optional()
  }).strict(), t.lexCidLink = e.z.object({
    type: e.z.literal("cid-link"),
    description: e.z.string().optional()
  }).strict(), t.lexIpldType = e.z.discriminatedUnion("type", [t.lexBytes, t.lexCidLink]), t.lexRef = e.z.object({
    type: e.z.literal("ref"),
    description: e.z.string().optional(),
    ref: e.z.string()
  }).strict(), t.lexRefUnion = e.z.object({
    type: e.z.literal("union"),
    description: e.z.string().optional(),
    refs: e.z.string().array(),
    closed: e.z.boolean().optional()
  }).strict(), t.lexRefVariant = e.z.discriminatedUnion("type", [t.lexRef, t.lexRefUnion]), t.lexBlob = e.z.object({
    type: e.z.literal("blob"),
    description: e.z.string().optional(),
    accept: e.z.string().array().optional(),
    maxSize: e.z.number().optional()
  }).strict(), t.lexArray = e.z.object({
    type: e.z.literal("array"),
    description: e.z.string().optional(),
    items: e.z.union([t.lexPrimitive, t.lexIpldType, t.lexBlob, t.lexRefVariant]),
    minLength: e.z.number().int().optional(),
    maxLength: e.z.number().int().optional()
  }).strict(), t.lexPrimitiveArray = t.lexArray.merge(e.z.object({
    items: t.lexPrimitive
  }).strict()), t.lexToken = e.z.object({
    type: e.z.literal("token"),
    description: e.z.string().optional()
  }).strict(), t.lexObject = e.z.object({
    type: e.z.literal("object"),
    description: e.z.string().optional(),
    required: e.z.string().array().optional(),
    nullable: e.z.string().array().optional(),
    properties: e.z.record(e.z.union([t.lexRefVariant, t.lexIpldType, t.lexArray, t.lexBlob, t.lexPrimitive]))
  }).strict().superRefine(n.requiredPropertiesRefinement), t.lexXrpcParameters = e.z.object({
    type: e.z.literal("params"),
    description: e.z.string().optional(),
    required: e.z.string().array().optional(),
    properties: e.z.record(e.z.union([t.lexPrimitive, t.lexPrimitiveArray]))
  }).strict().superRefine(n.requiredPropertiesRefinement), t.lexXrpcBody = e.z.object({
    description: e.z.string().optional(),
    encoding: e.z.string(),
    schema: e.z.union([t.lexRefVariant, t.lexObject]).optional()
  }).strict(), t.lexXrpcSubscriptionMessage = e.z.object({
    description: e.z.string().optional(),
    schema: e.z.union([t.lexRefVariant, t.lexObject]).optional()
  }).strict(), t.lexXrpcError = e.z.object({
    name: e.z.string(),
    description: e.z.string().optional()
  }).strict(), t.lexXrpcQuery = e.z.object({
    type: e.z.literal("query"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    output: t.lexXrpcBody.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexXrpcProcedure = e.z.object({
    type: e.z.literal("procedure"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    input: t.lexXrpcBody.optional(),
    output: t.lexXrpcBody.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexXrpcSubscription = e.z.object({
    type: e.z.literal("subscription"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    message: t.lexXrpcSubscriptionMessage.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexRecord = e.z.object({
    type: e.z.literal("record"),
    description: e.z.string().optional(),
    key: e.z.string().optional(),
    record: t.lexObject
  }).strict(), t.lexUserType = e.z.custom((B) => {
    if (!(!B || typeof B != "object") && B.type !== void 0)
      switch (B.type) {
        case "record":
          return t.lexRecord.parse(B);
        case "query":
          return t.lexXrpcQuery.parse(B);
        case "procedure":
          return t.lexXrpcProcedure.parse(B);
        case "subscription":
          return t.lexXrpcSubscription.parse(B);
        case "blob":
          return t.lexBlob.parse(B);
        case "array":
          return t.lexArray.parse(B);
        case "token":
          return t.lexToken.parse(B);
        case "object":
          return t.lexObject.parse(B);
        case "boolean":
          return t.lexBoolean.parse(B);
        case "integer":
          return t.lexInteger.parse(B);
        case "string":
          return t.lexString.parse(B);
        case "bytes":
          return t.lexBytes.parse(B);
        case "cid-link":
          return t.lexCidLink.parse(B);
        case "unknown":
          return t.lexUnknown.parse(B);
      }
  }, (B) => !B || typeof B != "object" ? {
    message: "Must be an object",
    fatal: !0
  } : B.type === void 0 ? {
    message: "Must have a type",
    fatal: !0
  } : {
    message: `Invalid type: ${B.type} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
    fatal: !0
  }), t.lexiconDoc = e.z.object({
    lexicon: e.z.literal(1),
    id: e.z.string().refine((B) => r.NSID.isValid(B), {
      message: "Must be a valid NSID"
    }),
    revision: e.z.number().optional(),
    description: e.z.string().optional(),
    defs: e.z.record(t.lexUserType)
  }).strict().superRefine((B, N) => {
    for (const X in B.defs) {
      const te = B.defs[X];
      X !== "main" && (te.type === "record" || te.type === "procedure" || te.type === "query" || te.type === "subscription") && N.addIssue({
        code: e.z.ZodIssueCode.custom,
        message: "Records, procedures, queries, and subscriptions must be the main definition."
      });
    }
  });
  function u(B) {
    return t.lexiconDoc.safeParse(B).success;
  }
  t.isValidLexiconDoc = u;
  function y(B) {
    return B !== null && typeof B == "object";
  }
  t.isObj = y;
  function b(B, N) {
    return N in B;
  }
  t.hasProp = b, t.discriminatedObject = e.z.object({ $type: e.z.string() });
  function h(B) {
    return t.discriminatedObject.safeParse(B).success;
  }
  t.isDiscriminatedObject = h;
  function d(B) {
    return t.lexiconDoc.parse(B), B;
  }
  t.parseLexiconDoc = d;
  class m extends Error {
  }
  t.ValidationError = m;
  class p extends Error {
  }
  t.InvalidLexiconError = p;
  class _ extends Error {
  }
  t.LexiconDefNotFoundError = _;
})(Tn);
var Wl = {}, $r = {}, qr = {}, Yl = {}, Jl = {}, Pi = {}, mi = {};
Object.defineProperty(mi, "__esModule", { value: !0 });
mi.isObject = mi.assure = mi.create = mi.is = void 0;
const Dy = (t, e) => e.safeParse(t).success;
mi.is = Dy;
const Py = (t) => (e) => t.safeParse(e).success;
mi.create = Py;
const By = (t, e) => t.parse(e);
mi.assure = By;
const Iy = (t) => typeof t == "object" && t !== null;
mi.isObject = Iy;
var fa = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.parseIntWithFallback = t.dedupeStrs = t.range = t.chunkArray = t.errHasMsg = t.isErrnoException = t.asyncFilter = t.s32decode = t.s32encode = t.streamToBuffer = t.flattenUint8Arrays = t.bailableWait = t.wait = t.jitter = t.omit = t.noUndefinedVals = void 0;
  const e = (F) => (Object.keys(F).forEach((z) => {
    F[z] === void 0 && delete F[z];
  }), F);
  t.noUndefinedVals = e;
  function r(F, z) {
    return F && Object.fromEntries(Object.entries(F).filter((ee) => !z.includes(ee[0])));
  }
  t.omit = r;
  const n = (F) => Math.round((Math.random() - 0.5) * F * 2);
  t.jitter = n;
  const u = (F) => new Promise((z) => setTimeout(z, F));
  t.wait = u;
  const y = (F) => {
    let z;
    const ee = new Promise((ye) => {
      const xe = setTimeout(ye, F);
      z = () => {
        clearTimeout(xe), ye();
      };
    });
    return { bail: z, wait: () => ee };
  };
  t.bailableWait = y;
  const b = (F) => {
    const z = F.reduce((xe, Ee) => xe + Ee.length, 0), ee = new Uint8Array(z);
    let ye = 0;
    return F.forEach((xe) => {
      ee.set(xe, ye), ye += xe.length;
    }), ee;
  };
  t.flattenUint8Arrays = b;
  const h = async (F) => {
    const z = [];
    for await (const ee of F)
      z.push(ee);
    return (0, t.flattenUint8Arrays)(z);
  };
  t.streamToBuffer = h;
  const d = "234567abcdefghijklmnopqrstuvwxyz", m = (F) => {
    let z = "";
    for (; F; ) {
      const ee = F % 32;
      F = Math.floor(F / 32), z = d.charAt(ee) + z;
    }
    return z;
  };
  t.s32encode = m;
  const p = (F) => {
    let z = 0;
    for (const ee of F)
      z = z * 32 + d.indexOf(ee);
    return z;
  };
  t.s32decode = p;
  const _ = async (F, z) => {
    const ee = await Promise.all(F.map((ye) => z(ye)));
    return F.filter((ye, xe) => ee[xe]);
  };
  t.asyncFilter = _;
  const B = (F) => !!F && F.code;
  t.isErrnoException = B;
  const N = (F, z) => !!F && typeof F == "object" && F.message === z;
  t.errHasMsg = N;
  const X = (F, z) => F.reduce((ee, ye, xe) => {
    const Ee = Math.floor(xe / z);
    return ee[Ee] || (ee[Ee] = []), ee[Ee].push(ye), ee;
  }, []);
  t.chunkArray = X;
  const te = (F) => {
    const z = [];
    for (let ee = 0; ee < F; ee++)
      z.push(ee);
    return z;
  };
  t.range = te;
  const re = (F) => [...new Set(F)];
  t.dedupeStrs = re;
  const J = (F, z) => {
    const ee = parseInt(F || "", 10);
    return isNaN(ee) ? z : ee;
  };
  t.parseIntWithFallback = J;
})(fa);
var pa = {};
Object.defineProperty(pa, "__esModule", { value: !0 });
pa.mapDefined = pa.keyBy = void 0;
const Uy = (t, e) => t.reduce((r, n) => (r[n[e]] = n, r), {});
pa.keyBy = Uy;
const Oy = (t, e) => {
  const r = [];
  for (const n of t) {
    const u = e(n);
    u !== void 0 && r.push(u);
  }
  return r;
};
pa.mapDefined = Oy;
var pf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.handleAllSettledErrors = t.AsyncBufferFullError = t.AsyncBuffer = t.allComplete = t.createDeferrables = t.createDeferrable = t.readFromGenerator = void 0;
  const e = fa, r = async (p, _, B = Promise.resolve(), N = Number.MAX_SAFE_INTEGER) => {
    const X = [];
    let te, re = !1;
    const J = async () => {
      if (await _(X.at(-1)))
        return !0;
      const z = (0, e.bailableWait)(20);
      return await z.wait(), te = z.bail, re ? !1 : await J();
    }, F = new Promise((z) => {
      B.then(() => {
        J().then(() => z());
      });
    });
    try {
      for (; X.length < N; ) {
        const z = await Promise.race([p.next(), F]);
        if (!z)
          break;
        const ee = z;
        if (ee.done)
          break;
        X.push(ee.value);
      }
    } finally {
      re = !0, te && te();
    }
    return X;
  };
  t.readFromGenerator = r;
  const n = () => {
    let p;
    const _ = new Promise((B) => {
      p = () => B();
    });
    return { resolve: p, complete: _ };
  };
  t.createDeferrable = n;
  const u = (p) => {
    const _ = [];
    for (let B = 0; B < p; B++)
      _.push((0, t.createDeferrable)());
    return _;
  };
  t.createDeferrables = u;
  const y = async (p) => {
    await Promise.all(p.map((_) => _.complete));
  };
  t.allComplete = y;
  class b {
    constructor(_) {
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: _
      }), Object.defineProperty(this, "buffer", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: []
      }), Object.defineProperty(this, "promise", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "resolve", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "closed", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1
      }), Object.defineProperty(this, "toThrow", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.promise = Promise.resolve(), this.resolve = () => null, this.resetPromise();
    }
    get curr() {
      return this.buffer;
    }
    get size() {
      return this.buffer.length;
    }
    get isClosed() {
      return this.closed;
    }
    resetPromise() {
      this.promise = new Promise((_) => this.resolve = _);
    }
    push(_) {
      this.buffer.push(_), this.resolve();
    }
    pushMany(_) {
      _.forEach((B) => this.buffer.push(B)), this.resolve();
    }
    async *events() {
      for (; ; ) {
        if (this.closed && this.buffer.length === 0) {
          if (this.toThrow)
            throw this.toThrow;
          return;
        }
        if (await this.promise, this.toThrow)
          throw this.toThrow;
        if (this.maxSize && this.size > this.maxSize)
          throw new h(this.maxSize);
        const [_, ...B] = this.buffer;
        _ ? (this.buffer = B, yield _) : this.resetPromise();
      }
    }
    throw(_) {
      this.toThrow = _, this.closed = !0, this.resolve();
    }
    close() {
      this.closed = !0, this.resolve();
    }
  }
  t.AsyncBuffer = b;
  class h extends Error {
    constructor(_) {
      super(`ReachedMaxBufferSize: ${_}`);
    }
  }
  t.AsyncBufferFullError = h;
  const d = (p) => {
    const _ = p.filter(m).map((B) => B.reason);
    if (_.length !== 0)
      throw _.length === 1 ? _[0] : new AggregateError(_, "Multiple errors: " + _.map((B) => B?.message).join(`
`));
  };
  t.handleAllSettledErrors = d;
  const m = (p) => p.status === "rejected";
})(pf);
var rs = {};
Object.defineProperty(rs, "__esModule", { value: !0 });
rs.TID = void 0;
const Al = fa, Kc = 13;
let _u = 0, Mc = 0, _l = null;
function Nc(t) {
  return t.replaceAll("-", "");
}
class Gi {
  constructor(e) {
    Object.defineProperty(this, "str", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const r = Nc(e);
    if (r.length !== Kc)
      throw new Error(`Poorly formatted TID: ${r.length} length`);
    this.str = r;
  }
  static next(e) {
    const r = Math.max(Date.now(), _u);
    r === _u && Mc++, _u = r;
    const n = r * 1e3 + Mc;
    _l === null && (_l = Math.floor(Math.random() * 32));
    const u = Gi.fromTime(n, _l);
    return !e || u.newerThan(e) ? u : Gi.fromTime(e.timestamp() + 1, _l);
  }
  static nextStr(e) {
    return Gi.next(e ? new Gi(e) : void 0).toString();
  }
  static fromTime(e, r) {
    const n = `${(0, Al.s32encode)(e)}${(0, Al.s32encode)(r).padStart(2, "2")}`;
    return new Gi(n);
  }
  static fromStr(e) {
    return new Gi(e);
  }
  static oldestFirst(e, r) {
    return e.compareTo(r);
  }
  static newestFirst(e, r) {
    return r.compareTo(e);
  }
  static is(e) {
    return Nc(e).length === Kc;
  }
  timestamp() {
    return (0, Al.s32decode)(this.str.slice(0, 11));
  }
  clockid() {
    return (0, Al.s32decode)(this.str.slice(11, 13));
  }
  formatted() {
    const e = this.toString();
    return `${e.slice(0, 4)}-${e.slice(4, 7)}-${e.slice(7, 11)}-${e.slice(11, 13)}`;
  }
  toString() {
    return this.str;
  }
  // newer > older
  compareTo(e) {
    return this.str > e.str ? 1 : this.str < e.str ? -1 : 0;
  }
  equals(e) {
    return this.str === e.str;
  }
  newerThan(e) {
    return this.compareTo(e) > 0;
  }
  olderThan(e) {
    return this.compareTo(e) < 0;
  }
}
rs.TID = Gi;
rs.default = Gi;
var hf = {}, Ky = mf, Vc = 128, My = 127, Ny = ~My, Vy = Math.pow(2, 31);
function mf(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= Vy; )
    e[r++] = t & 255 | Vc, t /= 128;
  for (; t & Ny; )
    e[r++] = t & 255 | Vc, t >>>= 7;
  return e[r] = t | 0, mf.bytes = r - n + 1, e;
}
var jy = Vu, Fy = 128, jc = 127;
function Vu(t, n) {
  var r = 0, n = n || 0, u = 0, y = n, b, h = t.length;
  do {
    if (y >= h)
      throw Vu.bytes = 0, new RangeError("Could not decode varint");
    b = t[y++], r += u < 28 ? (b & jc) << u : (b & jc) * Math.pow(2, u), u += 7;
  } while (b >= Fy);
  return Vu.bytes = y - n, r;
}
var $y = Math.pow(2, 7), Gy = Math.pow(2, 14), qy = Math.pow(2, 21), Xy = Math.pow(2, 28), zy = Math.pow(2, 35), Hy = Math.pow(2, 42), Zy = Math.pow(2, 49), Wy = Math.pow(2, 56), Yy = Math.pow(2, 63), Jy = function(t) {
  return t < $y ? 1 : t < Gy ? 2 : t < qy ? 3 : t < Xy ? 4 : t < zy ? 5 : t < Hy ? 6 : t < Zy ? 7 : t < Wy ? 8 : t < Yy ? 9 : 10;
}, Qy = {
  encode: Ky,
  decode: jy,
  encodingLength: Jy
}, Ol = Qy;
const ju = (t, e = 0) => [
  Ol.decode(t, e),
  Ol.decode.bytes
], Kl = (t, e, r = 0) => (Ol.encode(t, e, r), e), Ml = (t) => Ol.encodingLength(t), eb = (t, e) => {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}, Wu = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, tb = (t) => new TextEncoder().encode(t), rb = (t) => new TextDecoder().decode(t), ib = (t, e) => {
  const r = e.byteLength, n = Ml(t), u = n + Ml(r), y = new Uint8Array(u + r);
  return Kl(t, y, 0), Kl(r, y, n), y.set(e, u), new Yu(t, r, e, y);
}, nb = (t) => {
  const e = Wu(t), [r, n] = ju(e), [u, y] = ju(e.subarray(n)), b = e.subarray(n + y);
  if (b.byteLength !== u)
    throw new Error("Incorrect length");
  return new Yu(r, u, b, e);
}, ab = (t, e) => t === e ? !0 : t.code === e.code && t.size === e.size && eb(t.bytes, e.bytes);
class Yu {
  constructor(e, r, n, u) {
    this.code = e, this.size = r, this.digest = n, this.bytes = u;
  }
}
function sb(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var u = 0; u < t.length; u++) {
    var y = t.charAt(u), b = y.charCodeAt(0);
    if (r[b] !== 255)
      throw new TypeError(y + " is ambiguous");
    r[b] = u;
  }
  var h = t.length, d = t.charAt(0), m = Math.log(h) / Math.log(256), p = Math.log(256) / Math.log(h);
  function _(X) {
    if (X instanceof Uint8Array || (ArrayBuffer.isView(X) ? X = new Uint8Array(X.buffer, X.byteOffset, X.byteLength) : Array.isArray(X) && (X = Uint8Array.from(X))), !(X instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (X.length === 0)
      return "";
    for (var te = 0, re = 0, J = 0, F = X.length; J !== F && X[J] === 0; )
      J++, te++;
    for (var z = (F - J) * p + 1 >>> 0, ee = new Uint8Array(z); J !== F; ) {
      for (var ye = X[J], xe = 0, Ee = z - 1; (ye !== 0 || xe < re) && Ee !== -1; Ee--, xe++)
        ye += 256 * ee[Ee] >>> 0, ee[Ee] = ye % h >>> 0, ye = ye / h >>> 0;
      if (ye !== 0)
        throw new Error("Non-zero carry");
      re = xe, J++;
    }
    for (var Ae = z - re; Ae !== z && ee[Ae] === 0; )
      Ae++;
    for (var De = d.repeat(te); Ae < z; ++Ae)
      De += t.charAt(ee[Ae]);
    return De;
  }
  function B(X) {
    if (typeof X != "string")
      throw new TypeError("Expected String");
    if (X.length === 0)
      return new Uint8Array();
    var te = 0;
    if (X[te] !== " ") {
      for (var re = 0, J = 0; X[te] === d; )
        re++, te++;
      for (var F = (X.length - te) * m + 1 >>> 0, z = new Uint8Array(F); X[te]; ) {
        var ee = r[X.charCodeAt(te)];
        if (ee === 255)
          return;
        for (var ye = 0, xe = F - 1; (ee !== 0 || ye < J) && xe !== -1; xe--, ye++)
          ee += h * z[xe] >>> 0, z[xe] = ee % 256 >>> 0, ee = ee / 256 >>> 0;
        if (ee !== 0)
          throw new Error("Non-zero carry");
        J = ye, te++;
      }
      if (X[te] !== " ") {
        for (var Ee = F - J; Ee !== F && z[Ee] === 0; )
          Ee++;
        for (var Ae = new Uint8Array(re + (F - Ee)), De = re; Ee !== F; )
          Ae[De++] = z[Ee++];
        return Ae;
      }
    }
  }
  function N(X) {
    var te = B(X);
    if (te)
      return te;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: _,
    decodeUnsafe: B,
    decode: N
  };
}
var ob = sb, lb = ob;
class ub {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class cb {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return yf(this, e);
  }
}
class db {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return yf(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const yf = (t, e) => new db({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class fb {
  constructor(e, r, n, u) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = u, this.encoder = new ub(e, r, n), this.decoder = new cb(e, r, u);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Ql = ({ name: t, prefix: e, encode: r, decode: n }) => new fb(t, e, r, n), is = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: u } = lb(r, e);
  return Ql({
    prefix: t,
    name: e,
    encode: n,
    decode: (y) => Wu(u(y))
  });
}, pb = (t, e, r, n) => {
  const u = {};
  for (let p = 0; p < e.length; ++p)
    u[e[p]] = p;
  let y = t.length;
  for (; t[y - 1] === "="; )
    --y;
  const b = new Uint8Array(y * r / 8 | 0);
  let h = 0, d = 0, m = 0;
  for (let p = 0; p < y; ++p) {
    const _ = u[t[p]];
    if (_ === void 0)
      throw new SyntaxError(`Non-${n} character`);
    d = d << r | _, h += r, h >= 8 && (h -= 8, b[m++] = 255 & d >> h);
  }
  if (h >= r || 255 & d << 8 - h)
    throw new SyntaxError("Unexpected end of data");
  return b;
}, hb = (t, e, r) => {
  const n = e[e.length - 1] === "=", u = (1 << r) - 1;
  let y = "", b = 0, h = 0;
  for (let d = 0; d < t.length; ++d)
    for (h = h << 8 | t[d], b += 8; b > r; )
      b -= r, y += e[u & h >> b];
  if (b && (y += e[u & h << r - b]), n)
    for (; y.length * r & 7; )
      y += "=";
  return y;
}, or = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => Ql({
  prefix: e,
  name: t,
  encode(u) {
    return hb(u, n, r);
  },
  decode(u) {
    return pb(u, n, r, t);
  }
}), qi = is({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), mb = is({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), yb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: qi,
  base58flickr: mb
}, Symbol.toStringTag, { value: "Module" })), za = or({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), bb = or({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), gb = or({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), xb = or({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), Eb = or({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), vb = or({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), Rb = or({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), Ab = or({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), _b = or({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), wb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: za,
  base32hex: Eb,
  base32hexpad: Rb,
  base32hexpadupper: Ab,
  base32hexupper: vb,
  base32pad: gb,
  base32padupper: xb,
  base32upper: bb,
  base32z: _b
}, Symbol.toStringTag, { value: "Module" }));
class ur {
  constructor(e, r, n, u) {
    this.code = r, this.version = e, this.multihash = n, this.bytes = u, this.byteOffset = u.byteOffset, this.byteLength = u.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, {
      byteOffset: Tl,
      byteLength: Tl,
      code: wl,
      version: wl,
      multihash: wl,
      bytes: wl,
      _baseCache: Tl,
      asCID: Tl
    });
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      default: {
        const { code: e, multihash: r } = this;
        if (e !== Fa)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (r.code !== Lb)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return ur.createV0(r);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: r } = this.multihash, n = ib(e, r);
        return ur.createV1(this.code, n);
      }
      case 1:
        return this;
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  equals(e) {
    return e && this.code === e.code && this.version === e.version && ab(this.multihash, e.multihash);
  }
  toString(e) {
    const { bytes: r, version: n, _baseCache: u } = this;
    switch (n) {
      case 0:
        return Sb(r, u, e || qi.encoder);
      default:
        return Cb(r, u, e || za.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(e) {
    return Db(/^0\.0/, Pb), !!(e && (e[$c] || e.asCID === e));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(e) {
    if (e instanceof ur)
      return e;
    if (e != null && e.asCID === e) {
      const { version: r, code: n, multihash: u, bytes: y } = e;
      return new ur(r, n, u, y || Fc(r, n, u.bytes));
    } else if (e != null && e[$c] === !0) {
      const { version: r, multihash: n, code: u } = e, y = nb(n);
      return ur.create(r, u, y);
    } else
      return null;
  }
  static create(e, r, n) {
    if (typeof r != "number")
      throw new Error("String codecs are no longer supported");
    switch (e) {
      case 0: {
        if (r !== Fa)
          throw new Error(`Version 0 CID must use dag-pb (code: ${Fa}) block encoding`);
        return new ur(e, r, n, n.bytes);
      }
      case 1: {
        const u = Fc(e, r, n.bytes);
        return new ur(e, r, n, u);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(e) {
    return ur.create(0, Fa, e);
  }
  static createV1(e, r) {
    return ur.create(1, e, r);
  }
  static decode(e) {
    const [r, n] = ur.decodeFirst(e);
    if (n.length)
      throw new Error("Incorrect length");
    return r;
  }
  static decodeFirst(e) {
    const r = ur.inspectBytes(e), n = r.size - r.multihashSize, u = Wu(e.subarray(n, n + r.multihashSize));
    if (u.byteLength !== r.multihashSize)
      throw new Error("Incorrect length");
    const y = u.subarray(r.multihashSize - r.digestSize), b = new Yu(r.multihashCode, r.digestSize, y, u);
    return [
      r.version === 0 ? ur.createV0(b) : ur.createV1(r.codec, b),
      e.subarray(r.size)
    ];
  }
  static inspectBytes(e) {
    let r = 0;
    const n = () => {
      const [_, B] = ju(e.subarray(r));
      return r += B, _;
    };
    let u = n(), y = Fa;
    if (u === 18 ? (u = 0, r = 0) : u === 1 && (y = n()), u !== 0 && u !== 1)
      throw new RangeError(`Invalid CID version ${u}`);
    const b = r, h = n(), d = n(), m = r + d, p = m - b;
    return {
      version: u,
      codec: y,
      multihashCode: h,
      digestSize: d,
      multihashSize: p,
      size: m
    };
  }
  static parse(e, r) {
    const [n, u] = Tb(e, r), y = ur.decode(u);
    return y._baseCache.set(n, e), y;
  }
}
const Tb = (t, e) => {
  switch (t[0]) {
    case "Q": {
      const r = e || qi;
      return [
        qi.prefix,
        r.decode(`${qi.prefix}${t}`)
      ];
    }
    case qi.prefix: {
      const r = e || qi;
      return [
        qi.prefix,
        r.decode(t)
      ];
    }
    case za.prefix: {
      const r = e || za;
      return [
        za.prefix,
        r.decode(t)
      ];
    }
    default: {
      if (e == null)
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      return [
        t[0],
        e.decode(t)
      ];
    }
  }
}, Sb = (t, e, r) => {
  const { prefix: n } = r;
  if (n !== qi.prefix)
    throw Error(`Cannot string encode V0 in ${r.name} encoding`);
  const u = e.get(n);
  if (u == null) {
    const y = r.encode(t).slice(1);
    return e.set(n, y), y;
  } else
    return u;
}, Cb = (t, e, r) => {
  const { prefix: n } = r, u = e.get(n);
  if (u == null) {
    const y = r.encode(t);
    return e.set(n, y), y;
  } else
    return u;
}, Fa = 112, Lb = 18, Fc = (t, e, r) => {
  const n = Ml(t), u = n + Ml(e), y = new Uint8Array(u + r.byteLength);
  return Kl(t, y, 0), Kl(e, y, n), y.set(r, u), y;
}, $c = Symbol.for("@ipld/js-cid/CID"), wl = {
  writable: !1,
  configurable: !1,
  enumerable: !0
}, Tl = {
  writable: !1,
  enumerable: !1,
  configurable: !1
}, kb = "0.0.0-dev", Db = (t, e) => {
  if (t.test(kb))
    console.warn(e);
  else
    throw new Error(e);
}, Pb = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`, Bb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CID: ur
}, Symbol.toStringTag, { value: "Module" })), Pa = /* @__PURE__ */ Jd(Bb);
function Ib(t, e) {
  for (let r = 0; r < t.byteLength; r++) {
    if (t[r] < e[r])
      return -1;
    if (t[r] > e[r])
      return 1;
  }
  return t.byteLength > e.byteLength ? 1 : t.byteLength < e.byteLength ? -1 : 0;
}
function Ub(t, e) {
  e || (e = t.reduce((u, y) => u + y.length, 0));
  const r = new Uint8Array(e);
  let n = 0;
  for (const u of t)
    r.set(u, n), n += u.length;
  return r;
}
function Ob(t, e) {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const Kb = Ql({
  prefix: "\0",
  name: "identity",
  encode: (t) => rb(t),
  decode: (t) => tb(t)
}), Mb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: Kb
}, Symbol.toStringTag, { value: "Module" })), Nb = or({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), Vb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: Nb
}, Symbol.toStringTag, { value: "Module" })), jb = or({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), Fb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: jb
}, Symbol.toStringTag, { value: "Module" })), $b = is({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), Gb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: $b
}, Symbol.toStringTag, { value: "Module" })), qb = or({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), Xb = or({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), zb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: qb,
  base16upper: Xb
}, Symbol.toStringTag, { value: "Module" })), Hb = is({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), Zb = is({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), Wb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: Hb,
  base36upper: Zb
}, Symbol.toStringTag, { value: "Module" })), Yb = or({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), Jb = or({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), Qb = or({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), eg = or({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), tg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: Yb,
  base64pad: Jb,
  base64url: Qb,
  base64urlpad: eg
}, Symbol.toStringTag, { value: "Module" })), bf = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), rg = bf.reduce((t, e, r) => (t[r] = e, t), []), ig = bf.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function ng(t) {
  return t.reduce((e, r) => (e += rg[r], e), "");
}
function ag(t) {
  const e = [];
  for (const r of t) {
    const n = ig[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const sg = Ql({
  prefix: "🚀",
  name: "base256emoji",
  encode: ng,
  decode: ag
}), og = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: sg
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Gc = {
  ...Mb,
  ...Vb,
  ...Fb,
  ...Gb,
  ...zb,
  ...wb,
  ...Wb,
  ...yb,
  ...tg,
  ...og
};
function gf(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: n }
  };
}
const qc = gf("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), wu = gf("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), xf = {
  utf8: qc,
  "utf-8": qc,
  hex: Gc.base16,
  latin1: wu,
  ascii: wu,
  binary: wu,
  ...Gc
};
function lg(t, e = "utf8") {
  const r = xf[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return r.decoder.decode(`${r.prefix}${t}`);
}
function ug(t, e = "utf8") {
  const r = xf[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return r.encoder.encode(t).substring(1);
}
function cg(t, e) {
  if (t.length !== e.length)
    throw new Error("Inputs should have the same length");
  const r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t[n] ^ e[n];
  return r;
}
const dg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: Ib,
  concat: Ub,
  equals: Ob,
  fromString: lg,
  toString: ug,
  xor: cg
}, Symbol.toStringTag, { value: "Module" })), Ef = /* @__PURE__ */ Jd(dg);
(function(t) {
  var e = de && de.__createBinding || (Object.create ? function(m, p, _, B) {
    B === void 0 && (B = _);
    var N = Object.getOwnPropertyDescriptor(p, _);
    (!N || ("get" in N ? !p.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
      return p[_];
    } }), Object.defineProperty(m, B, N);
  } : function(m, p, _, B) {
    B === void 0 && (B = _), m[B] = p[_];
  }), r = de && de.__setModuleDefault || (Object.create ? function(m, p) {
    Object.defineProperty(m, "default", { enumerable: !0, value: p });
  } : function(m, p) {
    m.default = p;
  }), n = de && de.__importStar || function(m) {
    if (m && m.__esModule) return m;
    var p = {};
    if (m != null) for (var _ in m) _ !== "default" && Object.prototype.hasOwnProperty.call(m, _) && e(p, m, _);
    return r(p, m), p;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ipldEquals = t.ipldToJson = t.jsonToIpld = void 0;
  const u = Pa, y = n(Ef), b = (m) => {
    if (Array.isArray(m))
      return m.map((p) => (0, t.jsonToIpld)(p));
    if (m && typeof m == "object") {
      if (typeof m.$link == "string" && Object.keys(m).length === 1)
        return u.CID.parse(m.$link);
      if (typeof m.$bytes == "string" && Object.keys(m).length === 1)
        return y.fromString(m.$bytes, "base64");
      const p = {};
      for (const _ of Object.keys(m))
        p[_] = (0, t.jsonToIpld)(m[_]);
      return p;
    }
    return m;
  };
  t.jsonToIpld = b;
  const h = (m) => {
    if (Array.isArray(m))
      return m.map((p) => (0, t.ipldToJson)(p));
    if (m && typeof m == "object") {
      if (m instanceof Uint8Array)
        return {
          $bytes: y.toString(m, "base64")
        };
      if (u.CID.asCID(m))
        return {
          $link: m.toString()
        };
      const p = {};
      for (const _ of Object.keys(m))
        p[_] = (0, t.ipldToJson)(m[_]);
      return p;
    }
    return m;
  };
  t.ipldToJson = h;
  const d = (m, p) => {
    if (Array.isArray(m) && Array.isArray(p)) {
      if (m.length !== p.length)
        return !1;
      for (let _ = 0; _ < m.length; _++)
        if (!(0, t.ipldEquals)(m[_], p[_]))
          return !1;
      return !0;
    }
    if (m && p && typeof m == "object" && typeof p == "object") {
      if (m instanceof Uint8Array && p instanceof Uint8Array)
        return y.equals(m, p);
      if (u.CID.asCID(m) && u.CID.asCID(p))
        return u.CID.asCID(m)?.equals(u.CID.asCID(p));
      if (Object.keys(m).length !== Object.keys(p).length)
        return !1;
      for (const _ of Object.keys(m))
        if (!(0, t.ipldEquals)(m[_], p[_]))
          return !1;
      return !0;
    }
    return m === p;
  };
  t.ipldEquals = d;
})(hf);
var ha = {};
Object.defineProperty(ha, "__esModule", { value: !0 });
ha.backoffMs = ha.retry = void 0;
const fg = fa;
async function pg(t, e = {}) {
  const { maxRetries: r = 3, retryable: n = () => !0, getWaitMs: u = vf } = e;
  let y = 0, b;
  for (; !b; )
    try {
      return await t();
    } catch (h) {
      const d = u(y);
      y < r && d !== null && n(h) ? (y += 1, d !== 0 && await (0, fg.wait)(d)) : b = h;
    }
  throw b;
}
ha.retry = pg;
function vf(t, e = 100, r = 1e3) {
  const n = Math.pow(2, t) * e, u = Math.min(n, r);
  return hg(u);
}
ha.backoffMs = vf;
function hg(t) {
  const e = t * 0.15;
  return t + mg(-e, e);
}
function mg(t, e) {
  return Math.random() * (e - t) + t;
}
var Rf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.def = t.schema = void 0;
  const e = Pa, r = ia, n = r.z.any().refine((u) => e.CID.asCID(u) !== null, {
    message: "Not a CID"
  }).transform((u) => e.CID.asCID(u));
  t.schema = {
    cid: n,
    bytes: r.z.instanceof(Uint8Array),
    string: r.z.string(),
    array: r.z.array(r.z.unknown()),
    map: r.z.record(r.z.string(), r.z.unknown()),
    unknown: r.z.unknown()
  }, t.def = {
    cid: {
      name: "cid",
      schema: t.schema.cid
    },
    bytes: {
      name: "bytes",
      schema: t.schema.bytes
    },
    string: {
      name: "string",
      schema: t.schema.string
    },
    map: {
      name: "map",
      schema: t.schema.map
    },
    unknown: {
      name: "unknown",
      schema: t.schema.unknown
    }
  };
})(Rf);
var Af = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.addHoursToDate = t.lessThanAgoMs = t.DAY = t.HOUR = t.MINUTE = t.SECOND = void 0, t.SECOND = 1e3, t.MINUTE = t.SECOND * 60, t.HOUR = t.MINUTE * 60, t.DAY = t.HOUR * 24;
  const e = (n, u) => Date.now() < n.getTime() + u;
  t.lessThanAgoMs = e;
  const r = (n, u) => {
    const y = u ? new Date(u) : /* @__PURE__ */ new Date();
    return y.setHours(y.getHours() + n), y;
  };
  t.addHoursToDate = r;
})(Af);
var Sr = {}, Ju = {}, Qu = {}, ec = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.EXTENDED_PICTOGRAPHIC = t.CLUSTER_BREAK = void 0, function(e) {
    e[e.CR = 0] = "CR", e[e.LF = 1] = "LF", e[e.CONTROL = 2] = "CONTROL", e[e.EXTEND = 3] = "EXTEND", e[e.REGIONAL_INDICATOR = 4] = "REGIONAL_INDICATOR", e[e.SPACINGMARK = 5] = "SPACINGMARK", e[e.L = 6] = "L", e[e.V = 7] = "V", e[e.T = 8] = "T", e[e.LV = 9] = "LV", e[e.LVT = 10] = "LVT", e[e.OTHER = 11] = "OTHER", e[e.PREPEND = 12] = "PREPEND", e[e.E_BASE = 13] = "E_BASE", e[e.E_MODIFIER = 14] = "E_MODIFIER", e[e.ZWJ = 15] = "ZWJ", e[e.GLUE_AFTER_ZWJ = 16] = "GLUE_AFTER_ZWJ", e[e.E_BASE_GAZ = 17] = "E_BASE_GAZ";
  }(t.CLUSTER_BREAK || (t.CLUSTER_BREAK = {})), t.EXTENDED_PICTOGRAPHIC = 101;
})(ec);
var tc = {};
Object.defineProperty(tc, "__esModule", { value: !0 });
const He = ec, Vi = 0, Tu = 1, yg = 2, bg = 3, gg = 4;
class xg {
  /**
   * Check if the the character at the position {pos} of the string is surrogate
   * @param str {string}
   * @param pos {number}
   * @returns {boolean}
   */
  static isSurrogate(e, r) {
    return 55296 <= e.charCodeAt(r) && e.charCodeAt(r) <= 56319 && 56320 <= e.charCodeAt(r + 1) && e.charCodeAt(r + 1) <= 57343;
  }
  /**
   * The String.prototype.codePointAt polyfill
   * Private function, gets a Unicode code point from a JavaScript UTF-16 string
   * handling surrogate pairs appropriately
   * @param str {string}
   * @param idx {number}
   * @returns {number}
   */
  static codePointAt(e, r) {
    r === void 0 && (r = 0);
    const n = e.charCodeAt(r);
    if (55296 <= n && n <= 56319 && r < e.length - 1) {
      const u = n, y = e.charCodeAt(r + 1);
      return 56320 <= y && y <= 57343 ? (u - 55296) * 1024 + (y - 56320) + 65536 : u;
    }
    if (56320 <= n && n <= 57343 && r >= 1) {
      const u = e.charCodeAt(r - 1), y = n;
      return 55296 <= u && u <= 56319 ? (u - 55296) * 1024 + (y - 56320) + 65536 : y;
    }
    return n;
  }
  //
  /**
   * Private function, returns whether a break is allowed between the two given grapheme breaking classes
   * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters
   * @param start {number}
   * @param mid {Array<number>}
   * @param end {number}
   * @param startEmoji {number}
   * @param midEmoji {Array<number>}
   * @param endEmoji {number}
   * @returns {number}
   */
  static shouldBreak(e, r, n, u, y, b) {
    const h = [e].concat(r).concat([n]), d = [u].concat(y).concat([b]), m = h[h.length - 2], p = n, _ = b, B = h.lastIndexOf(He.CLUSTER_BREAK.REGIONAL_INDICATOR);
    if (B > 0 && h.slice(1, B).every(function(X) {
      return X === He.CLUSTER_BREAK.REGIONAL_INDICATOR;
    }) && [He.CLUSTER_BREAK.PREPEND, He.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(m) === -1)
      return h.filter(function(X) {
        return X === He.CLUSTER_BREAK.REGIONAL_INDICATOR;
      }).length % 2 === 1 ? bg : gg;
    if (m === He.CLUSTER_BREAK.CR && p === He.CLUSTER_BREAK.LF)
      return Vi;
    if (m === He.CLUSTER_BREAK.CONTROL || m === He.CLUSTER_BREAK.CR || m === He.CLUSTER_BREAK.LF)
      return Tu;
    if (p === He.CLUSTER_BREAK.CONTROL || p === He.CLUSTER_BREAK.CR || p === He.CLUSTER_BREAK.LF)
      return Tu;
    if (m === He.CLUSTER_BREAK.L && (p === He.CLUSTER_BREAK.L || p === He.CLUSTER_BREAK.V || p === He.CLUSTER_BREAK.LV || p === He.CLUSTER_BREAK.LVT))
      return Vi;
    if ((m === He.CLUSTER_BREAK.LV || m === He.CLUSTER_BREAK.V) && (p === He.CLUSTER_BREAK.V || p === He.CLUSTER_BREAK.T))
      return Vi;
    if ((m === He.CLUSTER_BREAK.LVT || m === He.CLUSTER_BREAK.T) && p === He.CLUSTER_BREAK.T)
      return Vi;
    if (p === He.CLUSTER_BREAK.EXTEND || p === He.CLUSTER_BREAK.ZWJ)
      return Vi;
    if (p === He.CLUSTER_BREAK.SPACINGMARK)
      return Vi;
    if (m === He.CLUSTER_BREAK.PREPEND)
      return Vi;
    const N = d.slice(0, -1).lastIndexOf(He.EXTENDED_PICTOGRAPHIC);
    return N !== -1 && d[N] === He.EXTENDED_PICTOGRAPHIC && h.slice(N + 1, -2).every(function(X) {
      return X === He.CLUSTER_BREAK.EXTEND;
    }) && m === He.CLUSTER_BREAK.ZWJ && _ === He.EXTENDED_PICTOGRAPHIC ? Vi : r.indexOf(He.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1 ? yg : m === He.CLUSTER_BREAK.REGIONAL_INDICATOR && p === He.CLUSTER_BREAK.REGIONAL_INDICATOR ? Vi : Tu;
  }
}
tc.default = xg;
var rc = {};
Object.defineProperty(rc, "__esModule", { value: !0 });
class Eg {
  constructor(e, r) {
    this._index = 0, this._str = e, this._nextBreak = r;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let e;
    if ((e = this._nextBreak(this._str, this._index)) < this._str.length) {
      const r = this._str.slice(this._index, e);
      return this._index = e, { value: r, done: !1 };
    }
    if (this._index < this._str.length) {
      const r = this._str.slice(this._index);
      return this._index = this._str.length, { value: r, done: !1 };
    }
    return { value: void 0, done: !0 };
  }
}
rc.default = Eg;
var _f = de && de.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Qu, "__esModule", { value: !0 });
const i = ec, Sl = _f(tc), vg = _f(rc);
class Fi {
  /**
   * Returns the next grapheme break in the string after the given index
   * @param string {string}
   * @param index {number}
   * @returns {number}
   */
  static nextBreak(e, r) {
    if (r === void 0 && (r = 0), r < 0)
      return 0;
    if (r >= e.length - 1)
      return e.length;
    const n = Sl.default.codePointAt(e, r), u = Fi.getGraphemeBreakProperty(n), y = Fi.getEmojiProperty(n), b = [], h = [];
    for (let d = r + 1; d < e.length; d++) {
      if (Sl.default.isSurrogate(e, d - 1))
        continue;
      const m = Sl.default.codePointAt(e, d), p = Fi.getGraphemeBreakProperty(m), _ = Fi.getEmojiProperty(m);
      if (Sl.default.shouldBreak(u, b, p, y, h, _))
        return d;
      b.push(p), h.push(_);
    }
    return e.length;
  }
  /**
   * Breaks the given string into an array of grapheme clusters
   * @param str {string}
   * @returns {string[]}
   */
  splitGraphemes(e) {
    const r = [];
    let n = 0, u;
    for (; (u = Fi.nextBreak(e, n)) < e.length; )
      r.push(e.slice(n, u)), n = u;
    return n < e.length && r.push(e.slice(n)), r;
  }
  /**
   * Returns an iterator of grapheme clusters in the given string
   * @param str {string}
   * @returns {GraphemerIterator}
   */
  iterateGraphemes(e) {
    return new vg.default(e, Fi.nextBreak);
  }
  /**
   * Returns the number of grapheme clusters in the given string
   * @param str {string}
   * @returns {number}
   */
  countGraphemes(e) {
    let r = 0, n = 0, u;
    for (; (u = Fi.nextBreak(e, n)) < e.length; )
      n = u, r++;
    return n < e.length && r++, r;
  }
  /**
   * Given a Unicode code point, determines this symbol's grapheme break property
   * @param code {number} Unicode code point
   * @returns {number}
   */
  static getGraphemeBreakProperty(e) {
    if (e < 48905) {
      if (e < 44116) {
        if (e < 4141) {
          if (e < 2818) {
            if (e < 2363)
              if (e < 1759) {
                if (e < 1471) {
                  if (e < 127) {
                    if (e < 11) {
                      if (e < 10) {
                        if (0 <= e && e <= 9)
                          return i.CLUSTER_BREAK.CONTROL;
                      } else if (e === 10)
                        return i.CLUSTER_BREAK.LF;
                    } else if (e < 13) {
                      if (11 <= e && e <= 12)
                        return i.CLUSTER_BREAK.CONTROL;
                    } else if (e < 14) {
                      if (e === 13)
                        return i.CLUSTER_BREAK.CR;
                    } else if (14 <= e && e <= 31)
                      return i.CLUSTER_BREAK.CONTROL;
                  } else if (e < 768) {
                    if (e < 173) {
                      if (127 <= e && e <= 159)
                        return i.CLUSTER_BREAK.CONTROL;
                    } else if (e === 173)
                      return i.CLUSTER_BREAK.CONTROL;
                  } else if (e < 1155) {
                    if (768 <= e && e <= 879)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1425) {
                    if (1155 <= e && e <= 1161)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (1425 <= e && e <= 1469)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 1552) {
                  if (e < 1476) {
                    if (e < 1473) {
                      if (e === 1471)
                        return i.CLUSTER_BREAK.EXTEND;
                    } else if (1473 <= e && e <= 1474)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1479) {
                    if (1476 <= e && e <= 1477)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1536) {
                    if (e === 1479)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (1536 <= e && e <= 1541)
                    return i.CLUSTER_BREAK.PREPEND;
                } else if (e < 1648) {
                  if (e < 1564) {
                    if (1552 <= e && e <= 1562)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1611) {
                    if (e === 1564)
                      return i.CLUSTER_BREAK.CONTROL;
                  } else if (1611 <= e && e <= 1631)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 1750) {
                  if (e === 1648)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 1757) {
                  if (1750 <= e && e <= 1756)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 1757)
                  return i.CLUSTER_BREAK.PREPEND;
              } else if (e < 2075) {
                if (e < 1840)
                  if (e < 1770) {
                    if (e < 1767) {
                      if (1759 <= e && e <= 1764)
                        return i.CLUSTER_BREAK.EXTEND;
                    } else if (1767 <= e && e <= 1768)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1807) {
                    if (1770 <= e && e <= 1773)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else {
                    if (e === 1807)
                      return i.CLUSTER_BREAK.PREPEND;
                    if (e === 1809)
                      return i.CLUSTER_BREAK.EXTEND;
                  }
                else if (e < 2027) {
                  if (e < 1958) {
                    if (1840 <= e && e <= 1866)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (1958 <= e && e <= 1968)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2045) {
                  if (2027 <= e && e <= 2035)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2070) {
                  if (e === 2045)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (2070 <= e && e <= 2073)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2200) {
                if (e < 2089) {
                  if (e < 2085) {
                    if (2075 <= e && e <= 2083)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (2085 <= e && e <= 2087)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2137) {
                  if (2089 <= e && e <= 2093)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2192) {
                  if (2137 <= e && e <= 2139)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (2192 <= e && e <= 2193)
                  return i.CLUSTER_BREAK.PREPEND;
              } else if (e < 2275) {
                if (e < 2250) {
                  if (2200 <= e && e <= 2207)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2274) {
                  if (2250 <= e && e <= 2273)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 2274)
                  return i.CLUSTER_BREAK.PREPEND;
              } else if (e < 2307) {
                if (2275 <= e && e <= 2306)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 2307)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 2362)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 2561) {
              if (e < 2434) {
                if (e < 2381) {
                  if (e < 2366) {
                    if (e === 2363)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                    if (e === 2364)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2369) {
                    if (2366 <= e && e <= 2368)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2377) {
                    if (2369 <= e && e <= 2376)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (2377 <= e && e <= 2380)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2385) {
                  if (e < 2382) {
                    if (e === 2381)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (2382 <= e && e <= 2383)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2402) {
                  if (2385 <= e && e <= 2391)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2433) {
                  if (2402 <= e && e <= 2403)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 2433)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2503) {
                if (e < 2494) {
                  if (e < 2492) {
                    if (2434 <= e && e <= 2435)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 2492)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2495) {
                  if (e === 2494)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2497) {
                  if (2495 <= e && e <= 2496)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (2497 <= e && e <= 2500)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2519) {
                if (e < 2507) {
                  if (2503 <= e && e <= 2504)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2509) {
                  if (2507 <= e && e <= 2508)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 2509)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2530) {
                if (e === 2519)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2558) {
                if (2530 <= e && e <= 2531)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 2558)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2691) {
              if (e < 2631) {
                if (e < 2620) {
                  if (e < 2563) {
                    if (2561 <= e && e <= 2562)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2563)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2622) {
                  if (e === 2620)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2625) {
                  if (2622 <= e && e <= 2624)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (2625 <= e && e <= 2626)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2672) {
                if (e < 2635) {
                  if (2631 <= e && e <= 2632)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2641) {
                  if (2635 <= e && e <= 2637)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 2641)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2677) {
                if (2672 <= e && e <= 2673)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2689) {
                if (e === 2677)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (2689 <= e && e <= 2690)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2761) {
              if (e < 2750) {
                if (e === 2691)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 2748)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2753) {
                if (2750 <= e && e <= 2752)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 2759) {
                if (2753 <= e && e <= 2757)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (2759 <= e && e <= 2760)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2786) {
              if (e < 2763) {
                if (e === 2761)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 2765) {
                if (2763 <= e && e <= 2764)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 2765)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2810) {
              if (2786 <= e && e <= 2787)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2817) {
              if (2810 <= e && e <= 2815)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 2817)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3315) {
            if (e < 3076) {
              if (e < 2946) {
                if (e < 2887) {
                  if (e < 2878) {
                    if (e < 2876) {
                      if (2818 <= e && e <= 2819)
                        return i.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e === 2876)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2880) {
                    if (2878 <= e && e <= 2879)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2881) {
                    if (e === 2880)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2881 <= e && e <= 2884)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2893) {
                  if (e < 2891) {
                    if (2887 <= e && e <= 2888)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2891 <= e && e <= 2892)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2901) {
                  if (e === 2893)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2914) {
                  if (2901 <= e && e <= 2903)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (2914 <= e && e <= 2915)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3014) {
                if (e < 3007) {
                  if (e === 2946 || e === 3006)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3008) {
                  if (e === 3007)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3009) {
                  if (e === 3008)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (3009 <= e && e <= 3010)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3031) {
                if (e < 3018) {
                  if (3014 <= e && e <= 3016)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3021) {
                  if (3018 <= e && e <= 3020)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 3021)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3072) {
                if (e === 3031)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3073) {
                if (e === 3072)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3073 <= e && e <= 3075)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3262) {
              if (e < 3146) {
                if (e < 3134) {
                  if (e === 3076 || e === 3132)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3137) {
                  if (3134 <= e && e <= 3136)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3142) {
                  if (3137 <= e && e <= 3140)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (3142 <= e && e <= 3144)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3201) {
                if (e < 3157) {
                  if (3146 <= e && e <= 3149)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3170) {
                  if (3157 <= e && e <= 3158)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (3170 <= e && e <= 3171)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3202) {
                if (e === 3201)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3260) {
                if (3202 <= e && e <= 3203)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 3260)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3270) {
              if (e < 3264) {
                if (e === 3262)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 3263)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3266) {
                if (3264 <= e && e <= 3265)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3267) {
                if (e === 3266)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3267 <= e && e <= 3268)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3276) {
              if (e < 3271) {
                if (e === 3270)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3274) {
                if (3271 <= e && e <= 3272)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (3274 <= e && e <= 3275)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3285) {
              if (3276 <= e && e <= 3277)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3298) {
              if (3285 <= e && e <= 3286)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3298 <= e && e <= 3299)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3551) {
            if (e < 3406) {
              if (e < 3391) {
                if (e < 3330) {
                  if (e < 3328) {
                    if (e === 3315)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (3328 <= e && e <= 3329)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3387) {
                  if (3330 <= e && e <= 3331)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3390) {
                  if (3387 <= e && e <= 3388)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 3390)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3398) {
                if (e < 3393) {
                  if (3391 <= e && e <= 3392)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (3393 <= e && e <= 3396)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3402) {
                if (3398 <= e && e <= 3400)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3405) {
                if (3402 <= e && e <= 3404)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 3405)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3530) {
              if (e < 3426) {
                if (e === 3406)
                  return i.CLUSTER_BREAK.PREPEND;
                if (e === 3415)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3457) {
                if (3426 <= e && e <= 3427)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3458) {
                if (e === 3457)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3458 <= e && e <= 3459)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3538) {
              if (e < 3535) {
                if (e === 3530)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3536) {
                if (e === 3535)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3536 <= e && e <= 3537)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3542) {
              if (3538 <= e && e <= 3540)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3544) {
              if (e === 3542)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3544 <= e && e <= 3550)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 3893) {
            if (e < 3655) {
              if (e < 3633) {
                if (e < 3570) {
                  if (e === 3551)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (3570 <= e && e <= 3571)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3635) {
                if (e === 3633)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3636) {
                if (e === 3635)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (3636 <= e && e <= 3642)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3764)
              if (e < 3761) {
                if (3655 <= e && e <= 3662)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 3761)
                  return i.CLUSTER_BREAK.EXTEND;
                if (e === 3763)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 3784) {
              if (3764 <= e && e <= 3772)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3864) {
              if (3784 <= e && e <= 3790)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3864 <= e && e <= 3865)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3967) {
            if (e < 3897) {
              if (e === 3893 || e === 3895)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3902) {
              if (e === 3897)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3953) {
              if (3902 <= e && e <= 3903)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (3953 <= e && e <= 3966)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3981) {
            if (e < 3968) {
              if (e === 3967)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3974) {
              if (3968 <= e && e <= 3972)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3974 <= e && e <= 3975)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3993) {
            if (3981 <= e && e <= 3991)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 4038) {
            if (3993 <= e && e <= 4028)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 4038)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 7204) {
          if (e < 6448) {
            if (e < 5938) {
              if (e < 4226) {
                if (e < 4157) {
                  if (e < 4146) {
                    if (e < 4145) {
                      if (4141 <= e && e <= 4144)
                        return i.CLUSTER_BREAK.EXTEND;
                    } else if (e === 4145)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4153) {
                    if (4146 <= e && e <= 4151)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 4155) {
                    if (4153 <= e && e <= 4154)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (4155 <= e && e <= 4156)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4184) {
                  if (e < 4182) {
                    if (4157 <= e && e <= 4158)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (4182 <= e && e <= 4183)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4190) {
                  if (4184 <= e && e <= 4185)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 4209) {
                  if (4190 <= e && e <= 4192)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (4209 <= e && e <= 4212)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 4352) {
                if (e < 4229) {
                  if (e === 4226)
                    return i.CLUSTER_BREAK.EXTEND;
                  if (e === 4228)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4237) {
                  if (4229 <= e && e <= 4230)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 4237 || e === 4253)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 4957) {
                if (e < 4448) {
                  if (4352 <= e && e <= 4447)
                    return i.CLUSTER_BREAK.L;
                } else if (e < 4520) {
                  if (4448 <= e && e <= 4519)
                    return i.CLUSTER_BREAK.V;
                } else if (4520 <= e && e <= 4607)
                  return i.CLUSTER_BREAK.T;
              } else if (e < 5906) {
                if (4957 <= e && e <= 4959)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 5909) {
                if (5906 <= e && e <= 5908)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 5909)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6089) {
              if (e < 6070) {
                if (e < 5970) {
                  if (e < 5940) {
                    if (5938 <= e && e <= 5939)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e === 5940)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6002) {
                  if (5970 <= e && e <= 5971)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 6068) {
                  if (6002 <= e && e <= 6003)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (6068 <= e && e <= 6069)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6078) {
                if (e < 6071) {
                  if (e === 6070)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (6071 <= e && e <= 6077)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6086) {
                if (6078 <= e && e <= 6085)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6087) {
                if (e === 6086)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6087 <= e && e <= 6088)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6277)
              if (e < 6155) {
                if (e < 6109) {
                  if (6089 <= e && e <= 6099)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 6109)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6158) {
                if (6155 <= e && e <= 6157)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 6158)
                  return i.CLUSTER_BREAK.CONTROL;
                if (e === 6159)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 6435) {
              if (e < 6313) {
                if (6277 <= e && e <= 6278)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6432) {
                if (e === 6313)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6432 <= e && e <= 6434)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 6439) {
              if (6435 <= e && e <= 6438)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6441) {
              if (6439 <= e && e <= 6440)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (6441 <= e && e <= 6443)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 6971) {
            if (e < 6744)
              if (e < 6681) {
                if (e < 6451) {
                  if (e < 6450) {
                    if (6448 <= e && e <= 6449)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 6450)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 6457) {
                  if (6451 <= e && e <= 6456)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6679) {
                  if (6457 <= e && e <= 6459)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (6679 <= e && e <= 6680)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6741) {
                if (e < 6683) {
                  if (6681 <= e && e <= 6682)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 6683)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6742) {
                if (e === 6741)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else {
                if (e === 6742)
                  return i.CLUSTER_BREAK.EXTEND;
                if (e === 6743)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 6771) {
              if (e < 6754) {
                if (e < 6752) {
                  if (6744 <= e && e <= 6750)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 6752)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6757) {
                if (e === 6754)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6765) {
                if (6757 <= e && e <= 6764)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6765 <= e && e <= 6770)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6912) {
              if (e < 6783) {
                if (6771 <= e && e <= 6780)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6832) {
                if (e === 6783)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6832 <= e && e <= 6862)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 6916) {
              if (6912 <= e && e <= 6915)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 6964) {
              if (e === 6916)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (6964 <= e && e <= 6970)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 7080) {
            if (e < 7019) {
              if (e < 6973) {
                if (e === 6971)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 6972)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6978) {
                if (6973 <= e && e <= 6977)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6979) {
                if (e === 6978)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6979 <= e && e <= 6980)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7073) {
              if (e < 7040) {
                if (7019 <= e && e <= 7027)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 7042) {
                if (7040 <= e && e <= 7041)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 7042)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7074) {
              if (e === 7073)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7078) {
              if (7074 <= e && e <= 7077)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (7078 <= e && e <= 7079)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 7144)
            if (e < 7083) {
              if (e < 7082) {
                if (7080 <= e && e <= 7081)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 7082)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7142) {
              if (7083 <= e && e <= 7085)
                return i.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 7142)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 7143)
                return i.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 7150) {
            if (e < 7146) {
              if (7144 <= e && e <= 7145)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 7149) {
              if (7146 <= e && e <= 7148)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 7149)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 7151) {
            if (e === 7150)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 7154) {
            if (7151 <= e && e <= 7153)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (7154 <= e && e <= 7155)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 43346) {
          if (e < 11647) {
            if (e < 7415) {
              if (e < 7380) {
                if (e < 7220) {
                  if (e < 7212) {
                    if (7204 <= e && e <= 7211)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (7212 <= e && e <= 7219)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 7222) {
                  if (7220 <= e && e <= 7221)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 7376) {
                  if (7222 <= e && e <= 7223)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (7376 <= e && e <= 7378)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 7394) {
                if (e < 7393) {
                  if (7380 <= e && e <= 7392)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 7393)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7405) {
                if (7394 <= e && e <= 7400)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 7405 || e === 7412)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 8205)
              if (e < 7616) {
                if (e < 7416) {
                  if (e === 7415)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (7416 <= e && e <= 7417)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 8203) {
                if (7616 <= e && e <= 7679)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 8203)
                  return i.CLUSTER_BREAK.CONTROL;
                if (e === 8204)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 8288) {
              if (e < 8206) {
                if (e === 8205)
                  return i.CLUSTER_BREAK.ZWJ;
              } else if (e < 8232) {
                if (8206 <= e && e <= 8207)
                  return i.CLUSTER_BREAK.CONTROL;
              } else if (8232 <= e && e <= 8238)
                return i.CLUSTER_BREAK.CONTROL;
            } else if (e < 8400) {
              if (8288 <= e && e <= 8303)
                return i.CLUSTER_BREAK.CONTROL;
            } else if (e < 11503) {
              if (8400 <= e && e <= 8432)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (11503 <= e && e <= 11505)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43043) {
            if (e < 42612) {
              if (e < 12330) {
                if (e < 11744) {
                  if (e === 11647)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (11744 <= e && e <= 11775)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 12441) {
                if (12330 <= e && e <= 12335)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 42607) {
                if (12441 <= e && e <= 12442)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (42607 <= e && e <= 42610)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43010) {
              if (e < 42654) {
                if (42612 <= e && e <= 42621)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 42736) {
                if (42654 <= e && e <= 42655)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (42736 <= e && e <= 42737)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43014) {
              if (e === 43010)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 43014 || e === 43019)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43188) {
            if (e < 43047) {
              if (e < 43045) {
                if (43043 <= e && e <= 43044)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (43045 <= e && e <= 43046)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43052) {
              if (e === 43047)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43136) {
              if (e === 43052)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43136 <= e && e <= 43137)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43263) {
            if (e < 43204) {
              if (43188 <= e && e <= 43203)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43232) {
              if (43204 <= e && e <= 43205)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43232 <= e && e <= 43249)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43302) {
            if (e === 43263)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43335) {
            if (43302 <= e && e <= 43309)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (43335 <= e && e <= 43345)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 43698) {
          if (e < 43493) {
            if (e < 43444)
              if (e < 43392) {
                if (e < 43360) {
                  if (43346 <= e && e <= 43347)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (43360 <= e && e <= 43388)
                  return i.CLUSTER_BREAK.L;
              } else if (e < 43395) {
                if (43392 <= e && e <= 43394)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 43395)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 43443)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 43450) {
              if (e < 43446) {
                if (43444 <= e && e <= 43445)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (43446 <= e && e <= 43449)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43452) {
              if (43450 <= e && e <= 43451)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43454) {
              if (43452 <= e && e <= 43453)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43454 <= e && e <= 43456)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43573) {
            if (e < 43567) {
              if (e < 43561) {
                if (e === 43493)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (43561 <= e && e <= 43566)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43569) {
              if (43567 <= e && e <= 43568)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43571) {
              if (43569 <= e && e <= 43570)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43571 <= e && e <= 43572)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43597) {
            if (e < 43587) {
              if (43573 <= e && e <= 43574)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 43587 || e === 43596)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43644) {
            if (e === 43597)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 43644 || e === 43696)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 44006) {
          if (e < 43756)
            if (e < 43710) {
              if (e < 43703) {
                if (43698 <= e && e <= 43700)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (43703 <= e && e <= 43704)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43713) {
              if (43710 <= e && e <= 43711)
                return i.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 43713)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 43755)
                return i.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 43766) {
            if (e < 43758) {
              if (43756 <= e && e <= 43757)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43765) {
              if (43758 <= e && e <= 43759)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 43765)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 44003) {
            if (e === 43766)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 44005) {
            if (44003 <= e && e <= 44004)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 44005)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 44032)
          if (e < 44009) {
            if (e < 44008) {
              if (44006 <= e && e <= 44007)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 44008)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 44012) {
            if (44009 <= e && e <= 44010)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else {
            if (e === 44012)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 44013)
              return i.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 44061) {
          if (e < 44033) {
            if (e === 44032)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 44060) {
            if (44033 <= e && e <= 44059)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 44060)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 44088) {
          if (44061 <= e && e <= 44087)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 44089) {
          if (e === 44088)
            return i.CLUSTER_BREAK.LV;
        } else if (44089 <= e && e <= 44115)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 46497) {
        if (e < 45293) {
          if (e < 44704) {
            if (e < 44397) {
              if (e < 44256) {
                if (e < 44173) {
                  if (e < 44144) {
                    if (e < 44117) {
                      if (e === 44116)
                        return i.CLUSTER_BREAK.LV;
                    } else if (44117 <= e && e <= 44143)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e < 44145) {
                    if (e === 44144)
                      return i.CLUSTER_BREAK.LV;
                  } else if (e < 44172) {
                    if (44145 <= e && e <= 44171)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 44172)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44201) {
                  if (e < 44200) {
                    if (44173 <= e && e <= 44199)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 44200)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44228) {
                  if (44201 <= e && e <= 44227)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44229) {
                  if (e === 44228)
                    return i.CLUSTER_BREAK.LV;
                } else if (44229 <= e && e <= 44255)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44313) {
                if (e < 44284) {
                  if (e < 44257) {
                    if (e === 44256)
                      return i.CLUSTER_BREAK.LV;
                  } else if (44257 <= e && e <= 44283)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44285) {
                  if (e === 44284)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44312) {
                  if (44285 <= e && e <= 44311)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44312)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44368) {
                if (e < 44340) {
                  if (44313 <= e && e <= 44339)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44341) {
                  if (e === 44340)
                    return i.CLUSTER_BREAK.LV;
                } else if (44341 <= e && e <= 44367)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44369) {
                if (e === 44368)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44396) {
                if (44369 <= e && e <= 44395)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44396)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44537) {
              if (e < 44480) {
                if (e < 44425) {
                  if (e < 44424) {
                    if (44397 <= e && e <= 44423)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 44424)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44452) {
                  if (44425 <= e && e <= 44451)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44453) {
                  if (e === 44452)
                    return i.CLUSTER_BREAK.LV;
                } else if (44453 <= e && e <= 44479)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44508) {
                if (e < 44481) {
                  if (e === 44480)
                    return i.CLUSTER_BREAK.LV;
                } else if (44481 <= e && e <= 44507)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44509) {
                if (e === 44508)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44536) {
                if (44509 <= e && e <= 44535)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44536)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44620) {
              if (e < 44565) {
                if (e < 44564) {
                  if (44537 <= e && e <= 44563)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44564)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44592) {
                if (44565 <= e && e <= 44591)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44593) {
                if (e === 44592)
                  return i.CLUSTER_BREAK.LV;
              } else if (44593 <= e && e <= 44619)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44649) {
              if (e < 44621) {
                if (e === 44620)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44648) {
                if (44621 <= e && e <= 44647)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44648)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44676) {
              if (44649 <= e && e <= 44675)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44677) {
              if (e === 44676)
                return i.CLUSTER_BREAK.LV;
            } else if (44677 <= e && e <= 44703)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 44985) {
            if (e < 44844) {
              if (e < 44761) {
                if (e < 44732) {
                  if (e < 44705) {
                    if (e === 44704)
                      return i.CLUSTER_BREAK.LV;
                  } else if (44705 <= e && e <= 44731)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44733) {
                  if (e === 44732)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44760) {
                  if (44733 <= e && e <= 44759)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44760)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44789) {
                if (e < 44788) {
                  if (44761 <= e && e <= 44787)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44788)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44816) {
                if (44789 <= e && e <= 44815)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44817) {
                if (e === 44816)
                  return i.CLUSTER_BREAK.LV;
              } else if (44817 <= e && e <= 44843)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44901) {
              if (e < 44872) {
                if (e < 44845) {
                  if (e === 44844)
                    return i.CLUSTER_BREAK.LV;
                } else if (44845 <= e && e <= 44871)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44873) {
                if (e === 44872)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44900) {
                if (44873 <= e && e <= 44899)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44900)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44956) {
              if (e < 44928) {
                if (44901 <= e && e <= 44927)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44929) {
                if (e === 44928)
                  return i.CLUSTER_BREAK.LV;
              } else if (44929 <= e && e <= 44955)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44957) {
              if (e === 44956)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44984) {
              if (44957 <= e && e <= 44983)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 44984)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45152) {
            if (e < 45068) {
              if (e < 45013) {
                if (e < 45012) {
                  if (44985 <= e && e <= 45011)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 45012)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45040) {
                if (45013 <= e && e <= 45039)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45041) {
                if (e === 45040)
                  return i.CLUSTER_BREAK.LV;
              } else if (45041 <= e && e <= 45067)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45097) {
              if (e < 45069) {
                if (e === 45068)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45096) {
                if (45069 <= e && e <= 45095)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45096)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45124) {
              if (45097 <= e && e <= 45123)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45125) {
              if (e === 45124)
                return i.CLUSTER_BREAK.LV;
            } else if (45125 <= e && e <= 45151)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45209) {
            if (e < 45180) {
              if (e < 45153) {
                if (e === 45152)
                  return i.CLUSTER_BREAK.LV;
              } else if (45153 <= e && e <= 45179)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45181) {
              if (e === 45180)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45208) {
              if (45181 <= e && e <= 45207)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 45208)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45264) {
            if (e < 45236) {
              if (45209 <= e && e <= 45235)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45237) {
              if (e === 45236)
                return i.CLUSTER_BREAK.LV;
            } else if (45237 <= e && e <= 45263)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45265) {
            if (e === 45264)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45292) {
            if (45265 <= e && e <= 45291)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 45292)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 45908) {
          if (e < 45600) {
            if (e < 45433) {
              if (e < 45376) {
                if (e < 45321) {
                  if (e < 45320) {
                    if (45293 <= e && e <= 45319)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 45320)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 45348) {
                  if (45321 <= e && e <= 45347)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 45349) {
                  if (e === 45348)
                    return i.CLUSTER_BREAK.LV;
                } else if (45349 <= e && e <= 45375)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45404) {
                if (e < 45377) {
                  if (e === 45376)
                    return i.CLUSTER_BREAK.LV;
                } else if (45377 <= e && e <= 45403)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45405) {
                if (e === 45404)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45432) {
                if (45405 <= e && e <= 45431)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45432)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45516) {
              if (e < 45461) {
                if (e < 45460) {
                  if (45433 <= e && e <= 45459)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 45460)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45488) {
                if (45461 <= e && e <= 45487)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45489) {
                if (e === 45488)
                  return i.CLUSTER_BREAK.LV;
              } else if (45489 <= e && e <= 45515)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45545) {
              if (e < 45517) {
                if (e === 45516)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45544) {
                if (45517 <= e && e <= 45543)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45544)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45572) {
              if (45545 <= e && e <= 45571)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45573) {
              if (e === 45572)
                return i.CLUSTER_BREAK.LV;
            } else if (45573 <= e && e <= 45599)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45741) {
            if (e < 45657) {
              if (e < 45628) {
                if (e < 45601) {
                  if (e === 45600)
                    return i.CLUSTER_BREAK.LV;
                } else if (45601 <= e && e <= 45627)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45629) {
                if (e === 45628)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45656) {
                if (45629 <= e && e <= 45655)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45656)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45712) {
              if (e < 45684) {
                if (45657 <= e && e <= 45683)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45685) {
                if (e === 45684)
                  return i.CLUSTER_BREAK.LV;
              } else if (45685 <= e && e <= 45711)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45713) {
              if (e === 45712)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45740) {
              if (45713 <= e && e <= 45739)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 45740)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45824) {
            if (e < 45769) {
              if (e < 45768) {
                if (45741 <= e && e <= 45767)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45768)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45796) {
              if (45769 <= e && e <= 45795)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45797) {
              if (e === 45796)
                return i.CLUSTER_BREAK.LV;
            } else if (45797 <= e && e <= 45823)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45853) {
            if (e < 45825) {
              if (e === 45824)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45852) {
              if (45825 <= e && e <= 45851)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 45852)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45880) {
            if (45853 <= e && e <= 45879)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45881) {
            if (e === 45880)
              return i.CLUSTER_BREAK.LV;
          } else if (45881 <= e && e <= 45907)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 46189) {
          if (e < 46048) {
            if (e < 45965) {
              if (e < 45936) {
                if (e < 45909) {
                  if (e === 45908)
                    return i.CLUSTER_BREAK.LV;
                } else if (45909 <= e && e <= 45935)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45937) {
                if (e === 45936)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45964) {
                if (45937 <= e && e <= 45963)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45964)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45993) {
              if (e < 45992) {
                if (45965 <= e && e <= 45991)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45992)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46020) {
              if (45993 <= e && e <= 46019)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46021) {
              if (e === 46020)
                return i.CLUSTER_BREAK.LV;
            } else if (46021 <= e && e <= 46047)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46105) {
            if (e < 46076) {
              if (e < 46049) {
                if (e === 46048)
                  return i.CLUSTER_BREAK.LV;
              } else if (46049 <= e && e <= 46075)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46077) {
              if (e === 46076)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46104) {
              if (46077 <= e && e <= 46103)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 46104)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46160) {
            if (e < 46132) {
              if (46105 <= e && e <= 46131)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46133) {
              if (e === 46132)
                return i.CLUSTER_BREAK.LV;
            } else if (46133 <= e && e <= 46159)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46161) {
            if (e === 46160)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46188) {
            if (46161 <= e && e <= 46187)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 46188)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 46356) {
          if (e < 46272) {
            if (e < 46217) {
              if (e < 46216) {
                if (46189 <= e && e <= 46215)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46216)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46244) {
              if (46217 <= e && e <= 46243)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46245) {
              if (e === 46244)
                return i.CLUSTER_BREAK.LV;
            } else if (46245 <= e && e <= 46271)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46301) {
            if (e < 46273) {
              if (e === 46272)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46300) {
              if (46273 <= e && e <= 46299)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 46300)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46328) {
            if (46301 <= e && e <= 46327)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46329) {
            if (e === 46328)
              return i.CLUSTER_BREAK.LV;
          } else if (46329 <= e && e <= 46355)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 46413) {
          if (e < 46384) {
            if (e < 46357) {
              if (e === 46356)
                return i.CLUSTER_BREAK.LV;
            } else if (46357 <= e && e <= 46383)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46385) {
            if (e === 46384)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46412) {
            if (46385 <= e && e <= 46411)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 46412)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 46468) {
          if (e < 46440) {
            if (46413 <= e && e <= 46439)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46441) {
            if (e === 46440)
              return i.CLUSTER_BREAK.LV;
          } else if (46441 <= e && e <= 46467)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 46469) {
          if (e === 46468)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 46496) {
          if (46469 <= e && e <= 46495)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 46496)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 47701) {
        if (e < 47112) {
          if (e < 46804) {
            if (e < 46637) {
              if (e < 46580) {
                if (e < 46525) {
                  if (e < 46524) {
                    if (46497 <= e && e <= 46523)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 46524)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 46552) {
                  if (46525 <= e && e <= 46551)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 46553) {
                  if (e === 46552)
                    return i.CLUSTER_BREAK.LV;
                } else if (46553 <= e && e <= 46579)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46608) {
                if (e < 46581) {
                  if (e === 46580)
                    return i.CLUSTER_BREAK.LV;
                } else if (46581 <= e && e <= 46607)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46609) {
                if (e === 46608)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46636) {
                if (46609 <= e && e <= 46635)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46636)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46720) {
              if (e < 46665) {
                if (e < 46664) {
                  if (46637 <= e && e <= 46663)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 46664)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46692) {
                if (46665 <= e && e <= 46691)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46693) {
                if (e === 46692)
                  return i.CLUSTER_BREAK.LV;
              } else if (46693 <= e && e <= 46719)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46749) {
              if (e < 46721) {
                if (e === 46720)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46748) {
                if (46721 <= e && e <= 46747)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46748)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46776) {
              if (46749 <= e && e <= 46775)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46777) {
              if (e === 46776)
                return i.CLUSTER_BREAK.LV;
            } else if (46777 <= e && e <= 46803)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46945) {
            if (e < 46861) {
              if (e < 46832) {
                if (e < 46805) {
                  if (e === 46804)
                    return i.CLUSTER_BREAK.LV;
                } else if (46805 <= e && e <= 46831)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46833) {
                if (e === 46832)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46860) {
                if (46833 <= e && e <= 46859)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46860)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46916) {
              if (e < 46888) {
                if (46861 <= e && e <= 46887)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46889) {
                if (e === 46888)
                  return i.CLUSTER_BREAK.LV;
              } else if (46889 <= e && e <= 46915)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46917) {
              if (e === 46916)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46944) {
              if (46917 <= e && e <= 46943)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 46944)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47028) {
            if (e < 46973) {
              if (e < 46972) {
                if (46945 <= e && e <= 46971)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46972)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47e3) {
              if (46973 <= e && e <= 46999)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47001) {
              if (e === 47e3)
                return i.CLUSTER_BREAK.LV;
            } else if (47001 <= e && e <= 47027)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47057) {
            if (e < 47029) {
              if (e === 47028)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47056) {
              if (47029 <= e && e <= 47055)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47056)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47084) {
            if (47057 <= e && e <= 47083)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47085) {
            if (e === 47084)
              return i.CLUSTER_BREAK.LV;
          } else if (47085 <= e && e <= 47111)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 47393) {
          if (e < 47252) {
            if (e < 47169) {
              if (e < 47140) {
                if (e < 47113) {
                  if (e === 47112)
                    return i.CLUSTER_BREAK.LV;
                } else if (47113 <= e && e <= 47139)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 47141) {
                if (e === 47140)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 47168) {
                if (47141 <= e && e <= 47167)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47168)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47197) {
              if (e < 47196) {
                if (47169 <= e && e <= 47195)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47196)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47224) {
              if (47197 <= e && e <= 47223)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47225) {
              if (e === 47224)
                return i.CLUSTER_BREAK.LV;
            } else if (47225 <= e && e <= 47251)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47309) {
            if (e < 47280) {
              if (e < 47253) {
                if (e === 47252)
                  return i.CLUSTER_BREAK.LV;
              } else if (47253 <= e && e <= 47279)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47281) {
              if (e === 47280)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47308) {
              if (47281 <= e && e <= 47307)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47308)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47364) {
            if (e < 47336) {
              if (47309 <= e && e <= 47335)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47337) {
              if (e === 47336)
                return i.CLUSTER_BREAK.LV;
            } else if (47337 <= e && e <= 47363)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47365) {
            if (e === 47364)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47392) {
            if (47365 <= e && e <= 47391)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 47392)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 47560) {
          if (e < 47476) {
            if (e < 47421) {
              if (e < 47420) {
                if (47393 <= e && e <= 47419)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47420)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47448) {
              if (47421 <= e && e <= 47447)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47449) {
              if (e === 47448)
                return i.CLUSTER_BREAK.LV;
            } else if (47449 <= e && e <= 47475)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47505) {
            if (e < 47477) {
              if (e === 47476)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47504) {
              if (47477 <= e && e <= 47503)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47504)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47532) {
            if (47505 <= e && e <= 47531)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47533) {
            if (e === 47532)
              return i.CLUSTER_BREAK.LV;
          } else if (47533 <= e && e <= 47559)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 47617) {
          if (e < 47588) {
            if (e < 47561) {
              if (e === 47560)
                return i.CLUSTER_BREAK.LV;
            } else if (47561 <= e && e <= 47587)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47589) {
            if (e === 47588)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47616) {
            if (47589 <= e && e <= 47615)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 47616)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 47672) {
          if (e < 47644) {
            if (47617 <= e && e <= 47643)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47645) {
            if (e === 47644)
              return i.CLUSTER_BREAK.LV;
          } else if (47645 <= e && e <= 47671)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 47673) {
          if (e === 47672)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 47700) {
          if (47673 <= e && e <= 47699)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 47700)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48316) {
        if (e < 48008) {
          if (e < 47841) {
            if (e < 47784) {
              if (e < 47729) {
                if (e < 47728) {
                  if (47701 <= e && e <= 47727)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 47728)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 47756) {
                if (47729 <= e && e <= 47755)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 47757) {
                if (e === 47756)
                  return i.CLUSTER_BREAK.LV;
              } else if (47757 <= e && e <= 47783)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47812) {
              if (e < 47785) {
                if (e === 47784)
                  return i.CLUSTER_BREAK.LV;
              } else if (47785 <= e && e <= 47811)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47813) {
              if (e === 47812)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47840) {
              if (47813 <= e && e <= 47839)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47840)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47924) {
            if (e < 47869) {
              if (e < 47868) {
                if (47841 <= e && e <= 47867)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47868)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47896) {
              if (47869 <= e && e <= 47895)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47897) {
              if (e === 47896)
                return i.CLUSTER_BREAK.LV;
            } else if (47897 <= e && e <= 47923)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47953) {
            if (e < 47925) {
              if (e === 47924)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47952) {
              if (47925 <= e && e <= 47951)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47952)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47980) {
            if (47953 <= e && e <= 47979)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47981) {
            if (e === 47980)
              return i.CLUSTER_BREAK.LV;
          } else if (47981 <= e && e <= 48007)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48149) {
          if (e < 48065) {
            if (e < 48036) {
              if (e < 48009) {
                if (e === 48008)
                  return i.CLUSTER_BREAK.LV;
              } else if (48009 <= e && e <= 48035)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 48037) {
              if (e === 48036)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 48064) {
              if (48037 <= e && e <= 48063)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48064)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48120) {
            if (e < 48092) {
              if (48065 <= e && e <= 48091)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 48093) {
              if (e === 48092)
                return i.CLUSTER_BREAK.LV;
            } else if (48093 <= e && e <= 48119)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48121) {
            if (e === 48120)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48148) {
            if (48121 <= e && e <= 48147)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48148)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48232) {
          if (e < 48177) {
            if (e < 48176) {
              if (48149 <= e && e <= 48175)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48176)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48204) {
            if (48177 <= e && e <= 48203)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48205) {
            if (e === 48204)
              return i.CLUSTER_BREAK.LV;
          } else if (48205 <= e && e <= 48231)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48261) {
          if (e < 48233) {
            if (e === 48232)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48260) {
            if (48233 <= e && e <= 48259)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48260)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48288) {
          if (48261 <= e && e <= 48287)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48289) {
          if (e === 48288)
            return i.CLUSTER_BREAK.LV;
        } else if (48289 <= e && e <= 48315)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 48597) {
        if (e < 48456) {
          if (e < 48373) {
            if (e < 48344) {
              if (e < 48317) {
                if (e === 48316)
                  return i.CLUSTER_BREAK.LV;
              } else if (48317 <= e && e <= 48343)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 48345) {
              if (e === 48344)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 48372) {
              if (48345 <= e && e <= 48371)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48372)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48401) {
            if (e < 48400) {
              if (48373 <= e && e <= 48399)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48400)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48428) {
            if (48401 <= e && e <= 48427)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48429) {
            if (e === 48428)
              return i.CLUSTER_BREAK.LV;
          } else if (48429 <= e && e <= 48455)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48513) {
          if (e < 48484) {
            if (e < 48457) {
              if (e === 48456)
                return i.CLUSTER_BREAK.LV;
            } else if (48457 <= e && e <= 48483)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48485) {
            if (e === 48484)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48512) {
            if (48485 <= e && e <= 48511)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48512)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48568) {
          if (e < 48540) {
            if (48513 <= e && e <= 48539)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48541) {
            if (e === 48540)
              return i.CLUSTER_BREAK.LV;
          } else if (48541 <= e && e <= 48567)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48569) {
          if (e === 48568)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48596) {
          if (48569 <= e && e <= 48595)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 48596)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48764) {
        if (e < 48680) {
          if (e < 48625) {
            if (e < 48624) {
              if (48597 <= e && e <= 48623)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48624)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48652) {
            if (48625 <= e && e <= 48651)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48653) {
            if (e === 48652)
              return i.CLUSTER_BREAK.LV;
          } else if (48653 <= e && e <= 48679)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48709) {
          if (e < 48681) {
            if (e === 48680)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48708) {
            if (48681 <= e && e <= 48707)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48708)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48736) {
          if (48709 <= e && e <= 48735)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48737) {
          if (e === 48736)
            return i.CLUSTER_BREAK.LV;
        } else if (48737 <= e && e <= 48763)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 48821) {
        if (e < 48792) {
          if (e < 48765) {
            if (e === 48764)
              return i.CLUSTER_BREAK.LV;
          } else if (48765 <= e && e <= 48791)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48793) {
          if (e === 48792)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48820) {
          if (48793 <= e && e <= 48819)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 48820)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48876) {
        if (e < 48848) {
          if (48821 <= e && e <= 48847)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48849) {
          if (e === 48848)
            return i.CLUSTER_BREAK.LV;
        } else if (48849 <= e && e <= 48875)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 48877) {
        if (e === 48876)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48904) {
        if (48877 <= e && e <= 48903)
          return i.CLUSTER_BREAK.LVT;
      } else if (e === 48904)
        return i.CLUSTER_BREAK.LV;
    } else if (e < 53720) {
      if (e < 51312) {
        if (e < 50108) {
          if (e < 49493) {
            if (e < 49212) {
              if (e < 49045) {
                if (e < 48988) {
                  if (e < 48933) {
                    if (e < 48932) {
                      if (48905 <= e && e <= 48931)
                        return i.CLUSTER_BREAK.LVT;
                    } else if (e === 48932)
                      return i.CLUSTER_BREAK.LV;
                  } else if (e < 48960) {
                    if (48933 <= e && e <= 48959)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e < 48961) {
                    if (e === 48960)
                      return i.CLUSTER_BREAK.LV;
                  } else if (48961 <= e && e <= 48987)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49016) {
                  if (e < 48989) {
                    if (e === 48988)
                      return i.CLUSTER_BREAK.LV;
                  } else if (48989 <= e && e <= 49015)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49017) {
                  if (e === 49016)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49044) {
                  if (49017 <= e && e <= 49043)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49044)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49128) {
                if (e < 49073) {
                  if (e < 49072) {
                    if (49045 <= e && e <= 49071)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 49072)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49100) {
                  if (49073 <= e && e <= 49099)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49101) {
                  if (e === 49100)
                    return i.CLUSTER_BREAK.LV;
                } else if (49101 <= e && e <= 49127)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49157) {
                if (e < 49129) {
                  if (e === 49128)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49156) {
                  if (49129 <= e && e <= 49155)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49156)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49184) {
                if (49157 <= e && e <= 49183)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49185) {
                if (e === 49184)
                  return i.CLUSTER_BREAK.LV;
              } else if (49185 <= e && e <= 49211)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49352) {
              if (e < 49269) {
                if (e < 49240) {
                  if (e < 49213) {
                    if (e === 49212)
                      return i.CLUSTER_BREAK.LV;
                  } else if (49213 <= e && e <= 49239)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49241) {
                  if (e === 49240)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49268) {
                  if (49241 <= e && e <= 49267)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49268)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49297) {
                if (e < 49296) {
                  if (49269 <= e && e <= 49295)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49296)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49324) {
                if (49297 <= e && e <= 49323)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49325) {
                if (e === 49324)
                  return i.CLUSTER_BREAK.LV;
              } else if (49325 <= e && e <= 49351)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49409) {
              if (e < 49380) {
                if (e < 49353) {
                  if (e === 49352)
                    return i.CLUSTER_BREAK.LV;
                } else if (49353 <= e && e <= 49379)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49381) {
                if (e === 49380)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49408) {
                if (49381 <= e && e <= 49407)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49408)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49464) {
              if (e < 49436) {
                if (49409 <= e && e <= 49435)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49437) {
                if (e === 49436)
                  return i.CLUSTER_BREAK.LV;
              } else if (49437 <= e && e <= 49463)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49465) {
              if (e === 49464)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49492) {
              if (49465 <= e && e <= 49491)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 49492)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 49800) {
            if (e < 49633) {
              if (e < 49576) {
                if (e < 49521) {
                  if (e < 49520) {
                    if (49493 <= e && e <= 49519)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 49520)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49548) {
                  if (49521 <= e && e <= 49547)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49549) {
                  if (e === 49548)
                    return i.CLUSTER_BREAK.LV;
                } else if (49549 <= e && e <= 49575)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49604) {
                if (e < 49577) {
                  if (e === 49576)
                    return i.CLUSTER_BREAK.LV;
                } else if (49577 <= e && e <= 49603)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49605) {
                if (e === 49604)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49632) {
                if (49605 <= e && e <= 49631)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49632)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49716) {
              if (e < 49661) {
                if (e < 49660) {
                  if (49633 <= e && e <= 49659)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49660)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49688) {
                if (49661 <= e && e <= 49687)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49689) {
                if (e === 49688)
                  return i.CLUSTER_BREAK.LV;
              } else if (49689 <= e && e <= 49715)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49745) {
              if (e < 49717) {
                if (e === 49716)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49744) {
                if (49717 <= e && e <= 49743)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49744)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49772) {
              if (49745 <= e && e <= 49771)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49773) {
              if (e === 49772)
                return i.CLUSTER_BREAK.LV;
            } else if (49773 <= e && e <= 49799)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 49941) {
            if (e < 49857) {
              if (e < 49828) {
                if (e < 49801) {
                  if (e === 49800)
                    return i.CLUSTER_BREAK.LV;
                } else if (49801 <= e && e <= 49827)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49829) {
                if (e === 49828)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49856) {
                if (49829 <= e && e <= 49855)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49856)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49912) {
              if (e < 49884) {
                if (49857 <= e && e <= 49883)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49885) {
                if (e === 49884)
                  return i.CLUSTER_BREAK.LV;
              } else if (49885 <= e && e <= 49911)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49913) {
              if (e === 49912)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49940) {
              if (49913 <= e && e <= 49939)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 49940)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50024) {
            if (e < 49969) {
              if (e < 49968) {
                if (49941 <= e && e <= 49967)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49968)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49996) {
              if (49969 <= e && e <= 49995)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49997) {
              if (e === 49996)
                return i.CLUSTER_BREAK.LV;
            } else if (49997 <= e && e <= 50023)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50053) {
            if (e < 50025) {
              if (e === 50024)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50052) {
              if (50025 <= e && e <= 50051)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50052)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50080) {
            if (50053 <= e && e <= 50079)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50081) {
            if (e === 50080)
              return i.CLUSTER_BREAK.LV;
          } else if (50081 <= e && e <= 50107)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 50697) {
          if (e < 50389) {
            if (e < 50248) {
              if (e < 50165) {
                if (e < 50136) {
                  if (e < 50109) {
                    if (e === 50108)
                      return i.CLUSTER_BREAK.LV;
                  } else if (50109 <= e && e <= 50135)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 50137) {
                  if (e === 50136)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 50164) {
                  if (50137 <= e && e <= 50163)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50164)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50193) {
                if (e < 50192) {
                  if (50165 <= e && e <= 50191)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50192)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50220) {
                if (50193 <= e && e <= 50219)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50221) {
                if (e === 50220)
                  return i.CLUSTER_BREAK.LV;
              } else if (50221 <= e && e <= 50247)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50305) {
              if (e < 50276) {
                if (e < 50249) {
                  if (e === 50248)
                    return i.CLUSTER_BREAK.LV;
                } else if (50249 <= e && e <= 50275)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50277) {
                if (e === 50276)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50304) {
                if (50277 <= e && e <= 50303)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 50304)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50360) {
              if (e < 50332) {
                if (50305 <= e && e <= 50331)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50333) {
                if (e === 50332)
                  return i.CLUSTER_BREAK.LV;
              } else if (50333 <= e && e <= 50359)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50361) {
              if (e === 50360)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50388) {
              if (50361 <= e && e <= 50387)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50388)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50556) {
            if (e < 50472) {
              if (e < 50417) {
                if (e < 50416) {
                  if (50389 <= e && e <= 50415)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50416)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50444) {
                if (50417 <= e && e <= 50443)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50445) {
                if (e === 50444)
                  return i.CLUSTER_BREAK.LV;
              } else if (50445 <= e && e <= 50471)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50501) {
              if (e < 50473) {
                if (e === 50472)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50500) {
                if (50473 <= e && e <= 50499)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 50500)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50528) {
              if (50501 <= e && e <= 50527)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50529) {
              if (e === 50528)
                return i.CLUSTER_BREAK.LV;
            } else if (50529 <= e && e <= 50555)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50613) {
            if (e < 50584) {
              if (e < 50557) {
                if (e === 50556)
                  return i.CLUSTER_BREAK.LV;
              } else if (50557 <= e && e <= 50583)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50585) {
              if (e === 50584)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50612) {
              if (50585 <= e && e <= 50611)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50612)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50668) {
            if (e < 50640) {
              if (50613 <= e && e <= 50639)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50641) {
              if (e === 50640)
                return i.CLUSTER_BREAK.LV;
            } else if (50641 <= e && e <= 50667)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50669) {
            if (e === 50668)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50696) {
            if (50669 <= e && e <= 50695)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 50696)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 51004) {
          if (e < 50837) {
            if (e < 50780) {
              if (e < 50725) {
                if (e < 50724) {
                  if (50697 <= e && e <= 50723)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50724)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50752) {
                if (50725 <= e && e <= 50751)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50753) {
                if (e === 50752)
                  return i.CLUSTER_BREAK.LV;
              } else if (50753 <= e && e <= 50779)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50808) {
              if (e < 50781) {
                if (e === 50780)
                  return i.CLUSTER_BREAK.LV;
              } else if (50781 <= e && e <= 50807)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50809) {
              if (e === 50808)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50836) {
              if (50809 <= e && e <= 50835)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50836)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50920) {
            if (e < 50865) {
              if (e < 50864) {
                if (50837 <= e && e <= 50863)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 50864)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50892) {
              if (50865 <= e && e <= 50891)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50893) {
              if (e === 50892)
                return i.CLUSTER_BREAK.LV;
            } else if (50893 <= e && e <= 50919)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50949) {
            if (e < 50921) {
              if (e === 50920)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50948) {
              if (50921 <= e && e <= 50947)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50948)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50976) {
            if (50949 <= e && e <= 50975)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50977) {
            if (e === 50976)
              return i.CLUSTER_BREAK.LV;
          } else if (50977 <= e && e <= 51003)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 51145) {
          if (e < 51061) {
            if (e < 51032) {
              if (e < 51005) {
                if (e === 51004)
                  return i.CLUSTER_BREAK.LV;
              } else if (51005 <= e && e <= 51031)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51033) {
              if (e === 51032)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51060) {
              if (51033 <= e && e <= 51059)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51060)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51116) {
            if (e < 51088) {
              if (51061 <= e && e <= 51087)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51089) {
              if (e === 51088)
                return i.CLUSTER_BREAK.LV;
            } else if (51089 <= e && e <= 51115)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51117) {
            if (e === 51116)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51144) {
            if (51117 <= e && e <= 51143)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 51144)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 51228) {
          if (e < 51173) {
            if (e < 51172) {
              if (51145 <= e && e <= 51171)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51172)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51200) {
            if (51173 <= e && e <= 51199)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51201) {
            if (e === 51200)
              return i.CLUSTER_BREAK.LV;
          } else if (51201 <= e && e <= 51227)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 51257) {
          if (e < 51229) {
            if (e === 51228)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51256) {
            if (51229 <= e && e <= 51255)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 51256)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 51284) {
          if (51257 <= e && e <= 51283)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 51285) {
          if (e === 51284)
            return i.CLUSTER_BREAK.LV;
        } else if (51285 <= e && e <= 51311)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 52516) {
        if (e < 51901) {
          if (e < 51593) {
            if (e < 51452) {
              if (e < 51369) {
                if (e < 51340) {
                  if (e < 51313) {
                    if (e === 51312)
                      return i.CLUSTER_BREAK.LV;
                  } else if (51313 <= e && e <= 51339)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 51341) {
                  if (e === 51340)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 51368) {
                  if (51341 <= e && e <= 51367)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51368)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51397) {
                if (e < 51396) {
                  if (51369 <= e && e <= 51395)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51396)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51424) {
                if (51397 <= e && e <= 51423)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51425) {
                if (e === 51424)
                  return i.CLUSTER_BREAK.LV;
              } else if (51425 <= e && e <= 51451)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51509) {
              if (e < 51480) {
                if (e < 51453) {
                  if (e === 51452)
                    return i.CLUSTER_BREAK.LV;
                } else if (51453 <= e && e <= 51479)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51481) {
                if (e === 51480)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51508) {
                if (51481 <= e && e <= 51507)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 51508)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51564) {
              if (e < 51536) {
                if (51509 <= e && e <= 51535)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51537) {
                if (e === 51536)
                  return i.CLUSTER_BREAK.LV;
              } else if (51537 <= e && e <= 51563)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51565) {
              if (e === 51564)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51592) {
              if (51565 <= e && e <= 51591)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51592)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51760) {
            if (e < 51676) {
              if (e < 51621) {
                if (e < 51620) {
                  if (51593 <= e && e <= 51619)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51620)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51648) {
                if (51621 <= e && e <= 51647)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51649) {
                if (e === 51648)
                  return i.CLUSTER_BREAK.LV;
              } else if (51649 <= e && e <= 51675)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51705) {
              if (e < 51677) {
                if (e === 51676)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51704) {
                if (51677 <= e && e <= 51703)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 51704)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51732) {
              if (51705 <= e && e <= 51731)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51733) {
              if (e === 51732)
                return i.CLUSTER_BREAK.LV;
            } else if (51733 <= e && e <= 51759)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51817) {
            if (e < 51788) {
              if (e < 51761) {
                if (e === 51760)
                  return i.CLUSTER_BREAK.LV;
              } else if (51761 <= e && e <= 51787)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51789) {
              if (e === 51788)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51816) {
              if (51789 <= e && e <= 51815)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51816)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51872) {
            if (e < 51844) {
              if (51817 <= e && e <= 51843)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51845) {
              if (e === 51844)
                return i.CLUSTER_BREAK.LV;
            } else if (51845 <= e && e <= 51871)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51873) {
            if (e === 51872)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51900) {
            if (51873 <= e && e <= 51899)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 51900)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52208) {
          if (e < 52041) {
            if (e < 51984) {
              if (e < 51929) {
                if (e < 51928) {
                  if (51901 <= e && e <= 51927)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51928)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51956) {
                if (51929 <= e && e <= 51955)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51957) {
                if (e === 51956)
                  return i.CLUSTER_BREAK.LV;
              } else if (51957 <= e && e <= 51983)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52012) {
              if (e < 51985) {
                if (e === 51984)
                  return i.CLUSTER_BREAK.LV;
              } else if (51985 <= e && e <= 52011)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52013) {
              if (e === 52012)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52040) {
              if (52013 <= e && e <= 52039)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52040)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52124) {
            if (e < 52069) {
              if (e < 52068) {
                if (52041 <= e && e <= 52067)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52068)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52096) {
              if (52069 <= e && e <= 52095)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52097) {
              if (e === 52096)
                return i.CLUSTER_BREAK.LV;
            } else if (52097 <= e && e <= 52123)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52153) {
            if (e < 52125) {
              if (e === 52124)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52152) {
              if (52125 <= e && e <= 52151)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52152)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52180) {
            if (52153 <= e && e <= 52179)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52181) {
            if (e === 52180)
              return i.CLUSTER_BREAK.LV;
          } else if (52181 <= e && e <= 52207)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 52349) {
          if (e < 52265) {
            if (e < 52236) {
              if (e < 52209) {
                if (e === 52208)
                  return i.CLUSTER_BREAK.LV;
              } else if (52209 <= e && e <= 52235)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52237) {
              if (e === 52236)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52264) {
              if (52237 <= e && e <= 52263)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52264)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52320) {
            if (e < 52292) {
              if (52265 <= e && e <= 52291)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52293) {
              if (e === 52292)
                return i.CLUSTER_BREAK.LV;
            } else if (52293 <= e && e <= 52319)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52321) {
            if (e === 52320)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52348) {
            if (52321 <= e && e <= 52347)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 52348)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52432) {
          if (e < 52377) {
            if (e < 52376) {
              if (52349 <= e && e <= 52375)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52376)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52404) {
            if (52377 <= e && e <= 52403)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52405) {
            if (e === 52404)
              return i.CLUSTER_BREAK.LV;
          } else if (52405 <= e && e <= 52431)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 52461) {
          if (e < 52433) {
            if (e === 52432)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52460) {
            if (52433 <= e && e <= 52459)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 52460)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52488) {
          if (52461 <= e && e <= 52487)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 52489) {
          if (e === 52488)
            return i.CLUSTER_BREAK.LV;
        } else if (52489 <= e && e <= 52515)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53105) {
        if (e < 52797) {
          if (e < 52656) {
            if (e < 52573) {
              if (e < 52544) {
                if (e < 52517) {
                  if (e === 52516)
                    return i.CLUSTER_BREAK.LV;
                } else if (52517 <= e && e <= 52543)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 52545) {
                if (e === 52544)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 52572) {
                if (52545 <= e && e <= 52571)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52572)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52601) {
              if (e < 52600) {
                if (52573 <= e && e <= 52599)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52600)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52628) {
              if (52601 <= e && e <= 52627)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52629) {
              if (e === 52628)
                return i.CLUSTER_BREAK.LV;
            } else if (52629 <= e && e <= 52655)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52713) {
            if (e < 52684) {
              if (e < 52657) {
                if (e === 52656)
                  return i.CLUSTER_BREAK.LV;
              } else if (52657 <= e && e <= 52683)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52685) {
              if (e === 52684)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52712) {
              if (52685 <= e && e <= 52711)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52712)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52768) {
            if (e < 52740) {
              if (52713 <= e && e <= 52739)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52741) {
              if (e === 52740)
                return i.CLUSTER_BREAK.LV;
            } else if (52741 <= e && e <= 52767)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52769) {
            if (e === 52768)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52796) {
            if (52769 <= e && e <= 52795)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 52796)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52964) {
          if (e < 52880) {
            if (e < 52825) {
              if (e < 52824) {
                if (52797 <= e && e <= 52823)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52824)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52852) {
              if (52825 <= e && e <= 52851)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52853) {
              if (e === 52852)
                return i.CLUSTER_BREAK.LV;
            } else if (52853 <= e && e <= 52879)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52909) {
            if (e < 52881) {
              if (e === 52880)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52908) {
              if (52881 <= e && e <= 52907)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52908)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52936) {
            if (52909 <= e && e <= 52935)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52937) {
            if (e === 52936)
              return i.CLUSTER_BREAK.LV;
          } else if (52937 <= e && e <= 52963)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53021) {
          if (e < 52992) {
            if (e < 52965) {
              if (e === 52964)
                return i.CLUSTER_BREAK.LV;
            } else if (52965 <= e && e <= 52991)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52993) {
            if (e === 52992)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53020) {
            if (52993 <= e && e <= 53019)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53020)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53076) {
          if (e < 53048) {
            if (53021 <= e && e <= 53047)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53049) {
            if (e === 53048)
              return i.CLUSTER_BREAK.LV;
          } else if (53049 <= e && e <= 53075)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53077) {
          if (e === 53076)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53104) {
          if (53077 <= e && e <= 53103)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 53104)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 53412) {
        if (e < 53245) {
          if (e < 53188) {
            if (e < 53133) {
              if (e < 53132) {
                if (53105 <= e && e <= 53131)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 53132)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 53160) {
              if (53133 <= e && e <= 53159)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 53161) {
              if (e === 53160)
                return i.CLUSTER_BREAK.LV;
            } else if (53161 <= e && e <= 53187)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53216) {
            if (e < 53189) {
              if (e === 53188)
                return i.CLUSTER_BREAK.LV;
            } else if (53189 <= e && e <= 53215)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53217) {
            if (e === 53216)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53244) {
            if (53217 <= e && e <= 53243)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53244)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53328) {
          if (e < 53273) {
            if (e < 53272) {
              if (53245 <= e && e <= 53271)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 53272)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53300) {
            if (53273 <= e && e <= 53299)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53301) {
            if (e === 53300)
              return i.CLUSTER_BREAK.LV;
          } else if (53301 <= e && e <= 53327)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53357) {
          if (e < 53329) {
            if (e === 53328)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53356) {
            if (53329 <= e && e <= 53355)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53356)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53384) {
          if (53357 <= e && e <= 53383)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53385) {
          if (e === 53384)
            return i.CLUSTER_BREAK.LV;
        } else if (53385 <= e && e <= 53411)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53553) {
        if (e < 53469) {
          if (e < 53440) {
            if (e < 53413) {
              if (e === 53412)
                return i.CLUSTER_BREAK.LV;
            } else if (53413 <= e && e <= 53439)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53441) {
            if (e === 53440)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53468) {
            if (53441 <= e && e <= 53467)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53468)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53524) {
          if (e < 53496) {
            if (53469 <= e && e <= 53495)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53497) {
            if (e === 53496)
              return i.CLUSTER_BREAK.LV;
          } else if (53497 <= e && e <= 53523)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53525) {
          if (e === 53524)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53552) {
          if (53525 <= e && e <= 53551)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 53552)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 53636) {
        if (e < 53581) {
          if (e < 53580) {
            if (53553 <= e && e <= 53579)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53580)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53608) {
          if (53581 <= e && e <= 53607)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53609) {
          if (e === 53608)
            return i.CLUSTER_BREAK.LV;
        } else if (53609 <= e && e <= 53635)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53665) {
        if (e < 53637) {
          if (e === 53636)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53664) {
          if (53637 <= e && e <= 53663)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 53664)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 53692) {
        if (53665 <= e && e <= 53691)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53693) {
        if (e === 53692)
          return i.CLUSTER_BREAK.LV;
      } else if (53693 <= e && e <= 53719)
        return i.CLUSTER_BREAK.LVT;
    } else if (e < 70459) {
      if (e < 54897) {
        if (e < 54308) {
          if (e < 54001) {
            if (e < 53860) {
              if (e < 53777) {
                if (e < 53748) {
                  if (e < 53721) {
                    if (e === 53720)
                      return i.CLUSTER_BREAK.LV;
                  } else if (53721 <= e && e <= 53747)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 53749) {
                  if (e === 53748)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 53776) {
                  if (53749 <= e && e <= 53775)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 53776)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 53805) {
                if (e < 53804) {
                  if (53777 <= e && e <= 53803)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 53804)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 53832) {
                if (53805 <= e && e <= 53831)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 53833) {
                if (e === 53832)
                  return i.CLUSTER_BREAK.LV;
              } else if (53833 <= e && e <= 53859)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 53917) {
              if (e < 53888) {
                if (e < 53861) {
                  if (e === 53860)
                    return i.CLUSTER_BREAK.LV;
                } else if (53861 <= e && e <= 53887)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 53889) {
                if (e === 53888)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 53916) {
                if (53889 <= e && e <= 53915)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 53916)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 53972) {
              if (e < 53944) {
                if (53917 <= e && e <= 53943)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 53945) {
                if (e === 53944)
                  return i.CLUSTER_BREAK.LV;
              } else if (53945 <= e && e <= 53971)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 53973) {
              if (e === 53972)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54e3) {
              if (53973 <= e && e <= 53999)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54e3)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54141) {
            if (e < 54084) {
              if (e < 54029) {
                if (e < 54028) {
                  if (54001 <= e && e <= 54027)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 54028)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 54056) {
                if (54029 <= e && e <= 54055)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 54057) {
                if (e === 54056)
                  return i.CLUSTER_BREAK.LV;
              } else if (54057 <= e && e <= 54083)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54112) {
              if (e < 54085) {
                if (e === 54084)
                  return i.CLUSTER_BREAK.LV;
              } else if (54085 <= e && e <= 54111)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54113) {
              if (e === 54112)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54140) {
              if (54113 <= e && e <= 54139)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54140)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54224) {
            if (e < 54169) {
              if (e < 54168) {
                if (54141 <= e && e <= 54167)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54168)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54196) {
              if (54169 <= e && e <= 54195)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54197) {
              if (e === 54196)
                return i.CLUSTER_BREAK.LV;
            } else if (54197 <= e && e <= 54223)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54253) {
            if (e < 54225) {
              if (e === 54224)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54252) {
              if (54225 <= e && e <= 54251)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54252)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54280) {
            if (54253 <= e && e <= 54279)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54281) {
            if (e === 54280)
              return i.CLUSTER_BREAK.LV;
          } else if (54281 <= e && e <= 54307)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 54589) {
          if (e < 54448) {
            if (e < 54365) {
              if (e < 54336) {
                if (e < 54309) {
                  if (e === 54308)
                    return i.CLUSTER_BREAK.LV;
                } else if (54309 <= e && e <= 54335)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 54337) {
                if (e === 54336)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 54364) {
                if (54337 <= e && e <= 54363)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54364)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54393) {
              if (e < 54392) {
                if (54365 <= e && e <= 54391)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54392)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54420) {
              if (54393 <= e && e <= 54419)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54421) {
              if (e === 54420)
                return i.CLUSTER_BREAK.LV;
            } else if (54421 <= e && e <= 54447)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54505) {
            if (e < 54476) {
              if (e < 54449) {
                if (e === 54448)
                  return i.CLUSTER_BREAK.LV;
              } else if (54449 <= e && e <= 54475)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54477) {
              if (e === 54476)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54504) {
              if (54477 <= e && e <= 54503)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54504)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54560) {
            if (e < 54532) {
              if (54505 <= e && e <= 54531)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54533) {
              if (e === 54532)
                return i.CLUSTER_BREAK.LV;
            } else if (54533 <= e && e <= 54559)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54561) {
            if (e === 54560)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54588) {
            if (54561 <= e && e <= 54587)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 54588)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 54756) {
          if (e < 54672) {
            if (e < 54617) {
              if (e < 54616) {
                if (54589 <= e && e <= 54615)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54616)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54644) {
              if (54617 <= e && e <= 54643)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54645) {
              if (e === 54644)
                return i.CLUSTER_BREAK.LV;
            } else if (54645 <= e && e <= 54671)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54701) {
            if (e < 54673) {
              if (e === 54672)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54700) {
              if (54673 <= e && e <= 54699)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54700)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54728) {
            if (54701 <= e && e <= 54727)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54729) {
            if (e === 54728)
              return i.CLUSTER_BREAK.LV;
          } else if (54729 <= e && e <= 54755)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 54813) {
          if (e < 54784) {
            if (e < 54757) {
              if (e === 54756)
                return i.CLUSTER_BREAK.LV;
            } else if (54757 <= e && e <= 54783)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54785) {
            if (e === 54784)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54812) {
            if (54785 <= e && e <= 54811)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 54812)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 54868) {
          if (e < 54840) {
            if (54813 <= e && e <= 54839)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54841) {
            if (e === 54840)
              return i.CLUSTER_BREAK.LV;
          } else if (54841 <= e && e <= 54867)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 54869) {
          if (e === 54868)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 54896) {
          if (54869 <= e && e <= 54895)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 54896)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 69632) {
        if (e < 55216) {
          if (e < 55037) {
            if (e < 54980) {
              if (e < 54925) {
                if (e < 54924) {
                  if (54897 <= e && e <= 54923)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 54924)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 54952) {
                if (54925 <= e && e <= 54951)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 54953) {
                if (e === 54952)
                  return i.CLUSTER_BREAK.LV;
              } else if (54953 <= e && e <= 54979)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 55008) {
              if (e < 54981) {
                if (e === 54980)
                  return i.CLUSTER_BREAK.LV;
              } else if (54981 <= e && e <= 55007)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 55009) {
              if (e === 55008)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 55036) {
              if (55009 <= e && e <= 55035)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 55036)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 55120) {
            if (e < 55065) {
              if (e < 55064) {
                if (55037 <= e && e <= 55063)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 55064)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 55092) {
              if (55065 <= e && e <= 55091)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 55093) {
              if (e === 55092)
                return i.CLUSTER_BREAK.LV;
            } else if (55093 <= e && e <= 55119)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 55149) {
            if (e < 55121) {
              if (e === 55120)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 55148) {
              if (55121 <= e && e <= 55147)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 55148)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 55176) {
            if (55149 <= e && e <= 55175)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 55177) {
            if (e === 55176)
              return i.CLUSTER_BREAK.LV;
          } else if (55177 <= e && e <= 55203)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 68097) {
          if (e < 65279) {
            if (e < 64286) {
              if (e < 55243) {
                if (55216 <= e && e <= 55238)
                  return i.CLUSTER_BREAK.V;
              } else if (55243 <= e && e <= 55291)
                return i.CLUSTER_BREAK.T;
            } else if (e < 65024) {
              if (e === 64286)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 65056) {
              if (65024 <= e && e <= 65039)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (65056 <= e && e <= 65071)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 66045) {
            if (e < 65438) {
              if (e === 65279)
                return i.CLUSTER_BREAK.CONTROL;
            } else if (e < 65520) {
              if (65438 <= e && e <= 65439)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (65520 <= e && e <= 65531)
              return i.CLUSTER_BREAK.CONTROL;
          } else if (e < 66272) {
            if (e === 66045)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 66422) {
            if (e === 66272)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (66422 <= e && e <= 66426)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 68325) {
          if (e < 68108) {
            if (e < 68101) {
              if (68097 <= e && e <= 68099)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (68101 <= e && e <= 68102)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 68152) {
            if (68108 <= e && e <= 68111)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 68159) {
            if (68152 <= e && e <= 68154)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 68159)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69373) {
          if (e < 68900) {
            if (68325 <= e && e <= 68326)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69291) {
            if (68900 <= e && e <= 68903)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (69291 <= e && e <= 69292)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69446) {
          if (69373 <= e && e <= 69375)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69506) {
          if (69446 <= e && e <= 69456)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (69506 <= e && e <= 69509)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70016) {
        if (e < 69815) {
          if (e < 69747) {
            if (e < 69634) {
              if (e === 69632)
                return i.CLUSTER_BREAK.SPACINGMARK;
              if (e === 69633)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 69688) {
              if (e === 69634)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 69744) {
              if (69688 <= e && e <= 69702)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 69744)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69762) {
            if (e < 69759) {
              if (69747 <= e && e <= 69748)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (69759 <= e && e <= 69761)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69808) {
            if (e === 69762)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 69811) {
            if (69808 <= e && e <= 69810)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (69811 <= e && e <= 69814)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69888)
          if (e < 69821) {
            if (e < 69817) {
              if (69815 <= e && e <= 69816)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (69817 <= e && e <= 69818)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69826) {
            if (e === 69821)
              return i.CLUSTER_BREAK.PREPEND;
          } else {
            if (e === 69826)
              return i.CLUSTER_BREAK.EXTEND;
            if (e === 69837)
              return i.CLUSTER_BREAK.PREPEND;
          }
        else if (e < 69933) {
          if (e < 69927) {
            if (69888 <= e && e <= 69890)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69932) {
            if (69927 <= e && e <= 69931)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 69932)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 69957) {
          if (69933 <= e && e <= 69940)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70003) {
          if (69957 <= e && e <= 69958)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e === 70003)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70194) {
        if (e < 70082) {
          if (e < 70067) {
            if (e < 70018) {
              if (70016 <= e && e <= 70017)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 70018)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70070) {
            if (70067 <= e && e <= 70069)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70079) {
            if (70070 <= e && e <= 70078)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (70079 <= e && e <= 70080)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70095) {
          if (e < 70089) {
            if (70082 <= e && e <= 70083)
              return i.CLUSTER_BREAK.PREPEND;
          } else if (e < 70094) {
            if (70089 <= e && e <= 70092)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 70094)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70188) {
          if (e === 70095)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70191) {
          if (70188 <= e && e <= 70190)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (70191 <= e && e <= 70193)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70209) {
        if (e < 70197) {
          if (e < 70196) {
            if (70194 <= e && e <= 70195)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 70196)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70198) {
          if (e === 70197)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70206) {
          if (70198 <= e && e <= 70199)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e === 70206)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70371) {
        if (e < 70367) {
          if (e === 70209)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70368) {
          if (e === 70367)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (70368 <= e && e <= 70370)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 70400) {
        if (70371 <= e && e <= 70378)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70402) {
        if (70400 <= e && e <= 70401)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (70402 <= e && e <= 70403)
        return i.CLUSTER_BREAK.SPACINGMARK;
    } else if (e < 72343) {
      if (e < 71339) {
        if (e < 70841) {
          if (e < 70512) {
            if (e < 70471) {
              if (e < 70463) {
                if (e < 70462) {
                  if (70459 <= e && e <= 70460)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 70462)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 70464) {
                if (e === 70463)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70465) {
                if (e === 70464)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (70465 <= e && e <= 70468)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70487) {
              if (e < 70475) {
                if (70471 <= e && e <= 70472)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (70475 <= e && e <= 70477)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70498) {
              if (e === 70487)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70502) {
              if (70498 <= e && e <= 70499)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (70502 <= e && e <= 70508)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70725) {
            if (e < 70712) {
              if (e < 70709) {
                if (70512 <= e && e <= 70516)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (70709 <= e && e <= 70711)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70720) {
              if (70712 <= e && e <= 70719)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70722) {
              if (70720 <= e && e <= 70721)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (70722 <= e && e <= 70724)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70832) {
            if (e < 70726) {
              if (e === 70725)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 70726 || e === 70750)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70833) {
            if (e === 70832)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70835) {
            if (70833 <= e && e <= 70834)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (70835 <= e && e <= 70840)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71096) {
          if (e < 70847)
            if (e < 70843) {
              if (e === 70841)
                return i.CLUSTER_BREAK.SPACINGMARK;
              if (e === 70842)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70845) {
              if (70843 <= e && e <= 70844)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else {
              if (e === 70845)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 70846)
                return i.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 71087) {
            if (e < 70849) {
              if (70847 <= e && e <= 70848)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70850) {
              if (e === 70849)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (70850 <= e && e <= 70851)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71088) {
            if (e === 71087)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71090) {
            if (71088 <= e && e <= 71089)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (71090 <= e && e <= 71093)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71216) {
          if (e < 71102) {
            if (e < 71100) {
              if (71096 <= e && e <= 71099)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (71100 <= e && e <= 71101)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71103) {
            if (e === 71102)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71132) {
            if (71103 <= e && e <= 71104)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (71132 <= e && e <= 71133)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71229) {
          if (e < 71219) {
            if (71216 <= e && e <= 71218)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71227) {
            if (71219 <= e && e <= 71226)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (71227 <= e && e <= 71228)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71230) {
          if (e === 71229)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71231) {
          if (e === 71230)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (71231 <= e && e <= 71232)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 71999)
        if (e < 71463) {
          if (e < 71350) {
            if (e < 71341) {
              if (e === 71339)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 71340)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71342) {
              if (e === 71341)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 71344) {
              if (71342 <= e && e <= 71343)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (71344 <= e && e <= 71349)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71453) {
            if (e === 71350)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 71351)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71458) {
            if (71453 <= e && e <= 71455)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71462) {
            if (71458 <= e && e <= 71461)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 71462)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71984) {
          if (e < 71727) {
            if (e < 71724) {
              if (71463 <= e && e <= 71467)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (71724 <= e && e <= 71726)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71736) {
            if (71727 <= e && e <= 71735)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71737) {
            if (e === 71736)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (71737 <= e && e <= 71738)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71995) {
          if (e < 71985) {
            if (e === 71984)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71991) {
            if (71985 <= e && e <= 71989)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (71991 <= e && e <= 71992)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71997) {
          if (71995 <= e && e <= 71996)
            return i.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 71997)
            return i.CLUSTER_BREAK.SPACINGMARK;
          if (e === 71998)
            return i.CLUSTER_BREAK.EXTEND;
        }
      else if (e < 72193)
        if (e < 72145)
          if (e < 72001) {
            if (e === 71999)
              return i.CLUSTER_BREAK.PREPEND;
            if (e === 72e3)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72002) {
            if (e === 72001)
              return i.CLUSTER_BREAK.PREPEND;
          } else {
            if (e === 72002)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 72003)
              return i.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 72156) {
          if (e < 72148) {
            if (72145 <= e && e <= 72147)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72154) {
            if (72148 <= e && e <= 72151)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (72154 <= e && e <= 72155)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 72160) {
          if (72156 <= e && e <= 72159)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else {
          if (e === 72160)
            return i.CLUSTER_BREAK.EXTEND;
          if (e === 72164)
            return i.CLUSTER_BREAK.SPACINGMARK;
        }
      else if (e < 72263) {
        if (e < 72249) {
          if (e < 72243) {
            if (72193 <= e && e <= 72202)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (72243 <= e && e <= 72248)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 72250) {
          if (e === 72249)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 72251) {
          if (e === 72250)
            return i.CLUSTER_BREAK.PREPEND;
        } else if (72251 <= e && e <= 72254)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 72281) {
        if (e < 72273) {
          if (e === 72263)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 72279) {
          if (72273 <= e && e <= 72278)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (72279 <= e && e <= 72280)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 72324) {
        if (72281 <= e && e <= 72283)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 72330) {
        if (72324 <= e && e <= 72329)
          return i.CLUSTER_BREAK.PREPEND;
      } else if (72330 <= e && e <= 72342)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 94033) {
      if (e < 73104) {
        if (e < 72881) {
          if (e < 72766) {
            if (e < 72751) {
              if (e < 72344) {
                if (e === 72343)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (72344 <= e && e <= 72345)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 72752) {
              if (e === 72751)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 72760) {
              if (72752 <= e && e <= 72758)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (72760 <= e && e <= 72765)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72850) {
            if (e === 72766)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 72767)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72873) {
            if (72850 <= e && e <= 72871)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72874) {
            if (e === 72873)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (72874 <= e && e <= 72880)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73018) {
          if (e < 72884) {
            if (e < 72882) {
              if (e === 72881)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (72882 <= e && e <= 72883)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72885) {
            if (e === 72884)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73009) {
            if (72885 <= e && e <= 72886)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (73009 <= e && e <= 73014)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73030) {
          if (e < 73020) {
            if (e === 73018)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 73023) {
            if (73020 <= e && e <= 73021)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (73023 <= e && e <= 73029)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73031) {
          if (e === 73030)
            return i.CLUSTER_BREAK.PREPEND;
        } else if (e < 73098) {
          if (e === 73031)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (73098 <= e && e <= 73102)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 73526) {
        if (e < 73459)
          if (e < 73109) {
            if (e < 73107) {
              if (73104 <= e && e <= 73105)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (73107 <= e && e <= 73108)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73110) {
            if (e === 73109)
              return i.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 73110)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 73111)
              return i.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 73474) {
          if (e < 73461) {
            if (73459 <= e && e <= 73460)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 73472) {
            if (73461 <= e && e <= 73462)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (73472 <= e && e <= 73473)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73475) {
          if (e === 73474)
            return i.CLUSTER_BREAK.PREPEND;
        } else if (e < 73524) {
          if (e === 73475)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (73524 <= e && e <= 73525)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 78896)
        if (e < 73536) {
          if (e < 73534) {
            if (73526 <= e && e <= 73530)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (73534 <= e && e <= 73535)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 73537) {
          if (e === 73536)
            return i.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 73537)
            return i.CLUSTER_BREAK.SPACINGMARK;
          if (e === 73538)
            return i.CLUSTER_BREAK.EXTEND;
        }
      else if (e < 92912) {
        if (e < 78912) {
          if (78896 <= e && e <= 78911)
            return i.CLUSTER_BREAK.CONTROL;
        } else if (e < 78919) {
          if (e === 78912)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (78919 <= e && e <= 78933)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 92976) {
        if (92912 <= e && e <= 92916)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 94031) {
        if (92976 <= e && e <= 92982)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e === 94031)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 121476) {
      if (e < 119143)
        if (e < 113824) {
          if (e < 94180) {
            if (e < 94095) {
              if (94033 <= e && e <= 94087)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (94095 <= e && e <= 94098)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 94192) {
            if (e === 94180)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 113821) {
            if (94192 <= e && e <= 94193)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (113821 <= e && e <= 113822)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 118576) {
          if (e < 118528) {
            if (113824 <= e && e <= 113827)
              return i.CLUSTER_BREAK.CONTROL;
          } else if (118528 <= e && e <= 118573)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 119141) {
          if (118576 <= e && e <= 118598)
            return i.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 119141)
            return i.CLUSTER_BREAK.EXTEND;
          if (e === 119142)
            return i.CLUSTER_BREAK.SPACINGMARK;
        }
      else if (e < 119173) {
        if (e < 119150) {
          if (e < 119149) {
            if (119143 <= e && e <= 119145)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 119149)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 119155) {
          if (119150 <= e && e <= 119154)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 119163) {
          if (119155 <= e && e <= 119162)
            return i.CLUSTER_BREAK.CONTROL;
        } else if (119163 <= e && e <= 119170)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 121344) {
        if (e < 119210) {
          if (119173 <= e && e <= 119179)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 119362) {
          if (119210 <= e && e <= 119213)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (119362 <= e && e <= 119364)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 121403) {
        if (121344 <= e && e <= 121398)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 121461) {
        if (121403 <= e && e <= 121452)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e === 121461)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 123628) {
      if (e < 122907) {
        if (e < 121505) {
          if (e < 121499) {
            if (e === 121476)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (121499 <= e && e <= 121503)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 122880) {
          if (121505 <= e && e <= 121519)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 122888) {
          if (122880 <= e && e <= 122886)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (122888 <= e && e <= 122904)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 123023) {
        if (e < 122915) {
          if (122907 <= e && e <= 122913)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 122918) {
          if (122915 <= e && e <= 122916)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (122918 <= e && e <= 122922)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 123184) {
        if (e === 123023)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 123566) {
        if (123184 <= e && e <= 123190)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e === 123566)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 127995) {
      if (e < 125136) {
        if (e < 124140) {
          if (123628 <= e && e <= 123631)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (124140 <= e && e <= 124143)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 125252) {
        if (125136 <= e && e <= 125142)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 127462) {
        if (125252 <= e && e <= 125258)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (127462 <= e && e <= 127487)
        return i.CLUSTER_BREAK.REGIONAL_INDICATOR;
    } else if (e < 917632) {
      if (e < 917504) {
        if (127995 <= e && e <= 127999)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 917536) {
        if (917504 <= e && e <= 917535)
          return i.CLUSTER_BREAK.CONTROL;
      } else if (917536 <= e && e <= 917631)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 917760) {
      if (917632 <= e && e <= 917759)
        return i.CLUSTER_BREAK.CONTROL;
    } else if (e < 918e3) {
      if (917760 <= e && e <= 917999)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (918e3 <= e && e <= 921599)
      return i.CLUSTER_BREAK.CONTROL;
    return i.CLUSTER_BREAK.OTHER;
  }
  /**
   * Given a Unicode code point, returns if symbol is an extended pictographic or some other break
   * @param code {number} Unicode code point
   * @returns {number}
   */
  static getEmojiProperty(e) {
    if (e < 10160) {
      if (e < 9728) {
        if (e < 9e3) {
          if (e < 8482) {
            if (e < 8252) {
              if (e === 169 || e === 174)
                return i.EXTENDED_PICTOGRAPHIC;
            } else if (e === 8252 || e === 8265)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8596) {
            if (e === 8482 || e === 8505)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8617) {
            if (8596 <= e && e <= 8601)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8986) {
            if (8617 <= e && e <= 8618)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (8986 <= e && e <= 8987)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9410) {
          if (e < 9167) {
            if (e === 9e3 || e === 9096)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9193) {
            if (e === 9167)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9208) {
            if (9193 <= e && e <= 9203)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (9208 <= e && e <= 9210)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9654) {
          if (e < 9642) {
            if (e === 9410)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (9642 <= e && e <= 9643)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9664) {
          if (e === 9654)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9723) {
          if (e === 9664)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (9723 <= e && e <= 9726)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10035) {
        if (e < 10004) {
          if (e < 9748) {
            if (e < 9735) {
              if (9728 <= e && e <= 9733)
                return i.EXTENDED_PICTOGRAPHIC;
            } else if (9735 <= e && e <= 9746)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9872) {
            if (9748 <= e && e <= 9861)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9992) {
            if (9872 <= e && e <= 9989)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (9992 <= e && e <= 10002)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10013) {
          if (e === 10004 || e === 10006)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10017) {
          if (e === 10013)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10017 || e === 10024)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10067) {
        if (e < 10055) {
          if (e < 10052) {
            if (10035 <= e && e <= 10036)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10052)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10060) {
          if (e === 10055)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10060 || e === 10062)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10083) {
        if (e < 10071) {
          if (10067 <= e && e <= 10069)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10071)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10133) {
        if (10083 <= e && e <= 10087)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10145) {
        if (10133 <= e && e <= 10135)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e === 10145)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 127489) {
      if (e < 12951) {
        if (e < 11035) {
          if (e < 10548) {
            if (e === 10160 || e === 10175)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 11013) {
            if (10548 <= e && e <= 10549)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (11013 <= e && e <= 11015)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 11093) {
          if (e < 11088) {
            if (11035 <= e && e <= 11036)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e === 11088)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 12336) {
          if (e === 11093)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 12336 || e === 12349)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127340) {
        if (e < 126976) {
          if (e === 12951 || e === 12953)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127245) {
          if (126976 <= e && e <= 127231)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127279) {
          if (127245 <= e && e <= 127247)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 127279)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127374) {
        if (e < 127358) {
          if (127340 <= e && e <= 127345)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (127358 <= e && e <= 127359)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127377) {
        if (e === 127374)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127405) {
        if (127377 <= e && e <= 127386)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (127405 <= e && e <= 127461)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 128981) {
      if (e < 127561) {
        if (e < 127535) {
          if (e < 127514) {
            if (127489 <= e && e <= 127503)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e === 127514)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127538) {
          if (e === 127535)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127548) {
          if (127538 <= e && e <= 127546)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (127548 <= e && e <= 127551)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128326) {
        if (e < 128e3) {
          if (127561 <= e && e <= 127994)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (128e3 <= e && e <= 128317)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128640) {
        if (128326 <= e && e <= 128591)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128884) {
        if (128640 <= e && e <= 128767)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (128884 <= e && e <= 128895)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129198) {
      if (e < 129096) {
        if (e < 129036) {
          if (128981 <= e && e <= 129023)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (129036 <= e && e <= 129039)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129114) {
        if (129096 <= e && e <= 129103)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129160) {
        if (129114 <= e && e <= 129119)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (129160 <= e && e <= 129167)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129340) {
      if (e < 129292) {
        if (129198 <= e && e <= 129279)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (129292 <= e && e <= 129338)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129351) {
      if (129340 <= e && e <= 129349)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 130048) {
      if (129351 <= e && e <= 129791)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (130048 <= e && e <= 131069)
      return i.EXTENDED_PICTOGRAPHIC;
    return i.CLUSTER_BREAK.OTHER;
  }
}
Qu.default = Fi;
var Rg = de && de.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Ju, "__esModule", { value: !0 });
const Ag = Rg(Qu);
Ju.default = Ag.default;
var _g = de && de.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, u);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), wg = de && de.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), Tg = de && de.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && _g(e, t, r);
  return wg(e, t), e;
}, Sg = de && de.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Sr, "__esModule", { value: !0 });
Sr.validateLanguage = Sr.parseLanguage = Sr.b64UrlToUtf8 = Sr.utf8ToB64Url = Sr.graphemeLen = Sr.utf8Len = void 0;
const Cg = Sg(Ju), Nl = Tg(Ef), Lg = (t) => new TextEncoder().encode(t).byteLength;
Sr.utf8Len = Lg;
const kg = (t) => new Cg.default().countGraphemes(t);
Sr.graphemeLen = kg;
const Dg = (t) => Nl.toString(Nl.fromString(t, "utf8"), "base64url");
Sr.utf8ToB64Url = Dg;
const Pg = (t) => Nl.toString(Nl.fromString(t, "base64url"), "utf8");
Sr.b64UrlToUtf8 = Pg;
const Bg = (t) => {
  const e = t.match(wf);
  if (!e?.groups)
    return null;
  const r = e.groups;
  return {
    grandfathered: r.grandfathered,
    language: r.language,
    extlang: r.extlang,
    script: r.script,
    region: r.region,
    variant: r.variant,
    extension: r.extension,
    privateUse: r.privateUseA || r.privateUseB
  };
};
Sr.parseLanguage = Bg;
const Ig = (t) => wf.test(t);
Sr.validateLanguage = Ig;
const wf = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/;
var Tf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.didDocument = t.getServiceEndpoint = t.getNotifEndpoint = t.getFeedGenEndpoint = t.getPdsEndpoint = t.getSigningDidKey = t.getVerificationMaterial = t.getSigningKey = t.getHandle = t.getDid = t.isValidDidDoc = void 0;
  const e = ia, r = (J) => t.didDocument.safeParse(J).success;
  t.isValidDidDoc = r;
  const n = (J) => {
    const F = J.id;
    if (typeof F != "string")
      throw new Error("No `id` on document");
    return F;
  };
  t.getDid = n;
  const u = (J) => {
    const F = J.alsoKnownAs;
    if (F)
      for (let z = 0; z < F.length; z++) {
        const ee = F[z];
        if (ee.startsWith("at://"))
          return ee.slice(5);
      }
  };
  t.getHandle = u;
  const y = (J) => (0, t.getVerificationMaterial)(J, "atproto");
  t.getSigningKey = y;
  const b = (J, F) => {
    const z = B(J, "verificationMethod", `#${F}`);
    if (z && z.publicKeyMultibase)
      return {
        type: z.type,
        publicKeyMultibase: z.publicKeyMultibase
      };
  };
  t.getVerificationMaterial = b;
  const h = (J) => {
    const F = (0, t.getSigningKey)(J);
    if (F)
      return `did:key:${F.publicKeyMultibase}`;
  };
  t.getSigningDidKey = h;
  const d = (J) => (0, t.getServiceEndpoint)(J, {
    id: "#atproto_pds",
    type: "AtprotoPersonalDataServer"
  });
  t.getPdsEndpoint = d;
  const m = (J) => (0, t.getServiceEndpoint)(J, {
    id: "#bsky_fg",
    type: "BskyFeedGenerator"
  });
  t.getFeedGenEndpoint = m;
  const p = (J) => (0, t.getServiceEndpoint)(J, {
    id: "#bsky_notif",
    type: "BskyNotificationService"
  });
  t.getNotifEndpoint = p;
  const _ = (J, F) => {
    const z = B(J, "service", F.id);
    if (z && !(F.type && z.type !== F.type) && typeof z.serviceEndpoint == "string")
      return N(z.serviceEndpoint);
  };
  t.getServiceEndpoint = _;
  function B(J, F, z) {
    const ee = J[F];
    if (ee)
      for (let ye = 0; ye < ee.length; ye++) {
        const xe = ee[ye], Ee = xe.id;
        if (Ee[0] === "#" ? Ee === z : (
          // Optimized version of: itemId === `${doc.id}${id}`
          Ee.length === J.id.length + z.length && Ee[J.id.length] === "#" && Ee.endsWith(z) && Ee.startsWith(J.id)
        ))
          return xe;
      }
  }
  const N = (J) => {
    if (!(!J.startsWith("http://") && !J.startsWith("https://")) && X(J))
      return J;
  }, X = URL.canParse ?? // URL.canParse is not available in Node.js < 18.17.0
  ((J) => {
    try {
      return new URL(J), !0;
    } catch {
      return !1;
    }
  }), te = e.z.object({
    id: e.z.string(),
    type: e.z.string(),
    controller: e.z.string(),
    publicKeyMultibase: e.z.string().optional()
  }), re = e.z.object({
    id: e.z.string(),
    type: e.z.string(),
    serviceEndpoint: e.z.union([e.z.string(), e.z.record(e.z.unknown())])
  });
  t.didDocument = e.z.object({
    id: e.z.string(),
    alsoKnownAs: e.z.array(e.z.string()).optional(),
    verificationMethod: e.z.array(te).optional(),
    service: e.z.array(re).optional()
  });
})(Tf);
(function(t) {
  var e = de && de.__createBinding || (Object.create ? function(y, b, h, d) {
    d === void 0 && (d = h);
    var m = Object.getOwnPropertyDescriptor(b, h);
    (!m || ("get" in m ? !b.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return b[h];
    } }), Object.defineProperty(y, d, m);
  } : function(y, b, h, d) {
    d === void 0 && (d = h), y[d] = b[h];
  }), r = de && de.__setModuleDefault || (Object.create ? function(y, b) {
    Object.defineProperty(y, "default", { enumerable: !0, value: b });
  } : function(y, b) {
    y.default = b;
  }), n = de && de.__importStar || function(y) {
    if (y && y.__esModule) return y;
    var b = {};
    if (y != null) for (var h in y) h !== "default" && Object.prototype.hasOwnProperty.call(y, h) && e(b, y, h);
    return r(b, y), b;
  }, u = de && de.__exportStar || function(y, b) {
    for (var h in y) h !== "default" && !Object.prototype.hasOwnProperty.call(b, h) && e(b, y, h);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.util = t.check = void 0, t.check = n(mi), t.util = n(fa), u(pa, t), u(pf, t), u(fa, t), u(rs, t), u(hf, t), u(ha, t), u(Rf, t), u(Af, t), u(Sr, t), u(Tf, t);
})(Pi);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.BlobRef = t.jsonBlobRef = t.untypedJsonBlobRef = t.typedJsonBlobRef = void 0;
  const e = Pi, r = Pa, n = ia;
  t.typedJsonBlobRef = n.z.object({
    $type: n.z.literal("blob"),
    ref: e.schema.cid,
    mimeType: n.z.string(),
    size: n.z.number()
  }).strict(), t.untypedJsonBlobRef = n.z.object({
    cid: n.z.string(),
    mimeType: n.z.string()
  }).strict(), t.jsonBlobRef = n.z.union([t.typedJsonBlobRef, t.untypedJsonBlobRef]);
  class u {
    constructor(b, h, d, m) {
      Object.defineProperty(this, "ref", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: b
      }), Object.defineProperty(this, "mimeType", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: h
      }), Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: d
      }), Object.defineProperty(this, "original", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.original = m ?? {
        $type: "blob",
        ref: b,
        mimeType: h,
        size: d
      };
    }
    static asBlobRef(b) {
      return e.check.is(b, t.jsonBlobRef) ? u.fromJsonRef(b) : null;
    }
    static fromJsonRef(b) {
      return e.check.is(b, t.typedJsonBlobRef) ? new u(b.ref, b.mimeType, b.size) : new u(r.CID.parse(b.cid), b.mimeType, -1, b);
    }
    ipld() {
      return {
        $type: "blob",
        ref: this.ref,
        mimeType: this.mimeType,
        size: this.size
      };
    }
    toJSON() {
      return (0, e.ipldToJson)(this.ipld());
    }
  }
  t.BlobRef = u;
})(Jl);
Object.defineProperty(Yl, "__esModule", { value: !0 });
Yl.blob = void 0;
const Ug = Jl, Og = Tn;
function Kg(t, e, r, n) {
  return !n || !(n instanceof Ug.BlobRef) ? {
    success: !1,
    error: new Og.ValidationError(`${e} should be a blob ref`)
  } : { success: !0, value: n };
}
Yl.blob = Kg;
var sr = {}, vt = {}, Sf = {};
(function(t) {
  (() => {
    var e = { d: (p, _) => {
      for (var B in _) e.o(_, B) && !e.o(p, B) && Object.defineProperty(p, B, { enumerable: !0, get: _[B] });
    }, o: (p, _) => Object.prototype.hasOwnProperty.call(p, _), r: (p) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(p, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(p, "__esModule", { value: !0 });
    } }, r = {};
    function n(p, _) {
      return _ === void 0 && (_ = "-"), new RegExp("^(?!0{4}" + _ + "0{2}" + _ + "0{2})((?=[0-9]{4}" + _ + "(((0[^2])|1[0-2])|02(?=" + _ + "(([0-1][0-9])|2[0-8])))" + _ + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + _ + "02" + _ + "29))([0-9]{4})" + _ + "(?!((0[469])|11)" + _ + "31)((0[1,3-9]|1[0-2])|(02(?!" + _ + "3)))" + _ + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(p);
    }
    function u(p) {
      var _ = /\D/.exec(p);
      return _ ? _[0] : "";
    }
    function y(p, _, B) {
      _ === void 0 && (_ = ":"), B === void 0 && (B = !1);
      var N = new RegExp("^([0-1]|2(?=([0-3])|4" + _ + "00))[0-9]" + _ + "[0-5][0-9](" + _ + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
      if (!B || !/[Z+\-]/.test(p)) return N.test(p);
      if (/Z$/.test(p)) return N.test(p.replace("Z", ""));
      var X = p.includes("+"), te = p.split(/[+-]/), re = te[0], J = te[1];
      return N.test(re) && function(F, z, ee) {
        return ee === void 0 && (ee = ":"), new RegExp(z ? "^(0(?!(2" + ee + "4)|0" + ee + "3)|1(?=([0-1]|2(?=" + ee + "[04])|[34](?=" + ee + "0))))([03469](?=" + ee + "[03])|[17](?=" + ee + "0)|2(?=" + ee + "[04])|5(?=" + ee + "[034])|8(?=" + ee + "[04]))" + ee + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + ee + "[03])|[0-24-8](?=" + ee + "00))" + ee + "[03]0$").test(F);
      }(J, X, u(J));
    }
    function b(p) {
      var _ = p.split("T"), B = _[0], N = _[1], X = n(B, u(B));
      if (!N) return !1;
      var te, re = (te = N.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(te) ? te[0] : "");
      return X && y(N, re, !0);
    }
    function h(p, _) {
      return _ === void 0 && (_ = "-"), new RegExp("^[0-9]{4}" + _ + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(p);
    }
    e.r(r), e.d(r, { isValidDate: () => n, isValidISODateString: () => b, isValidTime: () => y, isValidYearMonth: () => h });
    var d = t;
    for (var m in r) d[m] = r[m];
    r.__esModule && Object.defineProperty(d, "__esModule", { value: !0 });
  })();
})(Sf);
Object.defineProperty(vt, "__esModule", { value: !0 });
vt.recordKey = vt.tid = vt.language = vt.cid = vt.nsid = vt.atIdentifier = vt.handle = vt.did = vt.atUri = vt.uri = vt.datetime = void 0;
const Mg = Sf, Ng = Pa, oi = Tn, Ba = ra, Vg = Pi;
function jg(t, e) {
  try {
    if (!(0, Mg.isValidISODateString)(e))
      throw new Error();
  } catch {
    return {
      success: !1,
      error: new oi.ValidationError(`${t} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
    };
  }
  return { success: !0, value: e };
}
vt.datetime = jg;
function Fg(t, e) {
  return e.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null ? { success: !0, value: e } : {
    success: !1,
    error: new oi.ValidationError(`${t} must be a uri`)
  };
}
vt.uri = Fg;
function $g(t, e) {
  try {
    (0, Ba.ensureValidAtUri)(e);
  } catch {
    return {
      success: !1,
      error: new oi.ValidationError(`${t} must be a valid at-uri`)
    };
  }
  return { success: !0, value: e };
}
vt.atUri = $g;
function Cf(t, e) {
  try {
    (0, Ba.ensureValidDid)(e);
  } catch {
    return {
      success: !1,
      error: new oi.ValidationError(`${t} must be a valid did`)
    };
  }
  return { success: !0, value: e };
}
vt.did = Cf;
function Lf(t, e) {
  try {
    (0, Ba.ensureValidHandle)(e);
  } catch {
    return {
      success: !1,
      error: new oi.ValidationError(`${t} must be a valid handle`)
    };
  }
  return { success: !0, value: e };
}
vt.handle = Lf;
function Gg(t, e) {
  return !Cf(t, e).success && !Lf(t, e).success ? {
    success: !1,
    error: new oi.ValidationError(`${t} must be a valid did or a handle`)
  } : { success: !0, value: e };
}
vt.atIdentifier = Gg;
function qg(t, e) {
  try {
    (0, Ba.ensureValidNsid)(e);
  } catch {
    return {
      success: !1,
      error: new oi.ValidationError(`${t} must be a valid nsid`)
    };
  }
  return { success: !0, value: e };
}
vt.nsid = qg;
function Xg(t, e) {
  try {
    Ng.CID.parse(e);
  } catch {
    return {
      success: !1,
      error: new oi.ValidationError(`${t} must be a cid string`)
    };
  }
  return { success: !0, value: e };
}
vt.cid = Xg;
function zg(t, e) {
  return (0, Vg.validateLanguage)(e) ? { success: !0, value: e } : {
    success: !1,
    error: new oi.ValidationError(`${t} must be a well-formed BCP 47 language tag`)
  };
}
vt.language = zg;
function Hg(t, e) {
  try {
    (0, Ba.ensureValidTid)(e);
  } catch {
    return {
      success: !1,
      error: new oi.ValidationError(`${t} must be a valid TID (timestamp identifier)`)
    };
  }
  return { success: !0, value: e };
}
vt.tid = Hg;
function Zg(t, e) {
  try {
    (0, Ba.ensureValidRecordKey)(e);
  } catch {
    return {
      success: !1,
      error: new oi.ValidationError(`${t} must be a valid Record Key`)
    };
  }
  return { success: !0, value: e };
}
vt.recordKey = Zg;
var Wg = de && de.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, u);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), Yg = de && de.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), Jg = de && de.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && Wg(e, t, r);
  return Yg(e, t), e;
};
Object.defineProperty(sr, "__esModule", { value: !0 });
sr.unknown = sr.cidLink = sr.bytes = sr.string = sr.integer = sr.boolean = sr.validate = void 0;
const Xc = Pi, Qg = Pa, ei = Jg(vt), Rt = Tn;
function ex(t, e, r, n) {
  switch (r.type) {
    case "boolean":
      return kf(t, e, r, n);
    case "integer":
      return Df(t, e, r, n);
    case "string":
      return Pf(t, e, r, n);
    case "bytes":
      return Bf(t, e, r, n);
    case "cid-link":
      return If(t, e, r, n);
    case "unknown":
      return Uf(t, e, r, n);
    default:
      return {
        success: !1,
        error: new Rt.ValidationError(`Unexpected lexicon type: ${r.type}`)
      };
  }
}
sr.validate = ex;
function kf(t, e, r, n) {
  r = r;
  const u = typeof n;
  return u === "undefined" ? typeof r.default == "boolean" ? { success: !0, value: r.default } : {
    success: !1,
    error: new Rt.ValidationError(`${e} must be a boolean`)
  } : u !== "boolean" ? {
    success: !1,
    error: new Rt.ValidationError(`${e} must be a boolean`)
  } : typeof r.const == "boolean" && n !== r.const ? {
    success: !1,
    error: new Rt.ValidationError(`${e} must be ${r.const}`)
  } : { success: !0, value: n };
}
sr.boolean = kf;
function Df(t, e, r, n) {
  return r = r, typeof n === "undefined" ? typeof r.default == "number" ? { success: !0, value: r.default } : {
    success: !1,
    error: new Rt.ValidationError(`${e} must be an integer`)
  } : Number.isInteger(n) ? typeof r.const == "number" && n !== r.const ? {
    success: !1,
    error: new Rt.ValidationError(`${e} must be ${r.const}`)
  } : Array.isArray(r.enum) && !r.enum.includes(n) ? {
    success: !1,
    error: new Rt.ValidationError(`${e} must be one of (${r.enum.join("|")})`)
  } : typeof r.maximum == "number" && n > r.maximum ? {
    success: !1,
    error: new Rt.ValidationError(`${e} can not be greater than ${r.maximum}`)
  } : typeof r.minimum == "number" && n < r.minimum ? {
    success: !1,
    error: new Rt.ValidationError(`${e} can not be less than ${r.minimum}`)
  } : { success: !0, value: n } : {
    success: !1,
    error: new Rt.ValidationError(`${e} must be an integer`)
  };
}
sr.integer = Df;
function Pf(t, e, r, n) {
  if (r = r, typeof n > "u")
    return typeof r.default == "string" ? { success: !0, value: r.default } : {
      success: !1,
      error: new Rt.ValidationError(`${e} must be a string`)
    };
  if (typeof n != "string")
    return {
      success: !1,
      error: new Rt.ValidationError(`${e} must be a string`)
    };
  if (typeof r.const == "string" && n !== r.const)
    return {
      success: !1,
      error: new Rt.ValidationError(`${e} must be ${r.const}`)
    };
  if (Array.isArray(r.enum) && !r.enum.includes(n))
    return {
      success: !1,
      error: new Rt.ValidationError(`${e} must be one of (${r.enum.join("|")})`)
    };
  if (typeof r.maxLength == "number" || typeof r.minLength == "number") {
    const u = (0, Xc.utf8Len)(n);
    if (typeof r.maxLength == "number" && u > r.maxLength)
      return {
        success: !1,
        error: new Rt.ValidationError(`${e} must not be longer than ${r.maxLength} characters`)
      };
    if (typeof r.minLength == "number" && u < r.minLength)
      return {
        success: !1,
        error: new Rt.ValidationError(`${e} must not be shorter than ${r.minLength} characters`)
      };
  }
  if (typeof r.maxGraphemes == "number" || typeof r.minGraphemes == "number") {
    let u = !1, y = !1;
    if (typeof r.maxGraphemes == "number" && (n.length <= r.maxGraphemes ? u = !1 : u = !0), typeof r.minGraphemes == "number") {
      if (n.length < r.minGraphemes)
        return {
          success: !1,
          error: new Rt.ValidationError(`${e} must not be shorter than ${r.minGraphemes} graphemes`)
        };
      y = !0;
    }
    if (u || y) {
      const b = (0, Xc.graphemeLen)(n);
      if (typeof r.maxGraphemes == "number" && b > r.maxGraphemes)
        return {
          success: !1,
          error: new Rt.ValidationError(`${e} must not be longer than ${r.maxGraphemes} graphemes`)
        };
      if (typeof r.minGraphemes == "number" && b < r.minGraphemes)
        return {
          success: !1,
          error: new Rt.ValidationError(`${e} must not be shorter than ${r.minGraphemes} graphemes`)
        };
    }
  }
  if (typeof r.format == "string")
    switch (r.format) {
      case "datetime":
        return ei.datetime(e, n);
      case "uri":
        return ei.uri(e, n);
      case "at-uri":
        return ei.atUri(e, n);
      case "did":
        return ei.did(e, n);
      case "handle":
        return ei.handle(e, n);
      case "at-identifier":
        return ei.atIdentifier(e, n);
      case "nsid":
        return ei.nsid(e, n);
      case "cid":
        return ei.cid(e, n);
      case "language":
        return ei.language(e, n);
      case "tid":
        return ei.tid(e, n);
      case "record-key":
        return ei.recordKey(e, n);
    }
  return { success: !0, value: n };
}
sr.string = Pf;
function Bf(t, e, r, n) {
  return r = r, !n || !(n instanceof Uint8Array) ? {
    success: !1,
    error: new Rt.ValidationError(`${e} must be a byte array`)
  } : typeof r.maxLength == "number" && n.byteLength > r.maxLength ? {
    success: !1,
    error: new Rt.ValidationError(`${e} must not be larger than ${r.maxLength} bytes`)
  } : typeof r.minLength == "number" && n.byteLength < r.minLength ? {
    success: !1,
    error: new Rt.ValidationError(`${e} must not be smaller than ${r.minLength} bytes`)
  } : { success: !0, value: n };
}
sr.bytes = Bf;
function If(t, e, r, n) {
  return Qg.CID.asCID(n) === null ? {
    success: !1,
    error: new Rt.ValidationError(`${e} must be a CID`)
  } : { success: !0, value: n };
}
sr.cidLink = If;
function Uf(t, e, r, n) {
  return !n || typeof n != "object" ? {
    success: !1,
    error: new Rt.ValidationError(`${e} must be an object`)
  } : { success: !0, value: n };
}
sr.unknown = Uf;
Object.defineProperty(qr, "__esModule", { value: !0 });
qr.validateOneOf = qr.object = qr.array = qr.validate = void 0;
const yi = Tn, Fu = wi, tx = Yl, oa = sr;
function Of(t, e, r, n) {
  switch (r.type) {
    case "boolean":
      return (0, oa.boolean)(t, e, r, n);
    case "integer":
      return (0, oa.integer)(t, e, r, n);
    case "string":
      return (0, oa.string)(t, e, r, n);
    case "bytes":
      return (0, oa.bytes)(t, e, r, n);
    case "cid-link":
      return (0, oa.cidLink)(t, e, r, n);
    case "unknown":
      return (0, oa.unknown)(t, e, r, n);
    case "object":
      return ic(t, e, r, n);
    case "array":
      return Kf(t, e, r, n);
    case "blob":
      return (0, tx.blob)(t, e, r, n);
    default:
      return {
        success: !1,
        error: new yi.ValidationError(`Unexpected lexicon type: ${r.type}`)
      };
  }
}
qr.validate = Of;
function Kf(t, e, r, n) {
  if (!Array.isArray(n))
    return {
      success: !1,
      error: new yi.ValidationError(`${e} must be an array`)
    };
  if (typeof r.maxLength == "number" && n.length > r.maxLength)
    return {
      success: !1,
      error: new yi.ValidationError(`${e} must not have more than ${r.maxLength} elements`)
    };
  if (typeof r.minLength == "number" && n.length < r.minLength)
    return {
      success: !1,
      error: new yi.ValidationError(`${e} must not have fewer than ${r.minLength} elements`)
    };
  const u = r.items;
  for (let y = 0; y < n.length; y++) {
    const b = n[y], h = `${e}/${y}`, d = nc(t, h, u, b);
    if (!d.success)
      return d;
  }
  return { success: !0, value: n };
}
qr.array = Kf;
function ic(t, e, r, n) {
  if (r = r, !n || typeof n != "object")
    return {
      success: !1,
      error: new yi.ValidationError(`${e} must be an object`)
    };
  const u = new Set(r.required), y = new Set(r.nullable);
  let b = n;
  if (typeof r.properties == "object")
    for (const h in r.properties) {
      if (n[h] === null && y.has(h))
        continue;
      const d = r.properties[h];
      if (typeof n[h] > "u" && !u.has(h))
        if (d.type === "integer" || d.type === "boolean" || d.type === "string") {
          if (typeof d.default > "u")
            continue;
        } else
          continue;
      const m = `${e}/${h}`, p = nc(t, m, d, n[h]), _ = p.success ? p.value : n[h], B = typeof _ > "u";
      if (B && u.has(h))
        return {
          success: !1,
          error: new yi.ValidationError(`${e} must have the property "${h}"`)
        };
      if (!B && !p.success)
        return p;
      _ !== n[h] && (b === n && (b = { ...n }), b[h] = _);
    }
  return { success: !0, value: b };
}
qr.object = ic;
function nc(t, e, r, n, u = !1) {
  let y, b;
  if (r.type === "union") {
    if (!(0, yi.isDiscriminatedObject)(n))
      return {
        success: !1,
        error: new yi.ValidationError(`${e} must be an object which includes the "$type" property`)
      };
    if (rx(r.refs, n.$type))
      b = (0, Fu.toConcreteTypes)(t, {
        type: "ref",
        ref: n.$type
      });
    else
      return r.closed ? {
        success: !1,
        error: new yi.ValidationError(`${e} $type must be one of ${r.refs.join(", ")}`)
      } : { success: !0, value: n };
  } else
    b = (0, Fu.toConcreteTypes)(t, r);
  for (const h of b) {
    const d = u ? ic(t, e, h, n) : Of(t, e, h, n);
    if (d.success)
      return d;
    y ?? (y = d.error);
  }
  return b.length > 1 ? {
    success: !1,
    error: new yi.ValidationError(`${e} did not match any of the expected definitions`)
  } : { success: !1, error: y };
}
qr.validateOneOf = nc;
const rx = (t, e) => {
  const r = (0, Fu.toLexUri)(e);
  return t.includes(r) ? !0 : r.endsWith("#main") ? t.includes(r.replace("#main", "")) : t.includes(r + "#main");
};
var eu = {}, ix = de && de.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, u);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), nx = de && de.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), ax = de && de.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && ix(e, t, r);
  return nx(e, t), e;
};
Object.defineProperty(eu, "__esModule", { value: !0 });
eu.params = void 0;
const sx = Tn, ox = ax(sr), lx = qr;
function ux(t, e, r, n) {
  const u = n && typeof n == "object" ? n : {}, y = new Set(r.required ?? []);
  let b = u;
  if (typeof r.properties == "object")
    for (const h in r.properties) {
      const d = r.properties[h], m = d.type === "array" ? (0, lx.array)(t, h, d, u[h]) : ox.validate(t, h, d, u[h]), p = m.success ? m.value : u[h], _ = typeof p > "u";
      if (_ && y.has(h))
        return {
          success: !1,
          error: new sx.ValidationError(`${e} must have the property "${h}"`)
        };
      if (!_ && !m.success)
        return m;
      p !== u[h] && (b === u && (b = { ...u }), b[h] = p);
    }
  return { success: !0, value: b };
}
eu.params = ux;
Object.defineProperty($r, "__esModule", { value: !0 });
$r.assertValidXrpcMessage = $r.assertValidXrpcOutput = $r.assertValidXrpcInput = $r.assertValidXrpcParams = $r.assertValidRecord = void 0;
const Mf = qr, cx = eu;
function dx(t, e, r) {
  const n = (0, Mf.object)(t, "Record", e.record, r);
  if (!n.success)
    throw n.error;
  return n.value;
}
$r.assertValidRecord = dx;
function fx(t, e, r) {
  if (e.parameters) {
    const n = (0, cx.params)(t, "Params", e.parameters, r);
    if (!n.success)
      throw n.error;
    return n.value;
  }
}
$r.assertValidXrpcParams = fx;
function px(t, e, r) {
  if (e.input?.schema)
    return ac(t, "Input", e.input.schema, r, !0);
}
$r.assertValidXrpcInput = px;
function hx(t, e, r) {
  if (e.output?.schema)
    return ac(t, "Output", e.output.schema, r, !0);
}
$r.assertValidXrpcOutput = hx;
function mx(t, e, r) {
  if (e.message?.schema)
    return ac(t, "Message", e.message.schema, r, !0);
}
$r.assertValidXrpcMessage = mx;
function ac(t, e, r, n, u = !1) {
  const y = (0, Mf.validateOneOf)(t, e, r, n, u);
  if (!y.success)
    throw y.error;
  return y.value;
}
var yx = de && de.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, u);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), bx = de && de.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), gx = de && de.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && yx(e, t, r);
  return bx(e, t), e;
};
Object.defineProperty(Wl, "__esModule", { value: !0 });
Wl.Lexicons = void 0;
const ci = Tn, $a = $r, cr = wi, zc = gx(qr);
class xx {
  constructor(e) {
    if (Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "defs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), e)
      for (const r of e)
        this.add(r);
  }
  /**
   * @example clone a lexicon:
   * ```ts
   * const clone = new Lexicons(originalLexicon)
   * ```
   *
   * @example get docs array:
   * ```ts
   * const docs = Array.from(lexicons)
   * ```
   */
  [Symbol.iterator]() {
    return this.docs.values();
  }
  /**
   * Add a lexicon doc.
   */
  add(e) {
    const r = (0, cr.toLexUri)(e.id);
    if (this.docs.has(r))
      throw new Error(`${r} has already been registered`);
    $u(e, r), this.docs.set(r, e);
    for (const [n, u] of Hc(e))
      this.defs.set(n, u);
  }
  /**
   * Remove a lexicon doc.
   */
  remove(e) {
    e = (0, cr.toLexUri)(e);
    const r = this.docs.get(e);
    if (!r)
      throw new Error(`Unable to remove "${e}": does not exist`);
    for (const [n, u] of Hc(r))
      this.defs.delete(n);
    this.docs.delete(e);
  }
  /**
   * Get a lexicon doc.
   */
  get(e) {
    return e = (0, cr.toLexUri)(e), this.docs.get(e);
  }
  /**
   * Get a definition.
   */
  getDef(e) {
    return e = (0, cr.toLexUri)(e), this.defs.get(e);
  }
  getDefOrThrow(e, r) {
    const n = this.getDef(e);
    if (!n)
      throw new ci.LexiconDefNotFoundError(`Lexicon not found: ${e}`);
    if (r && !r.includes(n.type))
      throw new ci.InvalidLexiconError(`Not a ${r.join(" or ")} lexicon: ${e}`);
    return n;
  }
  /**
   * Validate a record or object.
   */
  validate(e, r) {
    e = (0, cr.toLexUri)(e);
    const n = this.getDefOrThrow(e, ["record", "object"]);
    if (!(0, ci.isObj)(r))
      throw new ci.ValidationError("Value must be an object");
    if (n.type === "record")
      return zc.object(this, "Record", n.record, r);
    if (n.type === "object")
      return zc.object(this, "Object", n, r);
    throw new ci.InvalidLexiconError("Definition must be a record or object");
  }
  /**
   * Validate a record and throw on any error.
   */
  assertValidRecord(e, r) {
    e = (0, cr.toLexUri)(e);
    const n = this.getDefOrThrow(e, ["record"]);
    if (!(0, ci.isObj)(r))
      throw new ci.ValidationError("Record must be an object");
    if (!(0, ci.hasProp)(r, "$type") || typeof r.$type != "string")
      throw new ci.ValidationError("Record/$type must be a string");
    const u = r.$type || "";
    if ((0, cr.toLexUri)(u) !== e)
      throw new ci.ValidationError(`Invalid $type: must be ${e}, got ${u}`);
    return (0, $a.assertValidRecord)(this, n, r);
  }
  /**
   * Validate xrpc query params and throw on any error.
   */
  assertValidXrpcParams(e, r) {
    e = (0, cr.toLexUri)(e);
    const n = this.getDefOrThrow(e, [
      "query",
      "procedure",
      "subscription"
    ]);
    return (0, $a.assertValidXrpcParams)(this, n, r);
  }
  /**
   * Validate xrpc input body and throw on any error.
   */
  assertValidXrpcInput(e, r) {
    e = (0, cr.toLexUri)(e);
    const n = this.getDefOrThrow(e, ["procedure"]);
    return (0, $a.assertValidXrpcInput)(this, n, r);
  }
  /**
   * Validate xrpc output body and throw on any error.
   */
  assertValidXrpcOutput(e, r) {
    e = (0, cr.toLexUri)(e);
    const n = this.getDefOrThrow(e, ["query", "procedure"]);
    return (0, $a.assertValidXrpcOutput)(this, n, r);
  }
  /**
   * Validate xrpc subscription message and throw on any error.
   */
  assertValidXrpcMessage(e, r) {
    e = (0, cr.toLexUri)(e);
    const n = this.getDefOrThrow(e, ["subscription"]);
    return (0, $a.assertValidXrpcMessage)(this, n, r);
  }
  /**
   * Resolve a lex uri given a ref
   */
  resolveLexUri(e, r) {
    return e = (0, cr.toLexUri)(e), (0, cr.toLexUri)(r, e);
  }
}
Wl.Lexicons = xx;
function* Hc(t) {
  for (const e in t.defs)
    yield [`lex:${t.id}#${e}`, t.defs[e]], e === "main" && (yield [`lex:${t.id}`, t.defs[e]]);
}
function $u(t, e) {
  for (const r in t)
    t.type === "ref" ? t.ref = (0, cr.toLexUri)(t.ref, e) : t.type === "union" ? t.refs = t.refs.map((n) => (0, cr.toLexUri)(n, e)) : Array.isArray(t[r]) ? t[r] = t[r].map((n) => typeof n == "string" ? n.startsWith("#") ? (0, cr.toLexUri)(n, e) : n : n && typeof n == "object" ? $u(n, e) : n) : t[r] && typeof t[r] == "object" && (t[r] = $u(t[r], e));
  return t;
}
var Nf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.jsonStringToLex = t.jsonToLex = t.stringifyLex = t.lexToJson = t.ipldToLex = t.lexToIpld = void 0;
  const e = Pi, r = Pa, n = Jl, u = (p) => {
    if (Array.isArray(p))
      return p.map((_) => (0, t.lexToIpld)(_));
    if (p && typeof p == "object") {
      if (p instanceof n.BlobRef)
        return p.original;
      if (r.CID.asCID(p) || p instanceof Uint8Array)
        return p;
      const _ = {};
      for (const B of Object.keys(p))
        _[B] = (0, t.lexToIpld)(p[B]);
      return _;
    }
    return p;
  };
  t.lexToIpld = u;
  const y = (p) => {
    if (Array.isArray(p))
      return p.map((_) => (0, t.ipldToLex)(_));
    if (p && typeof p == "object") {
      if ((p.$type === "blob" || typeof p.cid == "string" && typeof p.mimeType == "string") && e.check.is(p, n.jsonBlobRef))
        return n.BlobRef.fromJsonRef(p);
      if (r.CID.asCID(p) || p instanceof Uint8Array)
        return p;
      const _ = {};
      for (const B of Object.keys(p))
        _[B] = (0, t.ipldToLex)(p[B]);
      return _;
    }
    return p;
  };
  t.ipldToLex = y;
  const b = (p) => (0, e.ipldToJson)((0, t.lexToIpld)(p));
  t.lexToJson = b;
  const h = (p) => JSON.stringify((0, t.lexToJson)(p));
  t.stringifyLex = h;
  const d = (p) => (0, t.ipldToLex)((0, e.jsonToIpld)(p));
  t.jsonToLex = d;
  const m = (p) => (0, t.jsonToLex)(JSON.parse(p));
  t.jsonStringToLex = m;
})(Nf);
(function(t) {
  var e = de && de.__createBinding || (Object.create ? function(n, u, y, b) {
    b === void 0 && (b = y);
    var h = Object.getOwnPropertyDescriptor(u, y);
    (!h || ("get" in h ? !u.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return u[y];
    } }), Object.defineProperty(n, b, h);
  } : function(n, u, y, b) {
    b === void 0 && (b = y), n[b] = u[y];
  }), r = de && de.__exportStar || function(n, u) {
    for (var y in n) y !== "default" && !Object.prototype.hasOwnProperty.call(u, y) && e(u, n, y);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Tn, t), r(Wl, t), r(Jl, t), r(Nf, t);
})(es);
var Vf = {};
Object.defineProperty(Vf, "__esModule", { value: !0 });
var ns = {};
Object.defineProperty(ns, "__esModule", { value: !0 });
ns.BSKY_LABELER_DID = void 0;
ns.BSKY_LABELER_DID = "did:plc:ar7c4by46qjdydhdevvrndac";
var ti = {};
Object.defineProperty(ti, "__esModule", { value: !0 });
ti.validateSavedFeed = ti.getSavedFeedType = ti.savedFeedsToUriArrays = ti.sanitizeMutedWordValue = void 0;
const jf = ra, Ex = Pi;
function vx(t) {
  return t.trim().replace(/^#(?!\ufe0f)/, "").replace(/[\r\n\u00AD\u2060\u200D\u200C\u200B]+/, "");
}
ti.sanitizeMutedWordValue = vx;
function Rx(t) {
  const e = [], r = [];
  for (const n of t)
    n.pinned && e.push(n.value), r.push(n.value);
  return {
    pinned: e,
    saved: r
  };
}
ti.savedFeedsToUriArrays = Rx;
function Ax(t) {
  switch (new jf.AtUri(t).collection) {
    case "app.bsky.feed.generator":
      return "feed";
    case "app.bsky.graph.list":
      return "list";
    default:
      return "unknown";
  }
}
ti.getSavedFeedType = Ax;
function _x(t) {
  if (new Ex.TID(t.id), ["feed", "list"].includes(t.type)) {
    const e = new jf.AtUri(t.value), r = e.collection === "app.bsky.feed.generator", n = e.collection === "app.bsky.graph.list";
    if (t.type === "feed" && !r)
      throw new Error(`Saved feed of type 'feed' must be a feed, got ${e.collection}`);
    if (t.type === "list" && !n)
      throw new Error(`Saved feed of type 'list' must be a list, got ${e.collection}`);
  }
}
ti.validateSavedFeed = _x;
var E = {}, Z = {}, tu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.XRPCInvalidResponseError = t.XRPCError = t.XRPCResponse = t.ResponseTypeStrings = t.ResponseTypeNames = t.ResponseType = t.errorResponseBody = void 0;
  const e = ia;
  t.errorResponseBody = e.z.object({
    error: e.z.string().optional(),
    message: e.z.string().optional()
  });
  var r;
  (function(b) {
    b[b.Unknown = 1] = "Unknown", b[b.InvalidResponse = 2] = "InvalidResponse", b[b.Success = 200] = "Success", b[b.InvalidRequest = 400] = "InvalidRequest", b[b.AuthRequired = 401] = "AuthRequired", b[b.Forbidden = 403] = "Forbidden", b[b.XRPCNotSupported = 404] = "XRPCNotSupported", b[b.PayloadTooLarge = 413] = "PayloadTooLarge", b[b.RateLimitExceeded = 429] = "RateLimitExceeded", b[b.InternalServerError = 500] = "InternalServerError", b[b.MethodNotImplemented = 501] = "MethodNotImplemented", b[b.UpstreamFailure = 502] = "UpstreamFailure", b[b.NotEnoughResources = 503] = "NotEnoughResources", b[b.UpstreamTimeout = 504] = "UpstreamTimeout";
  })(r || (t.ResponseType = r = {})), t.ResponseTypeNames = {
    [r.InvalidResponse]: "InvalidResponse",
    [r.Success]: "Success",
    [r.InvalidRequest]: "InvalidRequest",
    [r.AuthRequired]: "AuthenticationRequired",
    [r.Forbidden]: "Forbidden",
    [r.XRPCNotSupported]: "XRPCNotSupported",
    [r.PayloadTooLarge]: "PayloadTooLarge",
    [r.RateLimitExceeded]: "RateLimitExceeded",
    [r.InternalServerError]: "InternalServerError",
    [r.MethodNotImplemented]: "MethodNotImplemented",
    [r.UpstreamFailure]: "UpstreamFailure",
    [r.NotEnoughResources]: "NotEnoughResources",
    [r.UpstreamTimeout]: "UpstreamTimeout"
  }, t.ResponseTypeStrings = {
    [r.InvalidResponse]: "Invalid Response",
    [r.Success]: "Success",
    [r.InvalidRequest]: "Invalid Request",
    [r.AuthRequired]: "Authentication Required",
    [r.Forbidden]: "Forbidden",
    [r.XRPCNotSupported]: "XRPC Not Supported",
    [r.PayloadTooLarge]: "Payload Too Large",
    [r.RateLimitExceeded]: "Rate Limit Exceeded",
    [r.InternalServerError]: "Internal Server Error",
    [r.MethodNotImplemented]: "Method Not Implemented",
    [r.UpstreamFailure]: "Upstream Failure",
    [r.NotEnoughResources]: "Not Enough Resources",
    [r.UpstreamTimeout]: "Upstream Timeout"
  };
  class n {
    constructor(h, d) {
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: h
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: d
      }), Object.defineProperty(this, "success", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !0
      });
    }
  }
  t.XRPCResponse = n;
  class u extends Error {
    constructor(h, d, m, p) {
      super(m || d || t.ResponseTypeStrings[h]), Object.defineProperty(this, "status", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: h
      }), Object.defineProperty(this, "error", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: d
      }), Object.defineProperty(this, "success", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.error || (this.error = t.ResponseTypeNames[h]), this.headers = p;
    }
  }
  t.XRPCError = u;
  class y extends u {
    constructor(h, d, m) {
      super(r.InvalidResponse, t.ResponseTypeStrings[r.InvalidResponse], "The server gave an invalid response and may be out of date."), Object.defineProperty(this, "lexiconNsid", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: h
      }), Object.defineProperty(this, "validationError", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: d
      }), Object.defineProperty(this, "responseBody", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: m
      });
    }
  }
  t.XRPCInvalidResponseError = y;
})(tu);
var Hi = {}, Zt = {};
Object.defineProperty(Zt, "__esModule", { value: !0 });
Zt.httpResponseBodyParse = Zt.httpResponseCodeToEnum = Zt.encodeMethodCallBody = Zt.constructMethodCallHeaders = Zt.normalizeHeaders = Zt.encodeQueryParam = Zt.constructMethodCallUri = Zt.getMethodSchemaHTTPMethod = void 0;
const Ff = es, hi = tu;
function wx(t) {
  return t.type === "procedure" ? "post" : "get";
}
Zt.getMethodSchemaHTTPMethod = wx;
function Tx(t, e, r, n) {
  const u = new URL(r);
  if (u.pathname = `/xrpc/${t}`, n)
    for (const [y, b] of Object.entries(n)) {
      const h = e.parameters?.properties?.[y];
      if (!h)
        throw new Error(`Invalid query parameter: ${y}`);
      b !== void 0 && (h.type === "array" ? [].concat(b).forEach((m) => {
        u.searchParams.append(y, Gu(h.items.type, m));
      }) : u.searchParams.set(y, Gu(h.type, b)));
    }
  return u.toString();
}
Zt.constructMethodCallUri = Tx;
function Gu(t, e) {
  if (t === "string" || t === "unknown")
    return String(e);
  if (t === "float")
    return String(Number(e));
  if (t === "integer")
    return String(Number(e) | 0);
  if (t === "boolean")
    return e ? "true" : "false";
  if (t === "datetime")
    return e instanceof Date ? e.toISOString() : String(e);
  throw new Error(`Unsupported query param type: ${t}`);
}
Zt.encodeQueryParam = Gu;
function Sx(t) {
  const e = {};
  for (const [r, n] of Object.entries(t))
    e[r.toLowerCase()] = n;
  return e;
}
Zt.normalizeHeaders = Sx;
function Cx(t, e, r) {
  const n = r?.headers || {};
  return t.type === "procedure" && (r?.encoding && (n["Content-Type"] = r.encoding), e && typeof e == "object" && (n["Content-Type"] || (n["Content-Type"] = "application/json"))), n;
}
Zt.constructMethodCallHeaders = Cx;
function Lx(t, e) {
  if (!(!t["content-type"] || typeof e > "u"))
    return e instanceof ArrayBuffer ? e : t["content-type"].startsWith("text/") ? new TextEncoder().encode(e.toString()) : t["content-type"].startsWith("application/json") ? new TextEncoder().encode((0, Ff.stringifyLex)(e)) : e;
}
Zt.encodeMethodCallBody = Lx;
function kx(t) {
  let e;
  return t in hi.ResponseType ? e = t : t >= 100 && t < 200 ? e = hi.ResponseType.XRPCNotSupported : t >= 200 && t < 300 ? e = hi.ResponseType.Success : t >= 300 && t < 400 ? e = hi.ResponseType.XRPCNotSupported : t >= 400 && t < 500 ? e = hi.ResponseType.InvalidRequest : e = hi.ResponseType.InternalServerError, e;
}
Zt.httpResponseCodeToEnum = kx;
function Dx(t, e) {
  if (t) {
    if (t.includes("application/json") && e?.byteLength)
      try {
        const r = new TextDecoder().decode(e);
        return (0, Ff.jsonStringToLex)(r);
      } catch (r) {
        throw new hi.XRPCError(hi.ResponseType.InvalidResponse, `Failed to parse response body: ${String(r)}`);
      }
    if (t.startsWith("text/") && e?.byteLength)
      try {
        return new TextDecoder().decode(e);
      } catch (r) {
        throw new hi.XRPCError(hi.ResponseType.InvalidResponse, `Failed to parse response body: ${String(r)}`);
      }
  }
  return e instanceof ArrayBuffer ? new Uint8Array(e) : e;
}
Zt.httpResponseBodyParse = Dx;
Object.defineProperty(Hi, "__esModule", { value: !0 });
Hi.defaultFetchHandler = Hi.ServiceClient = Hi.Client = void 0;
const $f = es, In = Zt, bn = tu;
class Px {
  constructor() {
    Object.defineProperty(this, "fetch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: qf
    }), Object.defineProperty(this, "lex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $f.Lexicons()
    });
  }
  // method calls
  //
  async call(e, r, n, u, y) {
    return this.service(e).call(r, n, u, y);
  }
  service(e) {
    return new Gf(this, e);
  }
  // schemas
  // =
  addLexicon(e) {
    this.lex.add(e);
  }
  addLexicons(e) {
    for (const r of e)
      this.addLexicon(r);
  }
  removeLexicon(e) {
    this.lex.remove(e);
  }
}
Hi.Client = Px;
class Gf {
  constructor(e, r) {
    Object.defineProperty(this, "baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uri", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this.baseClient = e, this.uri = typeof r == "string" ? new URL(r) : r;
  }
  setHeader(e, r) {
    this.headers[e] = r;
  }
  unsetHeader(e) {
    delete this.headers[e];
  }
  async call(e, r, n, u) {
    const y = this.baseClient.lex.getDefOrThrow(e);
    if (!y || y.type !== "query" && y.type !== "procedure")
      throw new Error(`Invalid lexicon: ${e}. Must be a query or procedure.`);
    const b = (0, In.getMethodSchemaHTTPMethod)(y), h = (0, In.constructMethodCallUri)(e, y, this.uri, r), d = (0, In.constructMethodCallHeaders)(y, n, {
      headers: {
        ...this.headers,
        ...u?.headers
      },
      encoding: u?.encoding
    }), m = await this.baseClient.fetch(h, b, d, n), p = (0, In.httpResponseCodeToEnum)(m.status);
    if (p === bn.ResponseType.Success) {
      try {
        this.baseClient.lex.assertValidXrpcOutput(e, m.body);
      } catch (_) {
        throw _ instanceof $f.ValidationError ? new bn.XRPCInvalidResponseError(e, _, m.body) : _;
      }
      return new bn.XRPCResponse(m.body, m.headers);
    } else
      throw m.body && Bx(m.body) ? new bn.XRPCError(p, m.body.error, m.body.message, m.headers) : new bn.XRPCError(p);
  }
}
Hi.ServiceClient = Gf;
async function qf(t, e, r, n) {
  try {
    const u = (0, In.normalizeHeaders)(r), y = {
      method: e,
      headers: u,
      body: (0, In.encodeMethodCallBody)(u, n),
      duplex: "half"
    }, b = await fetch(t, y), h = await b.arrayBuffer();
    return {
      status: b.status,
      headers: Object.fromEntries(b.headers.entries()),
      body: (0, In.httpResponseBodyParse)(b.headers.get("content-type"), h)
    };
  } catch (u) {
    throw new bn.XRPCError(bn.ResponseType.Unknown, String(u));
  }
}
Hi.defaultFetchHandler = qf;
function Bx(t) {
  return bn.errorResponseBody.safeParse(t).success;
}
(function(t) {
  var e = de && de.__createBinding || (Object.create ? function(y, b, h, d) {
    d === void 0 && (d = h);
    var m = Object.getOwnPropertyDescriptor(b, h);
    (!m || ("get" in m ? !b.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return b[h];
    } }), Object.defineProperty(y, d, m);
  } : function(y, b, h, d) {
    d === void 0 && (d = h), y[d] = b[h];
  }), r = de && de.__exportStar || function(y, b) {
    for (var h in y) h !== "default" && !Object.prototype.hasOwnProperty.call(b, h) && e(b, y, h);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(tu, t), r(Hi, t);
  const n = Hi, u = new n.Client();
  t.default = u;
})(Z);
var Ie = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ids = t.lexicons = t.schemas = t.schemaDict = void 0;
  const e = es;
  t.schemaDict = {
    ComAtprotoAdminDefs: {
      lexicon: 1,
      id: "com.atproto.admin.defs",
      defs: {
        statusAttr: {
          type: "object",
          required: ["applied"],
          properties: {
            applied: {
              type: "boolean"
            },
            ref: {
              type: "string"
            }
          }
        },
        accountView: {
          type: "object",
          required: ["did", "handle", "indexedAt"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invites: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              }
            },
            invitesDisabled: {
              type: "boolean"
            },
            emailConfirmedAt: {
              type: "string",
              format: "datetime"
            },
            inviteNote: {
              type: "string"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoRef: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        repoBlobRef: {
          type: "object",
          required: ["did", "cid"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            recordUri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    ComAtprotoAdminDeleteAccount: {
      lexicon: 1,
      id: "com.atproto.admin.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a user account as an administrator.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminDisableAccountInvites: {
      lexicon: 1,
      id: "com.atproto.admin.disableAccountInvites",
      defs: {
        main: {
          type: "procedure",
          description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "string",
                  format: "did"
                },
                note: {
                  type: "string",
                  description: "Optional reason for disabled invites."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminDisableInviteCodes: {
      lexicon: 1,
      id: "com.atproto.admin.disableInviteCodes",
      defs: {
        main: {
          type: "procedure",
          description: "Disable some set of codes and/or all codes associated with a set of users.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                accounts: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminEnableAccountInvites: {
      lexicon: 1,
      id: "com.atproto.admin.enableAccountInvites",
      defs: {
        main: {
          type: "procedure",
          description: "Re-enable an account's ability to receive invite codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "string",
                  format: "did"
                },
                note: {
                  type: "string",
                  description: "Optional reason for enabled invites."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetAccountInfo: {
      lexicon: 1,
      id: "com.atproto.admin.getAccountInfo",
      defs: {
        main: {
          type: "query",
          description: "Get details about an account.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:com.atproto.admin.defs#accountView"
            }
          }
        }
      }
    },
    ComAtprotoAdminGetAccountInfos: {
      lexicon: 1,
      id: "com.atproto.admin.getAccountInfos",
      defs: {
        main: {
          type: "query",
          description: "Get details about some accounts.",
          parameters: {
            type: "params",
            required: ["dids"],
            properties: {
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["infos"],
              properties: {
                infos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#accountView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetInviteCodes: {
      lexicon: 1,
      id: "com.atproto.admin.getInviteCodes",
      defs: {
        main: {
          type: "query",
          description: "Get an admin view of invite codes.",
          parameters: {
            type: "params",
            properties: {
              sort: {
                type: "string",
                knownValues: ["recent", "usage"],
                default: "recent"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 500,
                default: 100
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                cursor: {
                  type: "string"
                },
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetSubjectStatus: {
      lexicon: 1,
      id: "com.atproto.admin.getSubjectStatus",
      defs: {
        main: {
          type: "query",
          description: "Get the service-specific admin status of a subject (account, record, or blob).",
          parameters: {
            type: "params",
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              uri: {
                type: "string",
                format: "at-uri"
              },
              blob: {
                type: "string",
                format: "cid"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                },
                deactivated: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminSearchAccounts: {
      lexicon: 1,
      id: "com.atproto.admin.searchAccounts",
      defs: {
        main: {
          type: "query",
          description: "Get list of accounts that matches your search query.",
          parameters: {
            type: "params",
            properties: {
              email: {
                type: "string"
              },
              cursor: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accounts"],
              properties: {
                cursor: {
                  type: "string"
                },
                accounts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#accountView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminSendEmail: {
      lexicon: 1,
      id: "com.atproto.admin.sendEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Send email to a user's account email address.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["recipientDid", "content", "senderDid"],
              properties: {
                recipientDid: {
                  type: "string",
                  format: "did"
                },
                content: {
                  type: "string"
                },
                subject: {
                  type: "string"
                },
                senderDid: {
                  type: "string",
                  format: "did"
                },
                comment: {
                  type: "string",
                  description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["sent"],
              properties: {
                sent: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountEmail: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an account's email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account", "email"],
              properties: {
                account: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                },
                email: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountHandle: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountHandle",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an account's handle.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountPassword: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Update the password for a user account as an administrator.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "password"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                password: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateSubjectStatus: {
      lexicon: 1,
      id: "com.atproto.admin.updateSubjectStatus",
      defs: {
        main: {
          type: "procedure",
          description: "Update the service-specific admin status of a subject (account, record, or blob).",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                },
                deactivated: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityGetRecommendedDidCredentials: {
      lexicon: 1,
      id: "com.atproto.identity.getRecommendedDidCredentials",
      defs: {
        main: {
          type: "query",
          description: "Describe the credentials that should be included in the DID doc of an account that is migrating to this service.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                rotationKeys: {
                  description: "Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs.",
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                alsoKnownAs: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                verificationMethods: {
                  type: "unknown"
                },
                services: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityRequestPlcOperationSignature: {
      lexicon: 1,
      id: "com.atproto.identity.requestPlcOperationSignature",
      defs: {
        main: {
          type: "procedure",
          description: "Request an email with a code to in order to request a signed PLC operation. Requires Auth."
        }
      }
    },
    ComAtprotoIdentityResolveHandle: {
      lexicon: 1,
      id: "com.atproto.identity.resolveHandle",
      defs: {
        main: {
          type: "query",
          description: "Resolves a handle (domain name) to a DID.",
          parameters: {
            type: "params",
            required: ["handle"],
            properties: {
              handle: {
                type: "string",
                format: "handle",
                description: "The handle to resolve."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentitySignPlcOperation: {
      lexicon: 1,
      id: "com.atproto.identity.signPlcOperation",
      defs: {
        main: {
          type: "procedure",
          description: "Signs a PLC operation to update some value(s) in the requesting DID's document.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                token: {
                  description: "A token received through com.atproto.identity.requestPlcOperationSignature",
                  type: "string"
                },
                rotationKeys: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                alsoKnownAs: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                verificationMethods: {
                  type: "unknown"
                },
                services: {
                  type: "unknown"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["operation"],
              properties: {
                operation: {
                  type: "unknown",
                  description: "A signed DID PLC operation."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentitySubmitPlcOperation: {
      lexicon: 1,
      id: "com.atproto.identity.submitPlcOperation",
      defs: {
        main: {
          type: "procedure",
          description: "Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["operation"],
              properties: {
                operation: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityUpdateHandle: {
      lexicon: 1,
      id: "com.atproto.identity.updateHandle",
      defs: {
        main: {
          type: "procedure",
          description: "Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle",
                  description: "The new handle."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoLabelDefs: {
      lexicon: 1,
      id: "com.atproto.label.defs",
      defs: {
        label: {
          type: "object",
          description: "Metadata tag on an atproto resource (eg, repo or record).",
          required: ["src", "uri", "val", "cts"],
          properties: {
            ver: {
              type: "integer",
              description: "The AT Protocol version of the label object."
            },
            src: {
              type: "string",
              format: "did",
              description: "DID of the actor who created this label."
            },
            uri: {
              type: "string",
              format: "uri",
              description: "AT URI of the record, repository (account), or other resource that this label applies to."
            },
            cid: {
              type: "string",
              format: "cid",
              description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
            },
            val: {
              type: "string",
              maxLength: 128,
              description: "The short string name of the value or type of this label."
            },
            neg: {
              type: "boolean",
              description: "If true, this is a negation label, overwriting a previous label."
            },
            cts: {
              type: "string",
              format: "datetime",
              description: "Timestamp when this label was created."
            },
            exp: {
              type: "string",
              format: "datetime",
              description: "Timestamp at which this label expires (no longer applies)."
            },
            sig: {
              type: "bytes",
              description: "Signature of dag-cbor encoded label."
            }
          }
        },
        selfLabels: {
          type: "object",
          description: "Metadata tags on an atproto record, published by the author within the record.",
          required: ["values"],
          properties: {
            values: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#selfLabel"
              },
              maxLength: 10
            }
          }
        },
        selfLabel: {
          type: "object",
          description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
          required: ["val"],
          properties: {
            val: {
              type: "string",
              maxLength: 128,
              description: "The short string name of the value or type of this label."
            }
          }
        },
        labelValueDefinition: {
          type: "object",
          description: "Declares a label value and its expected interpretations and behaviors.",
          required: ["identifier", "severity", "blurs", "locales"],
          properties: {
            identifier: {
              type: "string",
              description: "The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).",
              maxLength: 100,
              maxGraphemes: 100
            },
            severity: {
              type: "string",
              description: "How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing.",
              knownValues: ["inform", "alert", "none"]
            },
            blurs: {
              type: "string",
              description: "What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing.",
              knownValues: ["content", "media", "none"]
            },
            defaultSetting: {
              type: "string",
              description: "The default setting for this label.",
              knownValues: ["ignore", "warn", "hide"],
              default: "warn"
            },
            adultOnly: {
              type: "boolean",
              description: "Does the user need to have adult content enabled in order to configure this label?"
            },
            locales: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValueDefinitionStrings"
              }
            }
          }
        },
        labelValueDefinitionStrings: {
          type: "object",
          description: "Strings which describe the label in the UI, localized into a specific language.",
          required: ["lang", "name", "description"],
          properties: {
            lang: {
              type: "string",
              description: "The code of the language these strings are written in.",
              format: "language"
            },
            name: {
              type: "string",
              description: "A short human-readable name for the label.",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              description: "A longer description of what the label means and why it might be applied.",
              maxGraphemes: 1e4,
              maxLength: 1e5
            }
          }
        },
        labelValue: {
          type: "string",
          knownValues: [
            "!hide",
            "!no-promote",
            "!warn",
            "!no-unauthenticated",
            "dmca-violation",
            "doxxing",
            "porn",
            "sexual",
            "nudity",
            "nsfl",
            "gore"
          ]
        }
      }
    },
    ComAtprotoLabelQueryLabels: {
      lexicon: 1,
      id: "com.atproto.label.queryLabels",
      defs: {
        main: {
          type: "query",
          description: "Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth.",
          parameters: {
            type: "params",
            required: ["uriPatterns"],
            properties: {
              uriPatterns: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
              },
              sources: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                },
                description: "Optional list of label sources (DIDs) to filter on."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 250,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["labels"],
              properties: {
                cursor: {
                  type: "string"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoLabelSubscribeLabels: {
      lexicon: 1,
      id: "com.atproto.label.subscribeLabels",
      defs: {
        main: {
          type: "subscription",
          description: "Subscribe to stream of labels (and negations). Public endpoint implemented by mod services. Uses same sequencing scheme as repo event stream.",
          parameters: {
            type: "params",
            properties: {
              cursor: {
                type: "integer",
                description: "The last known event seq number to backfill from."
              }
            }
          },
          message: {
            schema: {
              type: "union",
              refs: [
                "lex:com.atproto.label.subscribeLabels#labels",
                "lex:com.atproto.label.subscribeLabels#info"
              ]
            }
          },
          errors: [
            {
              name: "FutureCursor"
            }
          ]
        },
        labels: {
          type: "object",
          required: ["seq", "labels"],
          properties: {
            seq: {
              type: "integer"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        info: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              type: "string",
              knownValues: ["OutdatedCursor"]
            },
            message: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoModerationCreateReport: {
      lexicon: 1,
      id: "com.atproto.moderation.createReport",
      defs: {
        main: {
          type: "procedure",
          description: "Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["reasonType", "subject"],
              properties: {
                reasonType: {
                  type: "ref",
                  description: "Indicates the broad category of violation the report is for.",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                reason: {
                  type: "string",
                  maxGraphemes: 2e3,
                  maxLength: 2e4,
                  description: "Additional context about the content and violation."
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                reason: {
                  type: "string",
                  maxGraphemes: 2e3,
                  maxLength: 2e4
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoModerationDefs: {
      lexicon: 1,
      id: "com.atproto.moderation.defs",
      defs: {
        reasonType: {
          type: "string",
          knownValues: [
            "com.atproto.moderation.defs#reasonSpam",
            "com.atproto.moderation.defs#reasonViolation",
            "com.atproto.moderation.defs#reasonMisleading",
            "com.atproto.moderation.defs#reasonSexual",
            "com.atproto.moderation.defs#reasonRude",
            "com.atproto.moderation.defs#reasonOther",
            "com.atproto.moderation.defs#reasonAppeal"
          ]
        },
        reasonSpam: {
          type: "token",
          description: "Spam: frequent unwanted promotion, replies, mentions"
        },
        reasonViolation: {
          type: "token",
          description: "Direct violation of server rules, laws, terms of service"
        },
        reasonMisleading: {
          type: "token",
          description: "Misleading identity, affiliation, or content"
        },
        reasonSexual: {
          type: "token",
          description: "Unwanted or mislabeled sexual content"
        },
        reasonRude: {
          type: "token",
          description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
        },
        reasonOther: {
          type: "token",
          description: "Other: reports not falling under another report category"
        },
        reasonAppeal: {
          type: "token",
          description: "Appeal: appeal a previously taken moderation action"
        }
      }
    },
    ComAtprotoRepoApplyWrites: {
      lexicon: 1,
      id: "com.atproto.repo.applyWrites",
      defs: {
        main: {
          type: "procedure",
          description: "Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "writes"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data, for all operations."
                },
                writes: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.repo.applyWrites#create",
                      "lex:com.atproto.repo.applyWrites#update",
                      "lex:com.atproto.repo.applyWrites#delete"
                    ],
                    closed: !0
                  }
                },
                swapCommit: {
                  type: "string",
                  description: "If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap",
              description: "Indicates that the 'swapCommit' parameter did not match current commit."
            }
          ]
        },
        create: {
          type: "object",
          description: "Operation which creates a new record.",
          required: ["collection", "value"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string",
              maxLength: 15
            },
            value: {
              type: "unknown"
            }
          }
        },
        update: {
          type: "object",
          description: "Operation which updates an existing record.",
          required: ["collection", "rkey", "value"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string"
            },
            value: {
              type: "unknown"
            }
          }
        },
        delete: {
          type: "object",
          description: "Operation which deletes an existing record.",
          required: ["collection", "rkey"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoRepoCreateRecord: {
      lexicon: 1,
      id: "com.atproto.repo.createRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Create a single new repository record. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "record"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  maxLength: 15
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data."
                },
                record: {
                  type: "unknown",
                  description: "The record itself. Must contain a $type field."
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap",
              description: "Indicates that 'swapCommit' didn't match current repo commit."
            }
          ]
        }
      }
    },
    ComAtprotoRepoDeleteRecord: {
      lexicon: 1,
      id: "com.atproto.repo.deleteRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "rkey"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key."
                },
                swapRecord: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous record by CID."
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap"
            }
          ]
        }
      }
    },
    ComAtprotoRepoDescribeRepo: {
      lexicon: 1,
      id: "com.atproto.repo.describeRepo",
      defs: {
        main: {
          type: "query",
          description: "Get information about an account and repository, including the list of collections. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "handle",
                "did",
                "didDoc",
                "collections",
                "handleIsCorrect"
              ],
              properties: {
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown",
                  description: "The complete DID document for this account."
                },
                collections: {
                  type: "array",
                  description: "List of all the collections (NSIDs) for which this repo contains at least one record.",
                  items: {
                    type: "string",
                    format: "nsid"
                  }
                },
                handleIsCorrect: {
                  type: "boolean",
                  description: "Indicates if handle is currently valid (resolves bi-directionally)"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoRepoGetRecord: {
      lexicon: 1,
      id: "com.atproto.repo.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get a single record from a repository. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo", "collection", "rkey"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid",
                description: "The NSID of the record collection."
              },
              rkey: {
                type: "string",
                description: "The Record Key."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "The CID of the version of the record. If not specified, then return the most recent version."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "value"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoRepoImportRepo: {
      lexicon: 1,
      id: "com.atproto.repo.importRepo",
      defs: {
        main: {
          type: "procedure",
          description: "Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set.",
          input: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoRepoListMissingBlobs: {
      lexicon: 1,
      id: "com.atproto.repo.listMissingBlobs",
      defs: {
        main: {
          type: "query",
          description: "Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blobs"],
              properties: {
                cursor: {
                  type: "string"
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.listMissingBlobs#recordBlob"
                  }
                }
              }
            }
          }
        },
        recordBlob: {
          type: "object",
          required: ["cid", "recordUri"],
          properties: {
            cid: {
              type: "string",
              format: "cid"
            },
            recordUri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    ComAtprotoRepoListRecords: {
      lexicon: 1,
      id: "com.atproto.repo.listRecords",
      defs: {
        main: {
          type: "query",
          description: "List a range of records in a repository, matching a specific collection. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo", "collection"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid",
                description: "The NSID of the record type."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50,
                description: "The number of records to return."
              },
              cursor: {
                type: "string"
              },
              rkeyStart: {
                type: "string",
                description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
              },
              rkeyEnd: {
                type: "string",
                description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
              },
              reverse: {
                type: "boolean",
                description: "Flag to reverse the order of the returned records."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["records"],
              properties: {
                cursor: {
                  type: "string"
                },
                records: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.listRecords#record"
                  }
                }
              }
            }
          }
        },
        record: {
          type: "object",
          required: ["uri", "cid", "value"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            }
          }
        }
      }
    },
    ComAtprotoRepoPutRecord: {
      lexicon: 1,
      id: "com.atproto.repo.putRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "rkey", "record"],
              nullable: ["swapRecord"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  maxLength: 15
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data."
                },
                record: {
                  type: "unknown",
                  description: "The record to write."
                },
                swapRecord: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation"
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap"
            }
          ]
        }
      }
    },
    ComAtprotoRepoStrongRef: {
      lexicon: 1,
      id: "com.atproto.repo.strongRef",
      description: "A URI with a content-hash fingerprint.",
      defs: {
        main: {
          type: "object",
          required: ["uri", "cid"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            }
          }
        }
      }
    },
    ComAtprotoRepoUploadBlob: {
      lexicon: 1,
      id: "com.atproto.repo.uploadBlob",
      defs: {
        main: {
          type: "procedure",
          description: "Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS.",
          input: {
            encoding: "*/*"
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blob"],
              properties: {
                blob: {
                  type: "blob"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerActivateAccount: {
      lexicon: 1,
      id: "com.atproto.server.activateAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup."
        }
      }
    },
    ComAtprotoServerCheckAccountStatus: {
      lexicon: 1,
      id: "com.atproto.server.checkAccountStatus",
      defs: {
        main: {
          type: "query",
          description: "Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "activated",
                "validDid",
                "repoCommit",
                "repoRev",
                "repoBlocks",
                "indexedRecords",
                "privateStateValues",
                "expectedBlobs",
                "importedBlobs"
              ],
              properties: {
                activated: {
                  type: "boolean"
                },
                validDid: {
                  type: "boolean"
                },
                repoCommit: {
                  type: "string",
                  format: "cid"
                },
                repoRev: {
                  type: "string"
                },
                repoBlocks: {
                  type: "integer"
                },
                indexedRecords: {
                  type: "integer"
                },
                privateStateValues: {
                  type: "integer"
                },
                expectedBlobs: {
                  type: "integer"
                },
                importedBlobs: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerConfirmEmail: {
      lexicon: 1,
      id: "com.atproto.server.confirmEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email", "token"],
              properties: {
                email: {
                  type: "string"
                },
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "AccountNotFound"
            },
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            },
            {
              name: "InvalidEmail"
            }
          ]
        }
      }
    },
    ComAtprotoServerCreateAccount: {
      lexicon: 1,
      id: "com.atproto.server.createAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Create an account. Implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle"],
              properties: {
                email: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle",
                  description: "Requested handle for the account."
                },
                did: {
                  type: "string",
                  format: "did",
                  description: "Pre-existing atproto DID, being imported to a new account."
                },
                inviteCode: {
                  type: "string"
                },
                verificationCode: {
                  type: "string"
                },
                verificationPhone: {
                  type: "string"
                },
                password: {
                  type: "string",
                  description: "Initial account password. May need to meet instance-specific password strength requirements."
                },
                recoveryKey: {
                  type: "string",
                  description: "DID PLC rotation key (aka, recovery key) to be included in PLC creation operation."
                },
                plcOp: {
                  type: "unknown",
                  description: "A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              description: "Account login session returned on successful account creation.",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the new account."
                },
                didDoc: {
                  type: "unknown",
                  description: "Complete DID document."
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidHandle"
            },
            {
              name: "InvalidPassword"
            },
            {
              name: "InvalidInviteCode"
            },
            {
              name: "HandleNotAvailable"
            },
            {
              name: "UnsupportedDomain"
            },
            {
              name: "UnresolvableDid"
            },
            {
              name: "IncompatibleDidDoc"
            }
          ]
        }
      }
    },
    ComAtprotoServerCreateAppPassword: {
      lexicon: 1,
      id: "com.atproto.server.createAppPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Create an App Password.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  description: "A short name for the App Password, to help distinguish them."
                },
                privileged: {
                  type: "boolean",
                  description: "If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:com.atproto.server.createAppPassword#appPassword"
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        },
        appPassword: {
          type: "object",
          required: ["name", "password", "createdAt"],
          properties: {
            name: {
              type: "string"
            },
            password: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            privileged: {
              type: "boolean"
            }
          }
        }
      }
    },
    ComAtprotoServerCreateInviteCode: {
      lexicon: 1,
      id: "com.atproto.server.createInviteCode",
      defs: {
        main: {
          type: "procedure",
          description: "Create an invite code.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["useCount"],
              properties: {
                useCount: {
                  type: "integer"
                },
                forAccount: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["code"],
              properties: {
                code: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerCreateInviteCodes: {
      lexicon: 1,
      id: "com.atproto.server.createInviteCodes",
      defs: {
        main: {
          type: "procedure",
          description: "Create invite codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codeCount", "useCount"],
              properties: {
                codeCount: {
                  type: "integer",
                  default: 1
                },
                useCount: {
                  type: "integer"
                },
                forAccounts: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                  }
                }
              }
            }
          }
        },
        accountCodes: {
          type: "object",
          required: ["account", "codes"],
          properties: {
            account: {
              type: "string"
            },
            codes: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        }
      }
    },
    ComAtprotoServerCreateSession: {
      lexicon: 1,
      id: "com.atproto.server.createSession",
      defs: {
        main: {
          type: "procedure",
          description: "Create an authentication session.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["identifier", "password"],
              properties: {
                identifier: {
                  type: "string",
                  description: "Handle or other identifier supported by the server for the authenticating user."
                },
                password: {
                  type: "string"
                },
                authFactorToken: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown"
                },
                email: {
                  type: "string"
                },
                emailConfirmed: {
                  type: "boolean"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            },
            {
              name: "AuthFactorTokenRequired"
            }
          ]
        }
      }
    },
    ComAtprotoServerDeactivateAccount: {
      lexicon: 1,
      id: "com.atproto.server.deactivateAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                deleteAfter: {
                  type: "string",
                  format: "datetime",
                  description: "A recommendation to server as to how long they should hold onto the deactivated account before deleting."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerDefs: {
      lexicon: 1,
      id: "com.atproto.server.defs",
      defs: {
        inviteCode: {
          type: "object",
          required: [
            "code",
            "available",
            "disabled",
            "forAccount",
            "createdBy",
            "createdAt",
            "uses"
          ],
          properties: {
            code: {
              type: "string"
            },
            available: {
              type: "integer"
            },
            disabled: {
              type: "boolean"
            },
            forAccount: {
              type: "string"
            },
            createdBy: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            uses: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCodeUse"
              }
            }
          }
        },
        inviteCodeUse: {
          type: "object",
          required: ["usedBy", "usedAt"],
          properties: {
            usedBy: {
              type: "string",
              format: "did"
            },
            usedAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ComAtprotoServerDeleteAccount: {
      lexicon: 1,
      id: "com.atproto.server.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "password", "token"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                password: {
                  type: "string"
                },
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            }
          ]
        }
      }
    },
    ComAtprotoServerDeleteSession: {
      lexicon: 1,
      id: "com.atproto.server.deleteSession",
      defs: {
        main: {
          type: "procedure",
          description: "Delete the current session. Requires auth."
        }
      }
    },
    ComAtprotoServerDescribeServer: {
      lexicon: 1,
      id: "com.atproto.server.describeServer",
      defs: {
        main: {
          type: "query",
          description: "Describes the server's account creation requirements and capabilities. Implemented by PDS.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "availableUserDomains"],
              properties: {
                inviteCodeRequired: {
                  type: "boolean",
                  description: "If true, an invite code must be supplied to create an account on this instance."
                },
                phoneVerificationRequired: {
                  type: "boolean",
                  description: "If true, a phone verification token must be supplied to create an account on this instance."
                },
                availableUserDomains: {
                  type: "array",
                  description: "List of domain suffixes that can be used in account handles.",
                  items: {
                    type: "string"
                  }
                },
                links: {
                  type: "ref",
                  description: "URLs of service policy documents.",
                  ref: "lex:com.atproto.server.describeServer#links"
                },
                contact: {
                  type: "ref",
                  description: "Contact information",
                  ref: "lex:com.atproto.server.describeServer#contact"
                },
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        },
        links: {
          type: "object",
          properties: {
            privacyPolicy: {
              type: "string",
              format: "uri"
            },
            termsOfService: {
              type: "string",
              format: "uri"
            }
          }
        },
        contact: {
          type: "object",
          properties: {
            email: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoServerGetAccountInviteCodes: {
      lexicon: 1,
      id: "com.atproto.server.getAccountInviteCodes",
      defs: {
        main: {
          type: "query",
          description: "Get all invite codes for the current account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              includeUsed: {
                type: "boolean",
                default: !0
              },
              createAvailable: {
                type: "boolean",
                default: !0,
                description: "Controls whether any new 'earned' but not 'created' invites should be created."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "DuplicateCreate"
            }
          ]
        }
      }
    },
    ComAtprotoServerGetServiceAuth: {
      lexicon: 1,
      id: "com.atproto.server.getServiceAuth",
      defs: {
        main: {
          type: "query",
          description: "Get a signed token on behalf of the requesting DID for the requested service.",
          parameters: {
            type: "params",
            required: ["aud"],
            properties: {
              aud: {
                type: "string",
                format: "did",
                description: "The DID of the service that the token will be used to authenticate with"
              },
              exp: {
                type: "integer",
                description: "The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope."
              },
              lxm: {
                type: "string",
                format: "nsid",
                description: "Lexicon (XRPC) method to bind the requested token to"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["token"],
              properties: {
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "BadExpiration",
              description: "Indicates that the requested expiration date is not a valid. May be in the past or may be reliant on the requested scopes."
            }
          ]
        }
      }
    },
    ComAtprotoServerGetSession: {
      lexicon: 1,
      id: "com.atproto.server.getSession",
      defs: {
        main: {
          type: "query",
          description: "Get information about the current auth session. Requires auth.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle", "did"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                email: {
                  type: "string"
                },
                emailConfirmed: {
                  type: "boolean"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                didDoc: {
                  type: "unknown"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerListAppPasswords: {
      lexicon: 1,
      id: "com.atproto.server.listAppPasswords",
      defs: {
        main: {
          type: "query",
          description: "List all App Passwords.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["passwords"],
              properties: {
                passwords: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        },
        appPassword: {
          type: "object",
          required: ["name", "createdAt"],
          properties: {
            name: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            privileged: {
              type: "boolean"
            }
          }
        }
      }
    },
    ComAtprotoServerRefreshSession: {
      lexicon: 1,
      id: "com.atproto.server.refreshSession",
      defs: {
        main: {
          type: "procedure",
          description: "Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt').",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "Hosting status of the account. If not specified, then assume 'active'.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        }
      }
    },
    ComAtprotoServerRequestAccountDelete: {
      lexicon: 1,
      id: "com.atproto.server.requestAccountDelete",
      defs: {
        main: {
          type: "procedure",
          description: "Initiate a user account deletion via email."
        }
      }
    },
    ComAtprotoServerRequestEmailConfirmation: {
      lexicon: 1,
      id: "com.atproto.server.requestEmailConfirmation",
      defs: {
        main: {
          type: "procedure",
          description: "Request an email with a code to confirm ownership of email."
        }
      }
    },
    ComAtprotoServerRequestEmailUpdate: {
      lexicon: 1,
      id: "com.atproto.server.requestEmailUpdate",
      defs: {
        main: {
          type: "procedure",
          description: "Request a token in order to update email.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["tokenRequired"],
              properties: {
                tokenRequired: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerRequestPasswordReset: {
      lexicon: 1,
      id: "com.atproto.server.requestPasswordReset",
      defs: {
        main: {
          type: "procedure",
          description: "Initiate a user account password reset via email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email"],
              properties: {
                email: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerReserveSigningKey: {
      lexicon: 1,
      id: "com.atproto.server.reserveSigningKey",
      defs: {
        main: {
          type: "procedure",
          description: "Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID to reserve a key for."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["signingKey"],
              properties: {
                signingKey: {
                  type: "string",
                  description: "The public key for the reserved signing key, in did:key serialization."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerResetPassword: {
      lexicon: 1,
      id: "com.atproto.server.resetPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Reset a user account password using a token.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["token", "password"],
              properties: {
                token: {
                  type: "string"
                },
                password: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            }
          ]
        }
      }
    },
    ComAtprotoServerRevokeAppPassword: {
      lexicon: 1,
      id: "com.atproto.server.revokeAppPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Revoke an App Password by name.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerUpdateEmail: {
      lexicon: 1,
      id: "com.atproto.server.updateEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Update an account's email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email"],
              properties: {
                email: {
                  type: "string"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                token: {
                  type: "string",
                  description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            },
            {
              name: "TokenRequired"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetBlob: {
      lexicon: 1,
      id: "com.atproto.sync.getBlob",
      defs: {
        main: {
          type: "query",
          description: "Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did", "cid"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the account."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "The CID of the blob to fetch"
              }
            }
          },
          output: {
            encoding: "*/*"
          },
          errors: [
            {
              name: "BlobNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetBlocks: {
      lexicon: 1,
      id: "com.atproto.sync.getBlocks",
      defs: {
        main: {
          type: "query",
          description: "Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did", "cids"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              cids: {
                type: "array",
                items: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "BlockNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetCheckout: {
      lexicon: 1,
      id: "com.atproto.sync.getCheckout",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoSyncGetHead: {
      lexicon: 1,
      id: "com.atproto.sync.getHead",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "HeadNotFound"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetLatestCommit: {
      lexicon: 1,
      id: "com.atproto.sync.getLatestCommit",
      defs: {
        main: {
          type: "query",
          description: "Get the current commit CID & revision of the specified repo. Does not require auth.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["cid", "rev"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                rev: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRecord: {
      lexicon: 1,
      id: "com.atproto.sync.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth.",
          parameters: {
            type: "params",
            required: ["did", "collection", "rkey"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string",
                description: "Record Key"
              },
              commit: {
                type: "string",
                format: "cid",
                description: "DEPRECATED: referenced a repo commit by CID, and retrieved record as of that commit"
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "RecordNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRepo: {
      lexicon: 1,
      id: "com.atproto.sync.getRepo",
      defs: {
        main: {
          type: "query",
          description: "Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              since: {
                type: "string",
                description: "The revision ('rev') of the repo to create a diff from."
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRepoStatus: {
      lexicon: 1,
      id: "com.atproto.sync.getRepoStatus",
      defs: {
        main: {
          type: "query",
          description: "Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "active"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                },
                rev: {
                  type: "string",
                  description: "Optional field, the current rev of the repo, if active=true"
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            }
          ]
        }
      }
    },
    ComAtprotoSyncListBlobs: {
      lexicon: 1,
      id: "com.atproto.sync.listBlobs",
      defs: {
        main: {
          type: "query",
          description: "List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              since: {
                type: "string",
                description: "Optional revision of the repo to list blobs since."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["cids"],
              properties: {
                cursor: {
                  type: "string"
                },
                cids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncListRepos: {
      lexicon: 1,
      id: "com.atproto.sync.listRepos",
      defs: {
        main: {
          type: "query",
          description: "Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repos"],
              properties: {
                cursor: {
                  type: "string"
                },
                repos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.listRepos#repo"
                  }
                }
              }
            }
          }
        },
        repo: {
          type: "object",
          required: ["did", "head", "rev"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            head: {
              type: "string",
              format: "cid",
              description: "Current repo commit CID"
            },
            rev: {
              type: "string"
            },
            active: {
              type: "boolean"
            },
            status: {
              type: "string",
              description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
              knownValues: ["takendown", "suspended", "deactivated"]
            }
          }
        }
      }
    },
    ComAtprotoSyncNotifyOfUpdate: {
      lexicon: 1,
      id: "com.atproto.sync.notifyOfUpdate",
      defs: {
        main: {
          type: "procedure",
          description: "Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the current service (usually a PDS) that is notifying of update."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncRequestCrawl: {
      lexicon: 1,
      id: "com.atproto.sync.requestCrawl",
      defs: {
        main: {
          type: "procedure",
          description: "Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the current service (eg, PDS) that is requesting to be crawled."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncSubscribeRepos: {
      lexicon: 1,
      id: "com.atproto.sync.subscribeRepos",
      defs: {
        main: {
          type: "subscription",
          description: "Repository event stream, aka Firehose endpoint. Outputs repo commits with diff data, and identity update events, for all repositories on the current server. See the atproto specifications for details around stream sequencing, repo versioning, CAR diff format, and more. Public and does not require auth; implemented by PDS and Relay.",
          parameters: {
            type: "params",
            properties: {
              cursor: {
                type: "integer",
                description: "The last known event seq number to backfill from."
              }
            }
          },
          message: {
            schema: {
              type: "union",
              refs: [
                "lex:com.atproto.sync.subscribeRepos#commit",
                "lex:com.atproto.sync.subscribeRepos#identity",
                "lex:com.atproto.sync.subscribeRepos#account",
                "lex:com.atproto.sync.subscribeRepos#handle",
                "lex:com.atproto.sync.subscribeRepos#migrate",
                "lex:com.atproto.sync.subscribeRepos#tombstone",
                "lex:com.atproto.sync.subscribeRepos#info"
              ]
            }
          },
          errors: [
            {
              name: "FutureCursor"
            },
            {
              name: "ConsumerTooSlow",
              description: "If the consumer of the stream can not keep up with events, and a backlog gets too large, the server will drop the connection."
            }
          ]
        },
        commit: {
          type: "object",
          description: "Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature.",
          required: [
            "seq",
            "rebase",
            "tooBig",
            "repo",
            "commit",
            "rev",
            "since",
            "blocks",
            "ops",
            "blobs",
            "time"
          ],
          nullable: ["prev", "since"],
          properties: {
            seq: {
              type: "integer",
              description: "The stream sequence number of this message."
            },
            rebase: {
              type: "boolean",
              description: "DEPRECATED -- unused"
            },
            tooBig: {
              type: "boolean",
              description: "Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data."
            },
            repo: {
              type: "string",
              format: "did",
              description: "The repo this event comes from."
            },
            commit: {
              type: "cid-link",
              description: "Repo commit object CID."
            },
            prev: {
              type: "cid-link",
              description: "DEPRECATED -- unused. WARNING -- nullable and optional; stick with optional to ensure golang interoperability."
            },
            rev: {
              type: "string",
              description: "The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event."
            },
            since: {
              type: "string",
              description: "The rev of the last emitted commit from this repo (if any)."
            },
            blocks: {
              type: "bytes",
              description: "CAR file containing relevant blocks, as a diff since the previous repo state.",
              maxLength: 1e6
            },
            ops: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.sync.subscribeRepos#repoOp",
                description: "List of repo mutation operations in this commit (eg, records created, updated, or deleted)."
              },
              maxLength: 200
            },
            blobs: {
              type: "array",
              items: {
                type: "cid-link",
                description: "List of new blobs (by CID) referenced by records in this commit."
              }
            },
            time: {
              type: "string",
              format: "datetime",
              description: "Timestamp of when this message was originally broadcast."
            }
          }
        },
        identity: {
          type: "object",
          description: "Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache.",
          required: ["seq", "did", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            },
            handle: {
              type: "string",
              format: "handle",
              description: "The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details."
            }
          }
        },
        account: {
          type: "object",
          description: "Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active.",
          required: ["seq", "did", "time", "active"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            },
            active: {
              type: "boolean",
              description: "Indicates that the account has a repository which can be fetched from the host that emitted this event."
            },
            status: {
              type: "string",
              description: "If active=false, this optional field indicates a reason for why the account is not active.",
              knownValues: ["takendown", "suspended", "deleted", "deactivated"]
            }
          }
        },
        handle: {
          type: "object",
          description: "DEPRECATED -- Use #identity event instead",
          required: ["seq", "did", "handle", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        migrate: {
          type: "object",
          description: "DEPRECATED -- Use #account event instead",
          required: ["seq", "did", "migrateTo", "time"],
          nullable: ["migrateTo"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            migrateTo: {
              type: "string"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        tombstone: {
          type: "object",
          description: "DEPRECATED -- Use #account event instead",
          required: ["seq", "did", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        info: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              type: "string",
              knownValues: ["OutdatedCursor"]
            },
            message: {
              type: "string"
            }
          }
        },
        repoOp: {
          type: "object",
          description: "A repo operation, ie a mutation of a single record.",
          required: ["action", "path", "cid"],
          nullable: ["cid"],
          properties: {
            action: {
              type: "string",
              knownValues: ["create", "update", "delete"]
            },
            path: {
              type: "string"
            },
            cid: {
              type: "cid-link",
              description: "For creates and updates, the new record CID. For deletions, null."
            }
          }
        }
      }
    },
    ComAtprotoTempCheckSignupQueue: {
      lexicon: 1,
      id: "com.atproto.temp.checkSignupQueue",
      defs: {
        main: {
          type: "query",
          description: "Check accounts location in signup queue.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["activated"],
              properties: {
                activated: {
                  type: "boolean"
                },
                placeInQueue: {
                  type: "integer"
                },
                estimatedTimeMs: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoTempFetchLabels: {
      lexicon: 1,
      id: "com.atproto.temp.fetchLabels",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.",
          parameters: {
            type: "params",
            properties: {
              since: {
                type: "integer"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 250,
                default: 50
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["labels"],
              properties: {
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoTempRequestPhoneVerification: {
      lexicon: 1,
      id: "com.atproto.temp.requestPhoneVerification",
      defs: {
        main: {
          type: "procedure",
          description: "Request a verification code to be sent to the supplied phone number",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["phoneNumber"],
              properties: {
                phoneNumber: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorDefs: {
      lexicon: 1,
      id: "app.bsky.actor.defs",
      defs: {
        profileViewBasic: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        profileView: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              maxGraphemes: 256,
              maxLength: 2560
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileViewDetailed: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              maxGraphemes: 256,
              maxLength: 2560
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            banner: {
              type: "string",
              format: "uri"
            },
            followersCount: {
              type: "integer"
            },
            followsCount: {
              type: "integer"
            },
            postsCount: {
              type: "integer"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            joinedViaStarterPack: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileAssociated: {
          type: "object",
          properties: {
            lists: {
              type: "integer"
            },
            feedgens: {
              type: "integer"
            },
            starterPacks: {
              type: "integer"
            },
            labeler: {
              type: "boolean"
            },
            chat: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociatedChat"
            }
          }
        },
        profileAssociatedChat: {
          type: "object",
          required: ["allowIncoming"],
          properties: {
            allowIncoming: {
              type: "string",
              knownValues: ["all", "none", "following"]
            }
          }
        },
        viewerState: {
          type: "object",
          description: "Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests.",
          properties: {
            muted: {
              type: "boolean"
            },
            mutedByList: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            blockedBy: {
              type: "boolean"
            },
            blocking: {
              type: "string",
              format: "at-uri"
            },
            blockingByList: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            following: {
              type: "string",
              format: "at-uri"
            },
            followedBy: {
              type: "string",
              format: "at-uri"
            },
            knownFollowers: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#knownFollowers"
            }
          }
        },
        knownFollowers: {
          type: "object",
          description: "The subject's followers whom you also follow",
          required: ["count", "followers"],
          properties: {
            count: {
              type: "integer"
            },
            followers: {
              type: "array",
              minLength: 0,
              maxLength: 5,
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              }
            }
          }
        },
        preferences: {
          type: "array",
          items: {
            type: "union",
            refs: [
              "lex:app.bsky.actor.defs#adultContentPref",
              "lex:app.bsky.actor.defs#contentLabelPref",
              "lex:app.bsky.actor.defs#savedFeedsPref",
              "lex:app.bsky.actor.defs#savedFeedsPrefV2",
              "lex:app.bsky.actor.defs#personalDetailsPref",
              "lex:app.bsky.actor.defs#feedViewPref",
              "lex:app.bsky.actor.defs#threadViewPref",
              "lex:app.bsky.actor.defs#interestsPref",
              "lex:app.bsky.actor.defs#mutedWordsPref",
              "lex:app.bsky.actor.defs#hiddenPostsPref",
              "lex:app.bsky.actor.defs#bskyAppStatePref",
              "lex:app.bsky.actor.defs#labelersPref"
            ]
          }
        },
        adultContentPref: {
          type: "object",
          required: ["enabled"],
          properties: {
            enabled: {
              type: "boolean",
              default: !1
            }
          }
        },
        contentLabelPref: {
          type: "object",
          required: ["label", "visibility"],
          properties: {
            labelerDid: {
              type: "string",
              description: "Which labeler does this preference apply to? If undefined, applies globally.",
              format: "did"
            },
            label: {
              type: "string"
            },
            visibility: {
              type: "string",
              knownValues: ["ignore", "show", "warn", "hide"]
            }
          }
        },
        savedFeed: {
          type: "object",
          required: ["id", "type", "value", "pinned"],
          properties: {
            id: {
              type: "string"
            },
            type: {
              type: "string",
              knownValues: ["feed", "list", "timeline"]
            },
            value: {
              type: "string"
            },
            pinned: {
              type: "boolean"
            }
          }
        },
        savedFeedsPrefV2: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#savedFeed"
              }
            }
          }
        },
        savedFeedsPref: {
          type: "object",
          required: ["pinned", "saved"],
          properties: {
            pinned: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              }
            },
            saved: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              }
            },
            timelineIndex: {
              type: "integer"
            }
          }
        },
        personalDetailsPref: {
          type: "object",
          properties: {
            birthDate: {
              type: "string",
              format: "datetime",
              description: "The birth date of account owner."
            }
          }
        },
        feedViewPref: {
          type: "object",
          required: ["feed"],
          properties: {
            feed: {
              type: "string",
              description: "The URI of the feed, or an identifier which describes the feed."
            },
            hideReplies: {
              type: "boolean",
              description: "Hide replies in the feed."
            },
            hideRepliesByUnfollowed: {
              type: "boolean",
              description: "Hide replies in the feed if they are not by followed users.",
              default: !0
            },
            hideRepliesByLikeCount: {
              type: "integer",
              description: "Hide replies in the feed if they do not have this number of likes."
            },
            hideReposts: {
              type: "boolean",
              description: "Hide reposts in the feed."
            },
            hideQuotePosts: {
              type: "boolean",
              description: "Hide quote posts in the feed."
            }
          }
        },
        threadViewPref: {
          type: "object",
          properties: {
            sort: {
              type: "string",
              description: "Sorting mode for threads.",
              knownValues: ["oldest", "newest", "most-likes", "random"]
            },
            prioritizeFollowedUsers: {
              type: "boolean",
              description: "Show followed users at the top of all replies."
            }
          }
        },
        interestsPref: {
          type: "object",
          required: ["tags"],
          properties: {
            tags: {
              type: "array",
              maxLength: 100,
              items: {
                type: "string",
                maxLength: 640,
                maxGraphemes: 64
              },
              description: "A list of tags which describe the account owner's interests gathered during onboarding."
            }
          }
        },
        mutedWordTarget: {
          type: "string",
          knownValues: ["content", "tag"],
          maxLength: 640,
          maxGraphemes: 64
        },
        mutedWord: {
          type: "object",
          description: "A word that the account owner has muted.",
          required: ["value", "targets"],
          properties: {
            id: {
              type: "string"
            },
            value: {
              type: "string",
              description: "The muted word itself.",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            targets: {
              type: "array",
              description: "The intended targets of the muted word.",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#mutedWordTarget"
              }
            },
            actorTarget: {
              type: "string",
              description: "Groups of users to apply the muted word to. If undefined, applies to all users.",
              knownValues: ["all", "exclude-following"],
              default: "all"
            },
            expiresAt: {
              type: "string",
              format: "datetime",
              description: "The date and time at which the muted word will expire and no longer be applied."
            }
          }
        },
        mutedWordsPref: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#mutedWord"
              },
              description: "A list of words the account owner has muted."
            }
          }
        },
        hiddenPostsPref: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              },
              description: "A list of URIs of posts the account owner has hidden."
            }
          }
        },
        labelersPref: {
          type: "object",
          required: ["labelers"],
          properties: {
            labelers: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#labelerPrefItem"
              }
            }
          }
        },
        labelerPrefItem: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        bskyAppStatePref: {
          description: "A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this.",
          type: "object",
          properties: {
            activeProgressGuide: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#bskyAppProgressGuide"
            },
            queuedNudges: {
              description: "An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.",
              type: "array",
              maxLength: 1e3,
              items: {
                type: "string",
                maxLength: 100
              }
            }
          }
        },
        bskyAppProgressGuide: {
          description: "If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress.",
          type: "object",
          required: ["guide"],
          properties: {
            guide: {
              type: "string",
              maxLength: 100
            }
          }
        }
      }
    },
    AppBskyActorGetPreferences: {
      lexicon: 1,
      id: "app.bsky.actor.getPreferences",
      defs: {
        main: {
          type: "query",
          description: "Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth.",
          parameters: {
            type: "params",
            properties: {}
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["preferences"],
              properties: {
                preferences: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#preferences"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorGetProfile: {
      lexicon: 1,
      id: "app.bsky.actor.getProfile",
      defs: {
        main: {
          type: "query",
          description: "Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "Handle or DID of account to fetch profile of."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewDetailed"
            }
          }
        }
      }
    },
    AppBskyActorGetProfiles: {
      lexicon: 1,
      id: "app.bsky.actor.getProfiles",
      defs: {
        main: {
          type: "query",
          description: "Get detailed profile views of multiple actors.",
          parameters: {
            type: "params",
            required: ["actors"],
            properties: {
              actors: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-identifier"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["profiles"],
              properties: {
                profiles: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorGetSuggestions: {
      lexicon: 1,
      id: "app.bsky.actor.getSuggestions",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorProfile: {
      lexicon: 1,
      id: "app.bsky.actor.profile",
      defs: {
        main: {
          type: "record",
          description: "A declaration of a Bluesky account profile.",
          key: "literal:self",
          record: {
            type: "object",
            properties: {
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              description: {
                type: "string",
                description: "Free-form profile description text.",
                maxGraphemes: 256,
                maxLength: 2560
              },
              avatar: {
                type: "blob",
                description: "Small image to be displayed next to posts from account. AKA, 'profile picture'",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              banner: {
                type: "blob",
                description: "Larger horizontal image to display behind profile view.",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              labels: {
                type: "union",
                description: "Self-label values, specific to the Bluesky application, on the overall account.",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              joinedViaStarterPack: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyActorPutPreferences: {
      lexicon: 1,
      id: "app.bsky.actor.putPreferences",
      defs: {
        main: {
          type: "procedure",
          description: "Set the private preferences attached to the account.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["preferences"],
              properties: {
                preferences: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#preferences"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorSearchActors: {
      lexicon: 1,
      id: "app.bsky.actor.searchActors",
      defs: {
        main: {
          type: "query",
          description: "Find actors (profiles) matching search criteria. Does not require auth.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead."
              },
              q: {
                type: "string",
                description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorSearchActorsTypeahead: {
      lexicon: 1,
      id: "app.bsky.actor.searchActorsTypeahead",
      defs: {
        main: {
          type: "query",
          description: "Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead."
              },
              q: {
                type: "string",
                description: "Search query prefix; not a full query string."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 10
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyEmbedExternal: {
      lexicon: 1,
      id: "app.bsky.embed.external",
      defs: {
        main: {
          type: "object",
          description: "A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post).",
          required: ["external"],
          properties: {
            external: {
              type: "ref",
              ref: "lex:app.bsky.embed.external#external"
            }
          }
        },
        external: {
          type: "object",
          required: ["uri", "title", "description"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            thumb: {
              type: "blob",
              accept: ["image/*"],
              maxSize: 1e6
            }
          }
        },
        view: {
          type: "object",
          required: ["external"],
          properties: {
            external: {
              type: "ref",
              ref: "lex:app.bsky.embed.external#viewExternal"
            }
          }
        },
        viewExternal: {
          type: "object",
          required: ["uri", "title", "description"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            thumb: {
              type: "string",
              format: "uri"
            }
          }
        }
      }
    },
    AppBskyEmbedImages: {
      lexicon: 1,
      id: "app.bsky.embed.images",
      description: "A set of images embedded in a Bluesky record (eg, a post).",
      defs: {
        main: {
          type: "object",
          required: ["images"],
          properties: {
            images: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#image"
              },
              maxLength: 4
            }
          }
        },
        image: {
          type: "object",
          required: ["image", "alt"],
          properties: {
            image: {
              type: "blob",
              accept: ["image/*"],
              maxSize: 1e6
            },
            alt: {
              type: "string",
              description: "Alt text description of the image, for accessibility."
            },
            aspectRatio: {
              type: "ref",
              ref: "lex:app.bsky.embed.images#aspectRatio"
            }
          }
        },
        aspectRatio: {
          type: "object",
          description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
          required: ["width", "height"],
          properties: {
            width: {
              type: "integer",
              minimum: 1
            },
            height: {
              type: "integer",
              minimum: 1
            }
          }
        },
        view: {
          type: "object",
          required: ["images"],
          properties: {
            images: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#viewImage"
              },
              maxLength: 4
            }
          }
        },
        viewImage: {
          type: "object",
          required: ["thumb", "fullsize", "alt"],
          properties: {
            thumb: {
              type: "string",
              format: "uri",
              description: "Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View."
            },
            fullsize: {
              type: "string",
              format: "uri",
              description: "Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View."
            },
            alt: {
              type: "string",
              description: "Alt text description of the image, for accessibility."
            },
            aspectRatio: {
              type: "ref",
              ref: "lex:app.bsky.embed.images#aspectRatio"
            }
          }
        }
      }
    },
    AppBskyEmbedRecord: {
      lexicon: 1,
      id: "app.bsky.embed.record",
      description: "A representation of a record embedded in a Bluesky record (eg, a post). For example, a quote-post, or sharing a feed generator record.",
      defs: {
        main: {
          type: "object",
          required: ["record"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            }
          }
        },
        view: {
          type: "object",
          required: ["record"],
          properties: {
            record: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.record#viewRecord",
                "lex:app.bsky.embed.record#viewNotFound",
                "lex:app.bsky.embed.record#viewBlocked",
                "lex:app.bsky.feed.defs#generatorView",
                "lex:app.bsky.graph.defs#listView",
                "lex:app.bsky.labeler.defs#labelerView",
                "lex:app.bsky.graph.defs#starterPackViewBasic"
              ]
            }
          }
        },
        viewRecord: {
          type: "object",
          required: ["uri", "cid", "author", "value", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            value: {
              type: "unknown",
              description: "The record data itself."
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            replyCount: {
              type: "integer"
            },
            repostCount: {
              type: "integer"
            },
            likeCount: {
              type: "integer"
            },
            embeds: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images#view",
                  "lex:app.bsky.embed.external#view",
                  "lex:app.bsky.embed.record#view",
                  "lex:app.bsky.embed.recordWithMedia#view"
                ]
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        viewNotFound: {
          type: "object",
          required: ["uri", "notFound"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        viewBlocked: {
          type: "object",
          required: ["uri", "blocked", "author"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            blocked: {
              type: "boolean",
              const: !0
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#blockedAuthor"
            }
          }
        }
      }
    },
    AppBskyEmbedRecordWithMedia: {
      lexicon: 1,
      id: "app.bsky.embed.recordWithMedia",
      description: "A representation of a record embedded in a Bluesky record (eg, a post), alongside other compatible embeds. For example, a quote post and image, or a quote post and external URL card.",
      defs: {
        main: {
          type: "object",
          required: ["record", "media"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:app.bsky.embed.record"
            },
            media: {
              type: "union",
              refs: ["lex:app.bsky.embed.images", "lex:app.bsky.embed.external"]
            }
          }
        },
        view: {
          type: "object",
          required: ["record", "media"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:app.bsky.embed.record#view"
            },
            media: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.images#view",
                "lex:app.bsky.embed.external#view"
              ]
            }
          }
        }
      }
    },
    AppBskyFeedDefs: {
      lexicon: 1,
      id: "app.bsky.feed.defs",
      defs: {
        postView: {
          type: "object",
          required: ["uri", "cid", "author", "record", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            record: {
              type: "unknown"
            },
            embed: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.images#view",
                "lex:app.bsky.embed.external#view",
                "lex:app.bsky.embed.record#view",
                "lex:app.bsky.embed.recordWithMedia#view"
              ]
            },
            replyCount: {
              type: "integer"
            },
            repostCount: {
              type: "integer"
            },
            likeCount: {
              type: "integer"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            threadgate: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#threadgateView"
            }
          }
        },
        viewerState: {
          type: "object",
          description: "Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests.",
          properties: {
            repost: {
              type: "string",
              format: "at-uri"
            },
            like: {
              type: "string",
              format: "at-uri"
            },
            threadMuted: {
              type: "boolean"
            },
            replyDisabled: {
              type: "boolean"
            }
          }
        },
        feedViewPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#postView"
            },
            reply: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#replyRef"
            },
            reason: {
              type: "union",
              refs: ["lex:app.bsky.feed.defs#reasonRepost"]
            },
            feedContext: {
              type: "string",
              description: "Context provided by feed generator that may be passed back alongside interactions.",
              maxLength: 2e3
            }
          }
        },
        replyRef: {
          type: "object",
          required: ["root", "parent"],
          properties: {
            root: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#postView",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            parent: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#postView",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            grandparentAuthor: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic",
              description: "When parent is a reply to another post, this is the author of that post."
            }
          }
        },
        reasonRepost: {
          type: "object",
          required: ["by", "indexedAt"],
          properties: {
            by: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        threadViewPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#postView"
            },
            parent: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#threadViewPost",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            replies: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#threadViewPost",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              }
            }
          }
        },
        notFoundPost: {
          type: "object",
          required: ["uri", "notFound"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        blockedPost: {
          type: "object",
          required: ["uri", "blocked", "author"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            blocked: {
              type: "boolean",
              const: !0
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#blockedAuthor"
            }
          }
        },
        blockedAuthor: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            }
          }
        },
        generatorView: {
          type: "object",
          required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            did: {
              type: "string",
              format: "did"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            displayName: {
              type: "string"
            },
            description: {
              type: "string",
              maxGraphemes: 300,
              maxLength: 3e3
            },
            descriptionFacets: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            acceptsInteractions: {
              type: "boolean"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#generatorViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        generatorViewerState: {
          type: "object",
          properties: {
            like: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        skeletonFeedPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "string",
              format: "at-uri"
            },
            reason: {
              type: "union",
              refs: ["lex:app.bsky.feed.defs#skeletonReasonRepost"]
            },
            feedContext: {
              type: "string",
              description: "Context that will be passed through to client and may be passed to feed generator back alongside interactions.",
              maxLength: 2e3
            }
          }
        },
        skeletonReasonRepost: {
          type: "object",
          required: ["repost"],
          properties: {
            repost: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        threadgateView: {
          type: "object",
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            lists: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewBasic"
              }
            }
          }
        },
        interaction: {
          type: "object",
          properties: {
            item: {
              type: "string",
              format: "at-uri"
            },
            event: {
              type: "string",
              knownValues: [
                "app.bsky.feed.defs#requestLess",
                "app.bsky.feed.defs#requestMore",
                "app.bsky.feed.defs#clickthroughItem",
                "app.bsky.feed.defs#clickthroughAuthor",
                "app.bsky.feed.defs#clickthroughReposter",
                "app.bsky.feed.defs#clickthroughEmbed",
                "app.bsky.feed.defs#interactionSeen",
                "app.bsky.feed.defs#interactionLike",
                "app.bsky.feed.defs#interactionRepost",
                "app.bsky.feed.defs#interactionReply",
                "app.bsky.feed.defs#interactionQuote",
                "app.bsky.feed.defs#interactionShare"
              ]
            },
            feedContext: {
              type: "string",
              description: "Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.",
              maxLength: 2e3
            }
          }
        },
        requestLess: {
          type: "token",
          description: "Request that less content like the given feed item be shown in the feed"
        },
        requestMore: {
          type: "token",
          description: "Request that more content like the given feed item be shown in the feed"
        },
        clickthroughItem: {
          type: "token",
          description: "User clicked through to the feed item"
        },
        clickthroughAuthor: {
          type: "token",
          description: "User clicked through to the author of the feed item"
        },
        clickthroughReposter: {
          type: "token",
          description: "User clicked through to the reposter of the feed item"
        },
        clickthroughEmbed: {
          type: "token",
          description: "User clicked through to the embedded content of the feed item"
        },
        interactionSeen: {
          type: "token",
          description: "Feed item was seen by user"
        },
        interactionLike: {
          type: "token",
          description: "User liked the feed item"
        },
        interactionRepost: {
          type: "token",
          description: "User reposted the feed item"
        },
        interactionReply: {
          type: "token",
          description: "User replied to the feed item"
        },
        interactionQuote: {
          type: "token",
          description: "User quoted the feed item"
        },
        interactionShare: {
          type: "token",
          description: "User shared the feed item"
        }
      }
    },
    AppBskyFeedDescribeFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.describeFeedGenerator",
      defs: {
        main: {
          type: "query",
          description: "Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View).",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "feeds"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                  }
                },
                links: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                }
              }
            }
          }
        },
        feed: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        links: {
          type: "object",
          properties: {
            privacyPolicy: {
              type: "string"
            },
            termsOfService: {
              type: "string"
            }
          }
        }
      }
    },
    AppBskyFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.generator",
      defs: {
        main: {
          type: "record",
          description: "Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository.",
          key: "any",
          record: {
            type: "object",
            required: ["did", "displayName", "createdAt"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              displayName: {
                type: "string",
                maxGraphemes: 24,
                maxLength: 240
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "blob",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              acceptsInteractions: {
                type: "boolean",
                description: "Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions"
              },
              labels: {
                type: "union",
                description: "Self-label values",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetActorFeeds: {
      lexicon: 1,
      id: "app.bsky.feed.getActorFeeds",
      defs: {
        main: {
          type: "query",
          description: "Get a list of feeds (feed generator records) created by the actor (in the actor's repo).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetActorLikes: {
      lexicon: 1,
      id: "app.bsky.feed.getActorLikes",
      defs: {
        main: {
          type: "query",
          description: "Get a list of posts liked by an actor. Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BlockedActor"
            },
            {
              name: "BlockedByActor"
            }
          ]
        }
      }
    },
    AppBskyFeedGetAuthorFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getAuthorFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              filter: {
                type: "string",
                description: "Combinations of post/repost types to include in response.",
                knownValues: [
                  "posts_with_replies",
                  "posts_no_replies",
                  "posts_with_media",
                  "posts_and_author_threads"
                ],
                default: "posts_with_replies"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BlockedActor"
            },
            {
              name: "BlockedByActor"
            }
          ]
        }
      }
    },
    AppBskyFeedGetFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a hydrated feed from an actor's selected feed generator. Implemented by App View.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownFeed"
            }
          ]
        }
      }
    },
    AppBskyFeedGetFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedGenerator",
      defs: {
        main: {
          type: "query",
          description: "Get information about a feed generator. Implemented by AppView.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri",
                description: "AT-URI of the feed generator record."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["view", "isOnline", "isValid"],
              properties: {
                view: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorView"
                },
                isOnline: {
                  type: "boolean",
                  description: "Indicates whether the feed generator service has been online recently, or else seems to be inactive."
                },
                isValid: {
                  type: "boolean",
                  description: "Indicates whether the feed generator service is compatible with the record declaration."
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetFeedGenerators: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedGenerators",
      defs: {
        main: {
          type: "query",
          description: "Get information about a list of feed generators.",
          parameters: {
            type: "params",
            required: ["feeds"],
            properties: {
              feeds: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetFeedSkeleton: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri",
                description: "Reference to feed generator record describing the specific feed being requested."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownFeed"
            }
          ]
        }
      }
    },
    AppBskyFeedGetLikes: {
      lexicon: 1,
      id: "app.bsky.feed.getLikes",
      defs: {
        main: {
          type: "query",
          description: "Get like records which reference a subject (by AT-URI and CID).",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "AT-URI of the subject (eg, a post record)."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "CID of the subject record (aka, specific version of record), to filter likes."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "likes"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                cursor: {
                  type: "string"
                },
                likes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.getLikes#like"
                  }
                }
              }
            }
          }
        },
        like: {
          type: "object",
          required: ["indexedAt", "createdAt", "actor"],
          properties: {
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            actor: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            }
          }
        }
      }
    },
    AppBskyFeedGetListFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getListFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth.",
          parameters: {
            type: "params",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownList"
            }
          ]
        }
      }
    },
    AppBskyFeedGetPostThread: {
      lexicon: 1,
      id: "app.bsky.feed.getPostThread",
      defs: {
        main: {
          type: "query",
          description: "Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to post record."
              },
              depth: {
                type: "integer",
                description: "How many levels of reply depth should be included in response.",
                default: 6,
                minimum: 0,
                maximum: 1e3
              },
              parentHeight: {
                type: "integer",
                description: "How many levels of parent (and grandparent, etc) post to include.",
                default: 80,
                minimum: 0,
                maximum: 1e3
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["thread"],
              properties: {
                thread: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                }
              }
            }
          },
          errors: [
            {
              name: "NotFound"
            }
          ]
        }
      }
    },
    AppBskyFeedGetPosts: {
      lexicon: 1,
      id: "app.bsky.feed.getPosts",
      defs: {
        main: {
          type: "query",
          description: "Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'.",
          parameters: {
            type: "params",
            required: ["uris"],
            properties: {
              uris: {
                type: "array",
                description: "List of post AT-URIs to return hydrated views for.",
                items: {
                  type: "string",
                  format: "at-uri"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#postView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetRepostedBy: {
      lexicon: 1,
      id: "app.bsky.feed.getRepostedBy",
      defs: {
        main: {
          type: "query",
          description: "Get a list of reposts for a given post.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of post record"
              },
              cid: {
                type: "string",
                format: "cid",
                description: "If supplied, filters to reposts of specific version (by CID) of the post record."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "repostedBy"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                cursor: {
                  type: "string"
                },
                repostedBy: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetSuggestedFeeds: {
      lexicon: 1,
      id: "app.bsky.feed.getSuggestedFeeds",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggested feeds (feed generators) for the requesting account.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetTimeline: {
      lexicon: 1,
      id: "app.bsky.feed.getTimeline",
      defs: {
        main: {
          type: "query",
          description: "Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed.",
          parameters: {
            type: "params",
            properties: {
              algorithm: {
                type: "string",
                description: "Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedLike: {
      lexicon: 1,
      id: "app.bsky.feed.like",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a 'like' of a piece of subject content.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedPost: {
      lexicon: 1,
      id: "app.bsky.feed.post",
      defs: {
        main: {
          type: "record",
          description: "Record containing a Bluesky post.",
          key: "tid",
          record: {
            type: "object",
            required: ["text", "createdAt"],
            properties: {
              text: {
                type: "string",
                maxLength: 3e3,
                maxGraphemes: 300,
                description: "The primary post content. May be an empty string, if there are embeds."
              },
              entities: {
                type: "array",
                description: "DEPRECATED: replaced by app.bsky.richtext.facet.",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#entity"
                }
              },
              facets: {
                type: "array",
                description: "Annotations of text (mentions, URLs, hashtags, etc)",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              reply: {
                type: "ref",
                ref: "lex:app.bsky.feed.post#replyRef"
              },
              embed: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images",
                  "lex:app.bsky.embed.external",
                  "lex:app.bsky.embed.record",
                  "lex:app.bsky.embed.recordWithMedia"
                ]
              },
              langs: {
                type: "array",
                description: "Indicates human language of post primary text content.",
                maxLength: 3,
                items: {
                  type: "string",
                  format: "language"
                }
              },
              labels: {
                type: "union",
                description: "Self-label values for this post. Effectively content warnings.",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              tags: {
                type: "array",
                description: "Additional hashtags, in addition to any included in post text and facets.",
                maxLength: 8,
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                }
              },
              createdAt: {
                type: "string",
                format: "datetime",
                description: "Client-declared timestamp when this post was originally created."
              }
            }
          }
        },
        replyRef: {
          type: "object",
          required: ["root", "parent"],
          properties: {
            root: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            },
            parent: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            }
          }
        },
        entity: {
          type: "object",
          description: "Deprecated: use facets instead.",
          required: ["index", "type", "value"],
          properties: {
            index: {
              type: "ref",
              ref: "lex:app.bsky.feed.post#textSlice"
            },
            type: {
              type: "string",
              description: "Expected values are 'mention' and 'link'."
            },
            value: {
              type: "string"
            }
          }
        },
        textSlice: {
          type: "object",
          description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
          required: ["start", "end"],
          properties: {
            start: {
              type: "integer",
              minimum: 0
            },
            end: {
              type: "integer",
              minimum: 0
            }
          }
        }
      }
    },
    AppBskyFeedRepost: {
      lexicon: 1,
      id: "app.bsky.feed.repost",
      defs: {
        main: {
          description: "Record representing a 'repost' of an existing Bluesky post.",
          type: "record",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedSearchPosts: {
      lexicon: 1,
      id: "app.bsky.feed.searchPosts",
      defs: {
        main: {
          type: "query",
          description: "Find posts matching search criteria, returning views of those posts.",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              sort: {
                type: "string",
                knownValues: ["top", "latest"],
                default: "latest",
                description: "Specifies the ranking order of results."
              },
              since: {
                type: "string",
                description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
              },
              until: {
                type: "string",
                description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
              },
              mentions: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
              },
              author: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
              },
              lang: {
                type: "string",
                format: "language",
                description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
              },
              domain: {
                type: "string",
                description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
              },
              url: {
                type: "string",
                format: "uri",
                description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
              },
              tag: {
                type: "array",
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#postView"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    AppBskyFeedSendInteractions: {
      lexicon: 1,
      id: "app.bsky.feed.sendInteractions",
      defs: {
        main: {
          type: "procedure",
          description: "Send information about interactions with feed items back to the feed generator that served them.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["interactions"],
              properties: {
                interactions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#interaction"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {}
            }
          }
        }
      }
    },
    AppBskyFeedThreadgate: {
      lexicon: 1,
      id: "app.bsky.feed.threadgate",
      defs: {
        main: {
          type: "record",
          key: "tid",
          description: "Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository..",
          record: {
            type: "object",
            required: ["post", "createdAt"],
            properties: {
              post: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the post record."
              },
              allow: {
                type: "array",
                maxLength: 5,
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.threadgate#mentionRule",
                    "lex:app.bsky.feed.threadgate#followingRule",
                    "lex:app.bsky.feed.threadgate#listRule"
                  ]
                }
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        },
        mentionRule: {
          type: "object",
          description: "Allow replies from actors mentioned in your post.",
          properties: {}
        },
        followingRule: {
          type: "object",
          description: "Allow replies from actors you follow.",
          properties: {}
        },
        listRule: {
          type: "object",
          description: "Allow replies from actors on a list.",
          required: ["list"],
          properties: {
            list: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    AppBskyGraphBlock: {
      lexicon: 1,
      id: "app.bsky.graph.block",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did",
                description: "DID of the account to be blocked."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphDefs: {
      lexicon: 1,
      id: "app.bsky.graph.defs",
      defs: {
        listViewBasic: {
          type: "object",
          required: ["uri", "cid", "name", "purpose"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            name: {
              type: "string",
              maxLength: 64,
              minLength: 1
            },
            purpose: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listPurpose"
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listView: {
          type: "object",
          required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            name: {
              type: "string",
              maxLength: 64,
              minLength: 1
            },
            purpose: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listPurpose"
            },
            description: {
              type: "string",
              maxGraphemes: 300,
              maxLength: 3e3
            },
            descriptionFacets: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listItemView: {
          type: "object",
          required: ["uri", "subject"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            subject: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            }
          }
        },
        starterPackView: {
          type: "object",
          required: ["uri", "cid", "record", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            list: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            listItemsSample: {
              type: "array",
              maxLength: 12,
              items: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listItemView"
              }
            },
            feeds: {
              type: "array",
              maxLength: 3,
              items: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#generatorView"
              }
            },
            joinedWeekCount: {
              type: "integer",
              minimum: 0
            },
            joinedAllTimeCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        starterPackViewBasic: {
          type: "object",
          required: ["uri", "cid", "record", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            joinedWeekCount: {
              type: "integer",
              minimum: 0
            },
            joinedAllTimeCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listPurpose: {
          type: "string",
          knownValues: [
            "app.bsky.graph.defs#modlist",
            "app.bsky.graph.defs#curatelist",
            "app.bsky.graph.defs#referencelist"
          ]
        },
        modlist: {
          type: "token",
          description: "A list of actors to apply an aggregate moderation action (mute/block) on."
        },
        curatelist: {
          type: "token",
          description: "A list of actors used for curation purposes such as list feeds or interaction gating."
        },
        referencelist: {
          type: "token",
          description: "A list of actors used for only for reference purposes such as within a starter pack."
        },
        listViewerState: {
          type: "object",
          properties: {
            muted: {
              type: "boolean"
            },
            blocked: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        notFoundActor: {
          type: "object",
          description: "indicates that a handle or DID could not be resolved",
          required: ["actor", "notFound"],
          properties: {
            actor: {
              type: "string",
              format: "at-identifier"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        relationship: {
          type: "object",
          description: "lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object)",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            following: {
              type: "string",
              format: "at-uri",
              description: "if the actor follows this DID, this is the AT-URI of the follow record"
            },
            followedBy: {
              type: "string",
              format: "at-uri",
              description: "if the actor is followed by this DID, contains the AT-URI of the follow record"
            }
          }
        }
      }
    },
    AppBskyGraphFollow: {
      lexicon: 1,
      id: "app.bsky.graph.follow",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetActorStarterPacks: {
      lexicon: 1,
      id: "app.bsky.graph.getActorStarterPacks",
      defs: {
        main: {
          type: "query",
          description: "Get a list of starter packs created by the actor.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPacks"],
              properties: {
                cursor: {
                  type: "string"
                },
                starterPacks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetBlocks: {
      lexicon: 1,
      id: "app.bsky.graph.getBlocks",
      defs: {
        main: {
          type: "query",
          description: "Enumerates which accounts the requesting account is currently blocking. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blocks"],
              properties: {
                cursor: {
                  type: "string"
                },
                blocks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetFollowers: {
      lexicon: 1,
      id: "app.bsky.graph.getFollowers",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which follow a specified account (actor).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "followers"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                followers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetFollows: {
      lexicon: 1,
      id: "app.bsky.graph.getFollows",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which a specified account (actor) follows.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "follows"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                follows: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetKnownFollowers: {
      lexicon: 1,
      id: "app.bsky.graph.getKnownFollowers",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which follow a specified account (actor) and are followed by the viewer.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "followers"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                followers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetList: {
      lexicon: 1,
      id: "app.bsky.graph.getList",
      defs: {
        main: {
          type: "query",
          description: "Gets a 'view' (with additional context) of a specified list.",
          parameters: {
            type: "params",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of the list record to hydrate."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list", "items"],
              properties: {
                cursor: {
                  type: "string"
                },
                list: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listView"
                },
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listItemView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetListBlocks: {
      lexicon: 1,
      id: "app.bsky.graph.getListBlocks",
      defs: {
        main: {
          type: "query",
          description: "Get mod lists that the requesting account (actor) is blocking. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetListMutes: {
      lexicon: 1,
      id: "app.bsky.graph.getListMutes",
      defs: {
        main: {
          type: "query",
          description: "Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetLists: {
      lexicon: 1,
      id: "app.bsky.graph.getLists",
      defs: {
        main: {
          type: "query",
          description: "Enumerates the lists created by a specified account (actor).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "The account (actor) to enumerate lists from."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetMutes: {
      lexicon: 1,
      id: "app.bsky.graph.getMutes",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts that the requesting account (actor) currently has muted. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["mutes"],
              properties: {
                cursor: {
                  type: "string"
                },
                mutes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetRelationships: {
      lexicon: 1,
      id: "app.bsky.graph.getRelationships",
      defs: {
        main: {
          type: "query",
          description: "Enumerates public relationships between one account, and a list of other accounts. Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "Primary account requesting relationships for."
              },
              others: {
                type: "array",
                description: "List of 'other' accounts to be related back to the primary.",
                maxLength: 30,
                items: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["relationships"],
              properties: {
                actor: {
                  type: "string",
                  format: "did"
                },
                relationships: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.graph.defs#relationship",
                      "lex:app.bsky.graph.defs#notFoundActor"
                    ]
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "ActorNotFound",
              description: "the primary actor at-identifier could not be resolved"
            }
          ]
        }
      }
    },
    AppBskyGraphGetStarterPack: {
      lexicon: 1,
      id: "app.bsky.graph.getStarterPack",
      defs: {
        main: {
          type: "query",
          description: "Gets a view of a starter pack.",
          parameters: {
            type: "params",
            required: ["starterPack"],
            properties: {
              starterPack: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of the starter pack record."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPack"],
              properties: {
                starterPack: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#starterPackView"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetStarterPacks: {
      lexicon: 1,
      id: "app.bsky.graph.getStarterPacks",
      defs: {
        main: {
          type: "query",
          description: "Get views for a list of starter packs.",
          parameters: {
            type: "params",
            required: ["uris"],
            properties: {
              uris: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPacks"],
              properties: {
                starterPacks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetSuggestedFollowsByActor: {
      lexicon: 1,
      id: "app.bsky.graph.getSuggestedFollowsByActor",
      defs: {
        main: {
          type: "query",
          description: "Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["suggestions"],
              properties: {
                suggestions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphList: {
      lexicon: 1,
      id: "app.bsky.graph.list",
      defs: {
        main: {
          type: "record",
          description: "Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists.",
          key: "tid",
          record: {
            type: "object",
            required: ["name", "purpose", "createdAt"],
            properties: {
              purpose: {
                type: "ref",
                description: "Defines the purpose of the list (aka, moderation-oriented or curration-oriented)",
                ref: "lex:app.bsky.graph.defs#listPurpose"
              },
              name: {
                type: "string",
                maxLength: 64,
                minLength: 1,
                description: "Display name for list; can not be empty."
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "blob",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              labels: {
                type: "union",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphListblock: {
      lexicon: 1,
      id: "app.bsky.graph.listblock",
      defs: {
        main: {
          type: "record",
          description: "Record representing a block relationship against an entire an entire list of accounts (actors).",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the mod list record."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphListitem: {
      lexicon: 1,
      id: "app.bsky.graph.listitem",
      defs: {
        main: {
          type: "record",
          description: "Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "list", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did",
                description: "The account which is included on the list."
              },
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record (app.bsky.graph.list)."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteActor: {
      lexicon: 1,
      id: "app.bsky.graph.muteActor",
      defs: {
        main: {
          type: "procedure",
          description: "Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteActorList: {
      lexicon: 1,
      id: "app.bsky.graph.muteActorList",
      defs: {
        main: {
          type: "procedure",
          description: "Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteThread: {
      lexicon: 1,
      id: "app.bsky.graph.muteThread",
      defs: {
        main: {
          type: "procedure",
          description: "Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphStarterpack: {
      lexicon: 1,
      id: "app.bsky.graph.starterpack",
      defs: {
        main: {
          type: "record",
          description: "Record defining a starter pack of actors and feeds for new users.",
          key: "tid",
          record: {
            type: "object",
            required: ["name", "list", "createdAt"],
            properties: {
              name: {
                type: "string",
                maxGraphemes: 50,
                maxLength: 500,
                minLength: 1,
                description: "Display name for starter pack; can not be empty."
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record."
              },
              feeds: {
                type: "array",
                maxLength: 3,
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.starterpack#feedItem"
                }
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        },
        feedItem: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteActor: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteActor",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteActorList: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteActorList",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified list of accounts. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteThread: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteThread",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified thread. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyLabelerDefs: {
      lexicon: 1,
      id: "app.bsky.labeler.defs",
      defs: {
        labelerView: {
          type: "object",
          required: ["uri", "cid", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        labelerViewDetailed: {
          type: "object",
          required: ["uri", "cid", "creator", "policies", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            policies: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerPolicies"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        labelerViewerState: {
          type: "object",
          properties: {
            like: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        labelerPolicies: {
          type: "object",
          required: ["labelValues"],
          properties: {
            labelValues: {
              type: "array",
              description: "The label values which this labeler publishes. May include global or custom labels.",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValue"
              }
            },
            labelValueDefinitions: {
              type: "array",
              description: "Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler.",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValueDefinition"
              }
            }
          }
        }
      }
    },
    AppBskyLabelerGetServices: {
      lexicon: 1,
      id: "app.bsky.labeler.getServices",
      defs: {
        main: {
          type: "query",
          description: "Get information about a list of labeler services.",
          parameters: {
            type: "params",
            required: ["dids"],
            properties: {
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              },
              detailed: {
                type: "boolean",
                default: !1
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["views"],
              properties: {
                views: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.labeler.defs#labelerView",
                      "lex:app.bsky.labeler.defs#labelerViewDetailed"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyLabelerService: {
      lexicon: 1,
      id: "app.bsky.labeler.service",
      defs: {
        main: {
          type: "record",
          description: "A declaration of the existence of labeler service.",
          key: "literal:self",
          record: {
            type: "object",
            required: ["policies", "createdAt"],
            properties: {
              policies: {
                type: "ref",
                ref: "lex:app.bsky.labeler.defs#labelerPolicies"
              },
              labels: {
                type: "union",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyNotificationGetUnreadCount: {
      lexicon: 1,
      id: "app.bsky.notification.getUnreadCount",
      defs: {
        main: {
          type: "query",
          description: "Count the number of unread notifications for the requesting account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              priority: {
                type: "boolean"
              },
              seenAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["count"],
              properties: {
                count: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationListNotifications: {
      lexicon: 1,
      id: "app.bsky.notification.listNotifications",
      defs: {
        main: {
          type: "query",
          description: "Enumerate notifications for the requesting account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              priority: {
                type: "boolean"
              },
              cursor: {
                type: "string"
              },
              seenAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["notifications"],
              properties: {
                cursor: {
                  type: "string"
                },
                notifications: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.notification.listNotifications#notification"
                  }
                },
                priority: {
                  type: "boolean"
                },
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        notification: {
          type: "object",
          required: [
            "uri",
            "cid",
            "author",
            "reason",
            "record",
            "isRead",
            "indexedAt"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            reason: {
              type: "string",
              description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', 'quote', and 'starterpack-joined'.",
              knownValues: [
                "like",
                "repost",
                "follow",
                "mention",
                "reply",
                "quote",
                "starterpack-joined"
              ]
            },
            reasonSubject: {
              type: "string",
              format: "at-uri"
            },
            record: {
              type: "unknown"
            },
            isRead: {
              type: "boolean"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        }
      }
    },
    AppBskyNotificationPutPreferences: {
      lexicon: 1,
      id: "app.bsky.notification.putPreferences",
      defs: {
        main: {
          type: "procedure",
          description: "Set notification-related preferences for an account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["priority"],
              properties: {
                priority: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationRegisterPush: {
      lexicon: 1,
      id: "app.bsky.notification.registerPush",
      defs: {
        main: {
          type: "procedure",
          description: "Register to receive push notifications, via a specified service, for the requesting account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["serviceDid", "token", "platform", "appId"],
              properties: {
                serviceDid: {
                  type: "string",
                  format: "did"
                },
                token: {
                  type: "string"
                },
                platform: {
                  type: "string",
                  knownValues: ["ios", "android", "web"]
                },
                appId: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationUpdateSeen: {
      lexicon: 1,
      id: "app.bsky.notification.updateSeen",
      defs: {
        main: {
          type: "procedure",
          description: "Notify server that the requesting account has seen notifications. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["seenAt"],
              properties: {
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      }
    },
    AppBskyRichtextFacet: {
      lexicon: 1,
      id: "app.bsky.richtext.facet",
      defs: {
        main: {
          type: "object",
          description: "Annotation of a sub-string within rich text.",
          required: ["index", "features"],
          properties: {
            index: {
              type: "ref",
              ref: "lex:app.bsky.richtext.facet#byteSlice"
            },
            features: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.richtext.facet#mention",
                  "lex:app.bsky.richtext.facet#link",
                  "lex:app.bsky.richtext.facet#tag"
                ]
              }
            }
          }
        },
        mention: {
          type: "object",
          description: "Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID.",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        link: {
          type: "object",
          description: "Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL.",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            }
          }
        },
        tag: {
          type: "object",
          description: "Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags').",
          required: ["tag"],
          properties: {
            tag: {
              type: "string",
              maxLength: 640,
              maxGraphemes: 64
            }
          }
        },
        byteSlice: {
          type: "object",
          description: "Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets.",
          required: ["byteStart", "byteEnd"],
          properties: {
            byteStart: {
              type: "integer",
              minimum: 0
            },
            byteEnd: {
              type: "integer",
              minimum: 0
            }
          }
        }
      }
    },
    AppBskyUnspeccedDefs: {
      lexicon: 1,
      id: "app.bsky.unspecced.defs",
      defs: {
        skeletonSearchPost: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        skeletonSearchActor: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetPopularFeedGenerators: {
      lexicon: 1,
      id: "app.bsky.unspecced.getPopularFeedGenerators",
      defs: {
        main: {
          type: "query",
          description: "An unspecced view of globally popular feed generators.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              query: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetSuggestionsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.getSuggestionsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions",
          parameters: {
            type: "params",
            properties: {
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              relativeToDid: {
                type: "string",
                format: "did",
                description: "DID of the account to get suggestions relative to. If not provided, suggestions will be based on the viewer."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetTaggedSuggestions: {
      lexicon: 1,
      id: "app.bsky.unspecced.getTaggedSuggestions",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggestions (feeds and users) tagged with categories",
          parameters: {
            type: "params",
            properties: {}
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["suggestions"],
              properties: {
                suggestions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.getTaggedSuggestions#suggestion"
                  }
                }
              }
            }
          }
        },
        suggestion: {
          type: "object",
          required: ["tag", "subjectType", "subject"],
          properties: {
            tag: {
              type: "string"
            },
            subjectType: {
              type: "string",
              knownValues: ["actor", "feed"]
            },
            subject: {
              type: "string",
              format: "uri"
            }
          }
        }
      }
    },
    AppBskyUnspeccedSearchActorsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.searchActorsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Backend Actors (profile) search, returns only skeleton.",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
              },
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
              },
              typeahead: {
                type: "boolean",
                description: "If true, acts as fast/simple 'typeahead' query."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    AppBskyUnspeccedSearchPostsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.searchPostsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Backend Posts search, returns only skeleton",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              sort: {
                type: "string",
                knownValues: ["top", "latest"],
                default: "latest",
                description: "Specifies the ranking order of results."
              },
              since: {
                type: "string",
                description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
              },
              until: {
                type: "string",
                description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
              },
              mentions: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
              },
              author: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
              },
              lang: {
                type: "string",
                format: "language",
                description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
              },
              domain: {
                type: "string",
                description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
              },
              url: {
                type: "string",
                format: "uri",
                description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
              },
              tag: {
                type: "array",
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
              },
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    ChatBskyActorDeclaration: {
      lexicon: 1,
      id: "chat.bsky.actor.declaration",
      defs: {
        main: {
          type: "record",
          description: "A declaration of a Bluesky chat account.",
          key: "literal:self",
          record: {
            type: "object",
            required: ["allowIncoming"],
            properties: {
              allowIncoming: {
                type: "string",
                knownValues: ["all", "none", "following"]
              }
            }
          }
        }
      }
    },
    ChatBskyActorDefs: {
      lexicon: 1,
      id: "chat.bsky.actor.defs",
      defs: {
        profileViewBasic: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            chatDisabled: {
              type: "boolean",
              description: "Set to true when the actor cannot actively participate in converations"
            }
          }
        }
      }
    },
    ChatBskyActorDeleteAccount: {
      lexicon: 1,
      id: "chat.bsky.actor.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {}
            }
          }
        }
      }
    },
    ChatBskyActorExportAccountData: {
      lexicon: 1,
      id: "chat.bsky.actor.exportAccountData",
      defs: {
        main: {
          type: "query",
          output: {
            encoding: "application/jsonl"
          }
        }
      }
    },
    ChatBskyConvoDefs: {
      lexicon: 1,
      id: "chat.bsky.convo.defs",
      defs: {
        messageRef: {
          type: "object",
          required: ["did", "messageId", "convoId"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            convoId: {
              type: "string"
            },
            messageId: {
              type: "string"
            }
          }
        },
        messageInput: {
          type: "object",
          required: ["text"],
          properties: {
            text: {
              type: "string",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            facets: {
              type: "array",
              description: "Annotations of text (mentions, URLs, hashtags, etc)",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            embed: {
              type: "union",
              refs: ["lex:app.bsky.embed.record"]
            }
          }
        },
        messageView: {
          type: "object",
          required: ["id", "rev", "text", "sender", "sentAt"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            text: {
              type: "string",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            facets: {
              type: "array",
              description: "Annotations of text (mentions, URLs, hashtags, etc)",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            embed: {
              type: "union",
              refs: ["lex:app.bsky.embed.record#view"]
            },
            sender: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageViewSender"
            },
            sentAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        deletedMessageView: {
          type: "object",
          required: ["id", "rev", "sender", "sentAt"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            sender: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageViewSender"
            },
            sentAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        messageViewSender: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        convoView: {
          type: "object",
          required: ["id", "rev", "members", "muted", "unreadCount"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            members: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:chat.bsky.actor.defs#profileViewBasic"
              }
            },
            lastMessage: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            },
            muted: {
              type: "boolean"
            },
            unreadCount: {
              type: "integer"
            }
          }
        },
        logBeginConvo: {
          type: "object",
          required: ["rev", "convoId"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            }
          }
        },
        logLeaveConvo: {
          type: "object",
          required: ["rev", "convoId"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            }
          }
        },
        logCreateMessage: {
          type: "object",
          required: ["rev", "convoId", "message"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            },
            message: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            }
          }
        },
        logDeleteMessage: {
          type: "object",
          required: ["rev", "convoId", "message"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            },
            message: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            }
          }
        }
      }
    },
    ChatBskyConvoDeleteMessageForSelf: {
      lexicon: 1,
      id: "chat.bsky.convo.deleteMessageForSelf",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "messageId"],
              properties: {
                convoId: {
                  type: "string"
                },
                messageId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#deletedMessageView"
            }
          }
        }
      }
    },
    ChatBskyConvoGetConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.getConvo",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["convoId"],
            properties: {
              convoId: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetConvoForMembers: {
      lexicon: 1,
      id: "chat.bsky.convo.getConvoForMembers",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["members"],
            properties: {
              members: {
                type: "array",
                minLength: 1,
                maxLength: 10,
                items: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetLog: {
      lexicon: 1,
      id: "chat.bsky.convo.getLog",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: [],
            properties: {
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["logs"],
              properties: {
                cursor: {
                  type: "string"
                },
                logs: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#logBeginConvo",
                      "lex:chat.bsky.convo.defs#logLeaveConvo",
                      "lex:chat.bsky.convo.defs#logCreateMessage",
                      "lex:chat.bsky.convo.defs#logDeleteMessage"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetMessages: {
      lexicon: 1,
      id: "chat.bsky.convo.getMessages",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["convoId"],
            properties: {
              convoId: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["messages"],
              properties: {
                cursor: {
                  type: "string"
                },
                messages: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#messageView",
                      "lex:chat.bsky.convo.defs#deletedMessageView"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoLeaveConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.leaveConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "rev"],
              properties: {
                convoId: {
                  type: "string"
                },
                rev: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoListConvos: {
      lexicon: 1,
      id: "chat.bsky.convo.listConvos",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convos"],
              properties: {
                cursor: {
                  type: "string"
                },
                convos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#convoView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoMuteConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.muteConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoSendMessage: {
      lexicon: 1,
      id: "chat.bsky.convo.sendMessage",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "message"],
              properties: {
                convoId: {
                  type: "string"
                },
                message: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageInput"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageView"
            }
          }
        }
      }
    },
    ChatBskyConvoSendMessageBatch: {
      lexicon: 1,
      id: "chat.bsky.convo.sendMessageBatch",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.sendMessageBatch#batchItem"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#messageView"
                  }
                }
              }
            }
          }
        },
        batchItem: {
          type: "object",
          required: ["convoId", "message"],
          properties: {
            convoId: {
              type: "string"
            },
            message: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageInput"
            }
          }
        }
      }
    },
    ChatBskyConvoUnmuteConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.unmuteConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoUpdateRead: {
      lexicon: 1,
      id: "chat.bsky.convo.updateRead",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                },
                messageId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyModerationGetActorMetadata: {
      lexicon: 1,
      id: "chat.bsky.moderation.getActorMetadata",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["day", "month", "all"],
              properties: {
                day: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                },
                month: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                },
                all: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                }
              }
            }
          }
        },
        metadata: {
          type: "object",
          required: [
            "messagesSent",
            "messagesReceived",
            "convos",
            "convosStarted"
          ],
          properties: {
            messagesSent: {
              type: "integer"
            },
            messagesReceived: {
              type: "integer"
            },
            convos: {
              type: "integer"
            },
            convosStarted: {
              type: "integer"
            }
          }
        }
      }
    },
    ChatBskyModerationGetMessageContext: {
      lexicon: 1,
      id: "chat.bsky.moderation.getMessageContext",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["messageId"],
            properties: {
              convoId: {
                type: "string",
                description: "Conversation that the message is from. NOTE: this field will eventually be required."
              },
              messageId: {
                type: "string"
              },
              before: {
                type: "integer",
                default: 5
              },
              after: {
                type: "integer",
                default: 5
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["messages"],
              properties: {
                messages: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#messageView",
                      "lex:chat.bsky.convo.defs#deletedMessageView"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyModerationUpdateActorAccess: {
      lexicon: 1,
      id: "chat.bsky.moderation.updateActorAccess",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor", "allowAccess"],
              properties: {
                actor: {
                  type: "string",
                  format: "did"
                },
                allowAccess: {
                  type: "boolean"
                },
                ref: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationCreateTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.createTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to create a new, re-usable communication (email for now) template.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "contentMarkdown", "name"],
              properties: {
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Content of the template, markdown supported, can contain variable placeholders."
                },
                subject: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                createdBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who is creating the template."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.communication.defs#templateView"
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationDefs: {
      lexicon: 1,
      id: "tools.ozone.communication.defs",
      defs: {
        templateView: {
          type: "object",
          required: [
            "id",
            "name",
            "contentMarkdown",
            "disabled",
            "lastUpdatedBy",
            "createdAt",
            "updatedAt"
          ],
          properties: {
            id: {
              type: "string"
            },
            name: {
              type: "string",
              description: "Name of the template."
            },
            subject: {
              type: "string",
              description: "Content of the template, can contain markdown and variable placeholders."
            },
            contentMarkdown: {
              type: "string",
              description: "Subject of the message, used in emails."
            },
            disabled: {
              type: "boolean"
            },
            lastUpdatedBy: {
              type: "string",
              format: "did",
              description: "DID of the user who last updated the template."
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            updatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationDeleteTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.deleteTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a communication template.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["id"],
              properties: {
                id: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationListTemplates: {
      lexicon: 1,
      id: "tools.ozone.communication.listTemplates",
      defs: {
        main: {
          type: "query",
          description: "Get list of all communication templates.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["communicationTemplates"],
              properties: {
                communicationTemplates: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.communication.defs#templateView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationUpdateTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.updateTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["id"],
              properties: {
                id: {
                  type: "string",
                  description: "ID of the template to be updated."
                },
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Content of the template, markdown supported, can contain variable placeholders."
                },
                subject: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                updatedBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who is updating the template."
                },
                disabled: {
                  type: "boolean"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.communication.defs#templateView"
            }
          }
        }
      }
    },
    ToolsOzoneModerationDefs: {
      lexicon: 1,
      id: "tools.ozone.moderation.defs",
      defs: {
        modEventView: {
          type: "object",
          required: [
            "id",
            "event",
            "subject",
            "subjectBlobCids",
            "createdBy",
            "createdAt"
          ],
          properties: {
            id: {
              type: "integer"
            },
            event: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#modEventTakedown",
                "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                "lex:tools.ozone.moderation.defs#modEventComment",
                "lex:tools.ozone.moderation.defs#modEventReport",
                "lex:tools.ozone.moderation.defs#modEventLabel",
                "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                "lex:tools.ozone.moderation.defs#modEventEscalate",
                "lex:tools.ozone.moderation.defs#modEventMute",
                "lex:tools.ozone.moderation.defs#modEventUnmute",
                "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                "lex:tools.ozone.moderation.defs#modEventEmail",
                "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                "lex:tools.ozone.moderation.defs#modEventDivert",
                "lex:tools.ozone.moderation.defs#modEventTag"
              ]
            },
            subject: {
              type: "union",
              refs: [
                "lex:com.atproto.admin.defs#repoRef",
                "lex:com.atproto.repo.strongRef",
                "lex:chat.bsky.convo.defs#messageRef"
              ]
            },
            subjectBlobCids: {
              type: "array",
              items: {
                type: "string"
              }
            },
            createdBy: {
              type: "string",
              format: "did"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            creatorHandle: {
              type: "string"
            },
            subjectHandle: {
              type: "string"
            }
          }
        },
        modEventViewDetail: {
          type: "object",
          required: [
            "id",
            "event",
            "subject",
            "subjectBlobs",
            "createdBy",
            "createdAt"
          ],
          properties: {
            id: {
              type: "integer"
            },
            event: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#modEventTakedown",
                "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                "lex:tools.ozone.moderation.defs#modEventComment",
                "lex:tools.ozone.moderation.defs#modEventReport",
                "lex:tools.ozone.moderation.defs#modEventLabel",
                "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                "lex:tools.ozone.moderation.defs#modEventEscalate",
                "lex:tools.ozone.moderation.defs#modEventMute",
                "lex:tools.ozone.moderation.defs#modEventUnmute",
                "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                "lex:tools.ozone.moderation.defs#modEventEmail",
                "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                "lex:tools.ozone.moderation.defs#modEventDivert",
                "lex:tools.ozone.moderation.defs#modEventTag"
              ]
            },
            subject: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#repoView",
                "lex:tools.ozone.moderation.defs#repoViewNotFound",
                "lex:tools.ozone.moderation.defs#recordView",
                "lex:tools.ozone.moderation.defs#recordViewNotFound"
              ]
            },
            subjectBlobs: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#blobView"
              }
            },
            createdBy: {
              type: "string",
              format: "did"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        subjectStatusView: {
          type: "object",
          required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
          properties: {
            id: {
              type: "integer"
            },
            subject: {
              type: "union",
              refs: [
                "lex:com.atproto.admin.defs#repoRef",
                "lex:com.atproto.repo.strongRef"
              ]
            },
            subjectBlobCids: {
              type: "array",
              items: {
                type: "string",
                format: "cid"
              }
            },
            subjectRepoHandle: {
              type: "string"
            },
            updatedAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing when the last update was made to the moderation status of the subject"
            },
            createdAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
            },
            reviewState: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectReviewState"
            },
            comment: {
              type: "string",
              description: "Sticky comment on the subject."
            },
            muteUntil: {
              type: "string",
              format: "datetime"
            },
            muteReportingUntil: {
              type: "string",
              format: "datetime"
            },
            lastReviewedBy: {
              type: "string",
              format: "did"
            },
            lastReviewedAt: {
              type: "string",
              format: "datetime"
            },
            lastReportedAt: {
              type: "string",
              format: "datetime"
            },
            lastAppealedAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing when the author of the subject appealed a moderation action"
            },
            takendown: {
              type: "boolean"
            },
            appealed: {
              type: "boolean",
              description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
            },
            suspendUntil: {
              type: "string",
              format: "datetime"
            },
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        },
        subjectReviewState: {
          type: "string",
          knownValues: [
            "lex:tools.ozone.moderation.defs#reviewOpen",
            "lex:tools.ozone.moderation.defs#reviewEscalated",
            "lex:tools.ozone.moderation.defs#reviewClosed",
            "lex:tools.ozone.moderation.defs#reviewNone"
          ]
        },
        reviewOpen: {
          type: "token",
          description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
        },
        reviewEscalated: {
          type: "token",
          description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
        },
        reviewClosed: {
          type: "token",
          description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
        },
        reviewNone: {
          type: "token",
          description: "Moderator review status of a subject: Unnecessary. Indicates that the subject does not need a review at the moment but there is probably some moderation related metadata available for it"
        },
        modEventTakedown: {
          type: "object",
          description: "Take down a subject permanently or temporarily",
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the takedown should be in effect before automatically expiring."
            }
          }
        },
        modEventReverseTakedown: {
          type: "object",
          description: "Revert take down action on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventResolveAppeal: {
          type: "object",
          description: "Resolve appeal on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe resolution."
            }
          }
        },
        modEventComment: {
          type: "object",
          description: "Add a comment to a subject",
          required: ["comment"],
          properties: {
            comment: {
              type: "string"
            },
            sticky: {
              type: "boolean",
              description: "Make the comment persistent on the subject"
            }
          }
        },
        modEventReport: {
          type: "object",
          description: "Report a subject",
          required: ["reportType"],
          properties: {
            comment: {
              type: "string"
            },
            isReporterMuted: {
              type: "boolean",
              description: "Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject."
            },
            reportType: {
              type: "ref",
              ref: "lex:com.atproto.moderation.defs#reasonType"
            }
          }
        },
        modEventLabel: {
          type: "object",
          description: "Apply/Negate labels on a subject",
          required: ["createLabelVals", "negateLabelVals"],
          properties: {
            comment: {
              type: "string"
            },
            createLabelVals: {
              type: "array",
              items: {
                type: "string"
              }
            },
            negateLabelVals: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        },
        modEventAcknowledge: {
          type: "object",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventEscalate: {
          type: "object",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventMute: {
          type: "object",
          description: "Mute incoming reports on a subject",
          required: ["durationInHours"],
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the subject should remain muted."
            }
          }
        },
        modEventUnmute: {
          type: "object",
          description: "Unmute action on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventMuteReporter: {
          type: "object",
          description: "Mute incoming reports from an account",
          required: ["durationInHours"],
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the account should remain muted."
            }
          }
        },
        modEventUnmuteReporter: {
          type: "object",
          description: "Unmute incoming reports from an account",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventEmail: {
          type: "object",
          description: "Keep a log of outgoing email to a user",
          required: ["subjectLine"],
          properties: {
            subjectLine: {
              type: "string",
              description: "The subject line of the email sent to the user."
            },
            content: {
              type: "string",
              description: "The content of the email sent to the user."
            },
            comment: {
              type: "string",
              description: "Additional comment about the outgoing comm."
            }
          }
        },
        modEventDivert: {
          type: "object",
          description: "Divert a record's blobs to a 3rd party service for further scanning/tagging",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventTag: {
          type: "object",
          description: "Add/Remove a tag on a subject",
          required: ["add", "remove"],
          properties: {
            add: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Tags to be added to the subject. If already exists, won't be duplicated."
            },
            remove: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated."
            },
            comment: {
              type: "string",
              description: "Additional comment about added/removed tags."
            }
          }
        },
        repoView: {
          type: "object",
          required: [
            "did",
            "handle",
            "relatedRecords",
            "indexedAt",
            "moderation"
          ],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invitesDisabled: {
              type: "boolean"
            },
            inviteNote: {
              type: "string"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoViewDetail: {
          type: "object",
          required: [
            "did",
            "handle",
            "relatedRecords",
            "indexedAt",
            "moderation"
          ],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderationDetail"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invites: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              }
            },
            invitesDisabled: {
              type: "boolean"
            },
            inviteNote: {
              type: "string"
            },
            emailConfirmedAt: {
              type: "string",
              format: "datetime"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoViewNotFound: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        recordView: {
          type: "object",
          required: [
            "uri",
            "cid",
            "value",
            "blobCids",
            "indexedAt",
            "moderation",
            "repo"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            },
            blobCids: {
              type: "array",
              items: {
                type: "string",
                format: "cid"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            },
            repo: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoView"
            }
          }
        },
        recordViewDetail: {
          type: "object",
          required: [
            "uri",
            "cid",
            "value",
            "blobs",
            "indexedAt",
            "moderation",
            "repo"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            },
            blobs: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#blobView"
              }
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderationDetail"
            },
            repo: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoView"
            }
          }
        },
        recordViewNotFound: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        moderation: {
          type: "object",
          properties: {
            subjectStatus: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
            }
          }
        },
        moderationDetail: {
          type: "object",
          properties: {
            subjectStatus: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
            }
          }
        },
        blobView: {
          type: "object",
          required: ["cid", "mimeType", "size", "createdAt"],
          properties: {
            cid: {
              type: "string",
              format: "cid"
            },
            mimeType: {
              type: "string"
            },
            size: {
              type: "integer"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            details: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#imageDetails",
                "lex:tools.ozone.moderation.defs#videoDetails"
              ]
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            }
          }
        },
        imageDetails: {
          type: "object",
          required: ["width", "height"],
          properties: {
            width: {
              type: "integer"
            },
            height: {
              type: "integer"
            }
          }
        },
        videoDetails: {
          type: "object",
          required: ["width", "height", "length"],
          properties: {
            width: {
              type: "integer"
            },
            height: {
              type: "integer"
            },
            length: {
              type: "integer"
            }
          }
        }
      }
    },
    ToolsOzoneModerationEmitEvent: {
      lexicon: 1,
      id: "tools.ozone.moderation.emitEvent",
      defs: {
        main: {
          type: "procedure",
          description: "Take a moderation action on an actor.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["event", "subject", "createdBy"],
              properties: {
                event: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#modEventTakedown",
                    "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                    "lex:tools.ozone.moderation.defs#modEventEscalate",
                    "lex:tools.ozone.moderation.defs#modEventComment",
                    "lex:tools.ozone.moderation.defs#modEventLabel",
                    "lex:tools.ozone.moderation.defs#modEventReport",
                    "lex:tools.ozone.moderation.defs#modEventMute",
                    "lex:tools.ozone.moderation.defs#modEventUnmute",
                    "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                    "lex:tools.ozone.moderation.defs#modEventEmail",
                    "lex:tools.ozone.moderation.defs#modEventTag"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#modEventView"
            }
          },
          errors: [
            {
              name: "SubjectHasAction"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationGetEvent: {
      lexicon: 1,
      id: "tools.ozone.moderation.getEvent",
      defs: {
        main: {
          type: "query",
          description: "Get details about a moderation event.",
          parameters: {
            type: "params",
            required: ["id"],
            properties: {
              id: {
                type: "integer"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#modEventViewDetail"
            }
          }
        }
      }
    },
    ToolsOzoneModerationGetRecord: {
      lexicon: 1,
      id: "tools.ozone.moderation.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get details about a record.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#recordViewDetail"
            }
          },
          errors: [
            {
              name: "RecordNotFound"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationGetRepo: {
      lexicon: 1,
      id: "tools.ozone.moderation.getRepo",
      defs: {
        main: {
          type: "query",
          description: "Get details about a repository.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoViewDetail"
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationQueryEvents: {
      lexicon: 1,
      id: "tools.ozone.moderation.queryEvents",
      defs: {
        main: {
          type: "query",
          description: "List moderation events related to a subject.",
          parameters: {
            type: "params",
            properties: {
              types: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned."
              },
              createdBy: {
                type: "string",
                format: "did"
              },
              sortDirection: {
                type: "string",
                default: "desc",
                enum: ["asc", "desc"],
                description: "Sort direction for the events. Defaults to descending order of created at timestamp."
              },
              createdAfter: {
                type: "string",
                format: "datetime",
                description: "Retrieve events created after a given timestamp"
              },
              createdBefore: {
                type: "string",
                format: "datetime",
                description: "Retrieve events created before a given timestamp"
              },
              subject: {
                type: "string",
                format: "uri"
              },
              includeAllUserRecords: {
                type: "boolean",
                default: !1,
                description: "If true, events on all record types (posts, lists, profile etc.) owned by the did are returned"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              hasComment: {
                type: "boolean",
                description: "If true, only events with comments are returned"
              },
              comment: {
                type: "string",
                description: "If specified, only events with comments containing the keyword are returned"
              },
              addedLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these labels were added are returned"
              },
              removedLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these labels were removed are returned"
              },
              addedTags: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these tags were added are returned"
              },
              removedTags: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these tags were removed are returned"
              },
              reportTypes: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["events"],
              properties: {
                cursor: {
                  type: "string"
                },
                events: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#modEventView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneModerationQueryStatuses: {
      lexicon: 1,
      id: "tools.ozone.moderation.queryStatuses",
      defs: {
        main: {
          type: "query",
          description: "View moderation statuses of subjects (record or repo).",
          parameters: {
            type: "params",
            properties: {
              subject: {
                type: "string",
                format: "uri"
              },
              comment: {
                type: "string",
                description: "Search subjects by keyword from comments"
              },
              reportedAfter: {
                type: "string",
                format: "datetime",
                description: "Search subjects reported after a given timestamp"
              },
              reportedBefore: {
                type: "string",
                format: "datetime",
                description: "Search subjects reported before a given timestamp"
              },
              reviewedAfter: {
                type: "string",
                format: "datetime",
                description: "Search subjects reviewed after a given timestamp"
              },
              reviewedBefore: {
                type: "string",
                format: "datetime",
                description: "Search subjects reviewed before a given timestamp"
              },
              includeMuted: {
                type: "boolean",
                description: "By default, we don't include muted subjects in the results. Set this to true to include them."
              },
              onlyMuted: {
                type: "boolean",
                description: "When set to true, only muted subjects and reporters will be returned."
              },
              reviewState: {
                type: "string",
                description: "Specify when fetching subjects in a certain state"
              },
              ignoreSubjects: {
                type: "array",
                items: {
                  type: "string",
                  format: "uri"
                }
              },
              lastReviewedBy: {
                type: "string",
                format: "did",
                description: "Get all subject statuses that were reviewed by a specific moderator"
              },
              sortField: {
                type: "string",
                default: "lastReportedAt",
                enum: ["lastReviewedAt", "lastReportedAt"]
              },
              sortDirection: {
                type: "string",
                default: "desc",
                enum: ["asc", "desc"]
              },
              takendown: {
                type: "boolean",
                description: "Get subjects that were taken down"
              },
              appealed: {
                type: "boolean",
                description: "Get subjects in unresolved appealed status"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              tags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              excludeTags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subjectStatuses"],
              properties: {
                cursor: {
                  type: "string"
                },
                subjectStatuses: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneModerationSearchRepos: {
      lexicon: 1,
      id: "tools.ozone.moderation.searchRepos",
      defs: {
        main: {
          type: "query",
          description: "Find repositories based on a search term.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead"
              },
              q: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repos"],
              properties: {
                cursor: {
                  type: "string"
                },
                repos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#repoView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneServerGetConfig: {
      lexicon: 1,
      id: "tools.ozone.server.getConfig",
      defs: {
        main: {
          type: "query",
          description: "Get details about ozone's server configuration.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                appview: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                pds: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                blobDivert: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                chat: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#viewerConfig"
                }
              }
            }
          }
        },
        serviceConfig: {
          type: "object",
          properties: {
            url: {
              type: "string",
              format: "uri"
            }
          }
        },
        viewerConfig: {
          type: "object",
          properties: {
            role: {
              type: "string",
              knownValues: [
                "tools.ozone.team.defs#roleAdmin",
                "tools.ozone.team.defs#roleModerator",
                "tools.ozone.team.defs#roleTriage"
              ]
            }
          }
        }
      }
    },
    ToolsOzoneTeamAddMember: {
      lexicon: 1,
      id: "tools.ozone.team.addMember",
      defs: {
        main: {
          type: "procedure",
          description: "Add a member to the ozone team. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "role"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                role: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleAdmin",
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.team.defs#member"
            }
          },
          errors: [
            {
              name: "MemberAlreadyExists",
              description: "Member already exists in the team."
            }
          ]
        }
      }
    },
    ToolsOzoneTeamDefs: {
      lexicon: 1,
      id: "tools.ozone.team.defs",
      defs: {
        member: {
          type: "object",
          required: ["did", "role"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            disabled: {
              type: "boolean"
            },
            profile: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewDetailed"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            updatedAt: {
              type: "string",
              format: "datetime"
            },
            lastUpdatedBy: {
              type: "string"
            },
            role: {
              type: "string",
              knownValues: [
                "lex:tools.ozone.team.defs#roleAdmin",
                "lex:tools.ozone.team.defs#roleModerator",
                "lex:tools.ozone.team.defs#roleTriage"
              ]
            }
          }
        },
        roleAdmin: {
          type: "token",
          description: "Admin role. Highest level of access, can perform all actions."
        },
        roleModerator: {
          type: "token",
          description: "Moderator role. Can perform most actions."
        },
        roleTriage: {
          type: "token",
          description: "Triage role. Mostly intended for monitoring and escalating issues."
        }
      }
    },
    ToolsOzoneTeamDeleteMember: {
      lexicon: 1,
      id: "tools.ozone.team.deleteMember",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a member from ozone team. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          errors: [
            {
              name: "MemberNotFound",
              description: "The member being deleted does not exist"
            },
            {
              name: "CannotDeleteSelf",
              description: "You can not delete yourself from the team"
            }
          ]
        }
      }
    },
    ToolsOzoneTeamListMembers: {
      lexicon: 1,
      id: "tools.ozone.team.listMembers",
      defs: {
        main: {
          type: "query",
          description: "List all members with access to the ozone service.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["members"],
              properties: {
                cursor: {
                  type: "string"
                },
                members: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.team.defs#member"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneTeamUpdateMember: {
      lexicon: 1,
      id: "tools.ozone.team.updateMember",
      defs: {
        main: {
          type: "procedure",
          description: "Update a member in the ozone service. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                disabled: {
                  type: "boolean"
                },
                role: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleAdmin",
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.team.defs#member"
            }
          },
          errors: [
            {
              name: "MemberNotFound",
              description: "The member being updated does not exist in the team"
            }
          ]
        }
      }
    }
  }, t.schemas = Object.values(t.schemaDict), t.lexicons = new e.Lexicons(t.schemas), t.ids = {
    ComAtprotoAdminDefs: "com.atproto.admin.defs",
    ComAtprotoAdminDeleteAccount: "com.atproto.admin.deleteAccount",
    ComAtprotoAdminDisableAccountInvites: "com.atproto.admin.disableAccountInvites",
    ComAtprotoAdminDisableInviteCodes: "com.atproto.admin.disableInviteCodes",
    ComAtprotoAdminEnableAccountInvites: "com.atproto.admin.enableAccountInvites",
    ComAtprotoAdminGetAccountInfo: "com.atproto.admin.getAccountInfo",
    ComAtprotoAdminGetAccountInfos: "com.atproto.admin.getAccountInfos",
    ComAtprotoAdminGetInviteCodes: "com.atproto.admin.getInviteCodes",
    ComAtprotoAdminGetSubjectStatus: "com.atproto.admin.getSubjectStatus",
    ComAtprotoAdminSearchAccounts: "com.atproto.admin.searchAccounts",
    ComAtprotoAdminSendEmail: "com.atproto.admin.sendEmail",
    ComAtprotoAdminUpdateAccountEmail: "com.atproto.admin.updateAccountEmail",
    ComAtprotoAdminUpdateAccountHandle: "com.atproto.admin.updateAccountHandle",
    ComAtprotoAdminUpdateAccountPassword: "com.atproto.admin.updateAccountPassword",
    ComAtprotoAdminUpdateSubjectStatus: "com.atproto.admin.updateSubjectStatus",
    ComAtprotoIdentityGetRecommendedDidCredentials: "com.atproto.identity.getRecommendedDidCredentials",
    ComAtprotoIdentityRequestPlcOperationSignature: "com.atproto.identity.requestPlcOperationSignature",
    ComAtprotoIdentityResolveHandle: "com.atproto.identity.resolveHandle",
    ComAtprotoIdentitySignPlcOperation: "com.atproto.identity.signPlcOperation",
    ComAtprotoIdentitySubmitPlcOperation: "com.atproto.identity.submitPlcOperation",
    ComAtprotoIdentityUpdateHandle: "com.atproto.identity.updateHandle",
    ComAtprotoLabelDefs: "com.atproto.label.defs",
    ComAtprotoLabelQueryLabels: "com.atproto.label.queryLabels",
    ComAtprotoLabelSubscribeLabels: "com.atproto.label.subscribeLabels",
    ComAtprotoModerationCreateReport: "com.atproto.moderation.createReport",
    ComAtprotoModerationDefs: "com.atproto.moderation.defs",
    ComAtprotoRepoApplyWrites: "com.atproto.repo.applyWrites",
    ComAtprotoRepoCreateRecord: "com.atproto.repo.createRecord",
    ComAtprotoRepoDeleteRecord: "com.atproto.repo.deleteRecord",
    ComAtprotoRepoDescribeRepo: "com.atproto.repo.describeRepo",
    ComAtprotoRepoGetRecord: "com.atproto.repo.getRecord",
    ComAtprotoRepoImportRepo: "com.atproto.repo.importRepo",
    ComAtprotoRepoListMissingBlobs: "com.atproto.repo.listMissingBlobs",
    ComAtprotoRepoListRecords: "com.atproto.repo.listRecords",
    ComAtprotoRepoPutRecord: "com.atproto.repo.putRecord",
    ComAtprotoRepoStrongRef: "com.atproto.repo.strongRef",
    ComAtprotoRepoUploadBlob: "com.atproto.repo.uploadBlob",
    ComAtprotoServerActivateAccount: "com.atproto.server.activateAccount",
    ComAtprotoServerCheckAccountStatus: "com.atproto.server.checkAccountStatus",
    ComAtprotoServerConfirmEmail: "com.atproto.server.confirmEmail",
    ComAtprotoServerCreateAccount: "com.atproto.server.createAccount",
    ComAtprotoServerCreateAppPassword: "com.atproto.server.createAppPassword",
    ComAtprotoServerCreateInviteCode: "com.atproto.server.createInviteCode",
    ComAtprotoServerCreateInviteCodes: "com.atproto.server.createInviteCodes",
    ComAtprotoServerCreateSession: "com.atproto.server.createSession",
    ComAtprotoServerDeactivateAccount: "com.atproto.server.deactivateAccount",
    ComAtprotoServerDefs: "com.atproto.server.defs",
    ComAtprotoServerDeleteAccount: "com.atproto.server.deleteAccount",
    ComAtprotoServerDeleteSession: "com.atproto.server.deleteSession",
    ComAtprotoServerDescribeServer: "com.atproto.server.describeServer",
    ComAtprotoServerGetAccountInviteCodes: "com.atproto.server.getAccountInviteCodes",
    ComAtprotoServerGetServiceAuth: "com.atproto.server.getServiceAuth",
    ComAtprotoServerGetSession: "com.atproto.server.getSession",
    ComAtprotoServerListAppPasswords: "com.atproto.server.listAppPasswords",
    ComAtprotoServerRefreshSession: "com.atproto.server.refreshSession",
    ComAtprotoServerRequestAccountDelete: "com.atproto.server.requestAccountDelete",
    ComAtprotoServerRequestEmailConfirmation: "com.atproto.server.requestEmailConfirmation",
    ComAtprotoServerRequestEmailUpdate: "com.atproto.server.requestEmailUpdate",
    ComAtprotoServerRequestPasswordReset: "com.atproto.server.requestPasswordReset",
    ComAtprotoServerReserveSigningKey: "com.atproto.server.reserveSigningKey",
    ComAtprotoServerResetPassword: "com.atproto.server.resetPassword",
    ComAtprotoServerRevokeAppPassword: "com.atproto.server.revokeAppPassword",
    ComAtprotoServerUpdateEmail: "com.atproto.server.updateEmail",
    ComAtprotoSyncGetBlob: "com.atproto.sync.getBlob",
    ComAtprotoSyncGetBlocks: "com.atproto.sync.getBlocks",
    ComAtprotoSyncGetCheckout: "com.atproto.sync.getCheckout",
    ComAtprotoSyncGetHead: "com.atproto.sync.getHead",
    ComAtprotoSyncGetLatestCommit: "com.atproto.sync.getLatestCommit",
    ComAtprotoSyncGetRecord: "com.atproto.sync.getRecord",
    ComAtprotoSyncGetRepo: "com.atproto.sync.getRepo",
    ComAtprotoSyncGetRepoStatus: "com.atproto.sync.getRepoStatus",
    ComAtprotoSyncListBlobs: "com.atproto.sync.listBlobs",
    ComAtprotoSyncListRepos: "com.atproto.sync.listRepos",
    ComAtprotoSyncNotifyOfUpdate: "com.atproto.sync.notifyOfUpdate",
    ComAtprotoSyncRequestCrawl: "com.atproto.sync.requestCrawl",
    ComAtprotoSyncSubscribeRepos: "com.atproto.sync.subscribeRepos",
    ComAtprotoTempCheckSignupQueue: "com.atproto.temp.checkSignupQueue",
    ComAtprotoTempFetchLabels: "com.atproto.temp.fetchLabels",
    ComAtprotoTempRequestPhoneVerification: "com.atproto.temp.requestPhoneVerification",
    AppBskyActorDefs: "app.bsky.actor.defs",
    AppBskyActorGetPreferences: "app.bsky.actor.getPreferences",
    AppBskyActorGetProfile: "app.bsky.actor.getProfile",
    AppBskyActorGetProfiles: "app.bsky.actor.getProfiles",
    AppBskyActorGetSuggestions: "app.bsky.actor.getSuggestions",
    AppBskyActorProfile: "app.bsky.actor.profile",
    AppBskyActorPutPreferences: "app.bsky.actor.putPreferences",
    AppBskyActorSearchActors: "app.bsky.actor.searchActors",
    AppBskyActorSearchActorsTypeahead: "app.bsky.actor.searchActorsTypeahead",
    AppBskyEmbedExternal: "app.bsky.embed.external",
    AppBskyEmbedImages: "app.bsky.embed.images",
    AppBskyEmbedRecord: "app.bsky.embed.record",
    AppBskyEmbedRecordWithMedia: "app.bsky.embed.recordWithMedia",
    AppBskyFeedDefs: "app.bsky.feed.defs",
    AppBskyFeedDescribeFeedGenerator: "app.bsky.feed.describeFeedGenerator",
    AppBskyFeedGenerator: "app.bsky.feed.generator",
    AppBskyFeedGetActorFeeds: "app.bsky.feed.getActorFeeds",
    AppBskyFeedGetActorLikes: "app.bsky.feed.getActorLikes",
    AppBskyFeedGetAuthorFeed: "app.bsky.feed.getAuthorFeed",
    AppBskyFeedGetFeed: "app.bsky.feed.getFeed",
    AppBskyFeedGetFeedGenerator: "app.bsky.feed.getFeedGenerator",
    AppBskyFeedGetFeedGenerators: "app.bsky.feed.getFeedGenerators",
    AppBskyFeedGetFeedSkeleton: "app.bsky.feed.getFeedSkeleton",
    AppBskyFeedGetLikes: "app.bsky.feed.getLikes",
    AppBskyFeedGetListFeed: "app.bsky.feed.getListFeed",
    AppBskyFeedGetPostThread: "app.bsky.feed.getPostThread",
    AppBskyFeedGetPosts: "app.bsky.feed.getPosts",
    AppBskyFeedGetRepostedBy: "app.bsky.feed.getRepostedBy",
    AppBskyFeedGetSuggestedFeeds: "app.bsky.feed.getSuggestedFeeds",
    AppBskyFeedGetTimeline: "app.bsky.feed.getTimeline",
    AppBskyFeedLike: "app.bsky.feed.like",
    AppBskyFeedPost: "app.bsky.feed.post",
    AppBskyFeedRepost: "app.bsky.feed.repost",
    AppBskyFeedSearchPosts: "app.bsky.feed.searchPosts",
    AppBskyFeedSendInteractions: "app.bsky.feed.sendInteractions",
    AppBskyFeedThreadgate: "app.bsky.feed.threadgate",
    AppBskyGraphBlock: "app.bsky.graph.block",
    AppBskyGraphDefs: "app.bsky.graph.defs",
    AppBskyGraphFollow: "app.bsky.graph.follow",
    AppBskyGraphGetActorStarterPacks: "app.bsky.graph.getActorStarterPacks",
    AppBskyGraphGetBlocks: "app.bsky.graph.getBlocks",
    AppBskyGraphGetFollowers: "app.bsky.graph.getFollowers",
    AppBskyGraphGetFollows: "app.bsky.graph.getFollows",
    AppBskyGraphGetKnownFollowers: "app.bsky.graph.getKnownFollowers",
    AppBskyGraphGetList: "app.bsky.graph.getList",
    AppBskyGraphGetListBlocks: "app.bsky.graph.getListBlocks",
    AppBskyGraphGetListMutes: "app.bsky.graph.getListMutes",
    AppBskyGraphGetLists: "app.bsky.graph.getLists",
    AppBskyGraphGetMutes: "app.bsky.graph.getMutes",
    AppBskyGraphGetRelationships: "app.bsky.graph.getRelationships",
    AppBskyGraphGetStarterPack: "app.bsky.graph.getStarterPack",
    AppBskyGraphGetStarterPacks: "app.bsky.graph.getStarterPacks",
    AppBskyGraphGetSuggestedFollowsByActor: "app.bsky.graph.getSuggestedFollowsByActor",
    AppBskyGraphList: "app.bsky.graph.list",
    AppBskyGraphListblock: "app.bsky.graph.listblock",
    AppBskyGraphListitem: "app.bsky.graph.listitem",
    AppBskyGraphMuteActor: "app.bsky.graph.muteActor",
    AppBskyGraphMuteActorList: "app.bsky.graph.muteActorList",
    AppBskyGraphMuteThread: "app.bsky.graph.muteThread",
    AppBskyGraphStarterpack: "app.bsky.graph.starterpack",
    AppBskyGraphUnmuteActor: "app.bsky.graph.unmuteActor",
    AppBskyGraphUnmuteActorList: "app.bsky.graph.unmuteActorList",
    AppBskyGraphUnmuteThread: "app.bsky.graph.unmuteThread",
    AppBskyLabelerDefs: "app.bsky.labeler.defs",
    AppBskyLabelerGetServices: "app.bsky.labeler.getServices",
    AppBskyLabelerService: "app.bsky.labeler.service",
    AppBskyNotificationGetUnreadCount: "app.bsky.notification.getUnreadCount",
    AppBskyNotificationListNotifications: "app.bsky.notification.listNotifications",
    AppBskyNotificationPutPreferences: "app.bsky.notification.putPreferences",
    AppBskyNotificationRegisterPush: "app.bsky.notification.registerPush",
    AppBskyNotificationUpdateSeen: "app.bsky.notification.updateSeen",
    AppBskyRichtextFacet: "app.bsky.richtext.facet",
    AppBskyUnspeccedDefs: "app.bsky.unspecced.defs",
    AppBskyUnspeccedGetPopularFeedGenerators: "app.bsky.unspecced.getPopularFeedGenerators",
    AppBskyUnspeccedGetSuggestionsSkeleton: "app.bsky.unspecced.getSuggestionsSkeleton",
    AppBskyUnspeccedGetTaggedSuggestions: "app.bsky.unspecced.getTaggedSuggestions",
    AppBskyUnspeccedSearchActorsSkeleton: "app.bsky.unspecced.searchActorsSkeleton",
    AppBskyUnspeccedSearchPostsSkeleton: "app.bsky.unspecced.searchPostsSkeleton",
    ChatBskyActorDeclaration: "chat.bsky.actor.declaration",
    ChatBskyActorDefs: "chat.bsky.actor.defs",
    ChatBskyActorDeleteAccount: "chat.bsky.actor.deleteAccount",
    ChatBskyActorExportAccountData: "chat.bsky.actor.exportAccountData",
    ChatBskyConvoDefs: "chat.bsky.convo.defs",
    ChatBskyConvoDeleteMessageForSelf: "chat.bsky.convo.deleteMessageForSelf",
    ChatBskyConvoGetConvo: "chat.bsky.convo.getConvo",
    ChatBskyConvoGetConvoForMembers: "chat.bsky.convo.getConvoForMembers",
    ChatBskyConvoGetLog: "chat.bsky.convo.getLog",
    ChatBskyConvoGetMessages: "chat.bsky.convo.getMessages",
    ChatBskyConvoLeaveConvo: "chat.bsky.convo.leaveConvo",
    ChatBskyConvoListConvos: "chat.bsky.convo.listConvos",
    ChatBskyConvoMuteConvo: "chat.bsky.convo.muteConvo",
    ChatBskyConvoSendMessage: "chat.bsky.convo.sendMessage",
    ChatBskyConvoSendMessageBatch: "chat.bsky.convo.sendMessageBatch",
    ChatBskyConvoUnmuteConvo: "chat.bsky.convo.unmuteConvo",
    ChatBskyConvoUpdateRead: "chat.bsky.convo.updateRead",
    ChatBskyModerationGetActorMetadata: "chat.bsky.moderation.getActorMetadata",
    ChatBskyModerationGetMessageContext: "chat.bsky.moderation.getMessageContext",
    ChatBskyModerationUpdateActorAccess: "chat.bsky.moderation.updateActorAccess",
    ToolsOzoneCommunicationCreateTemplate: "tools.ozone.communication.createTemplate",
    ToolsOzoneCommunicationDefs: "tools.ozone.communication.defs",
    ToolsOzoneCommunicationDeleteTemplate: "tools.ozone.communication.deleteTemplate",
    ToolsOzoneCommunicationListTemplates: "tools.ozone.communication.listTemplates",
    ToolsOzoneCommunicationUpdateTemplate: "tools.ozone.communication.updateTemplate",
    ToolsOzoneModerationDefs: "tools.ozone.moderation.defs",
    ToolsOzoneModerationEmitEvent: "tools.ozone.moderation.emitEvent",
    ToolsOzoneModerationGetEvent: "tools.ozone.moderation.getEvent",
    ToolsOzoneModerationGetRecord: "tools.ozone.moderation.getRecord",
    ToolsOzoneModerationGetRepo: "tools.ozone.moderation.getRepo",
    ToolsOzoneModerationQueryEvents: "tools.ozone.moderation.queryEvents",
    ToolsOzoneModerationQueryStatuses: "tools.ozone.moderation.queryStatuses",
    ToolsOzoneModerationSearchRepos: "tools.ozone.moderation.searchRepos",
    ToolsOzoneServerGetConfig: "tools.ozone.server.getConfig",
    ToolsOzoneTeamAddMember: "tools.ozone.team.addMember",
    ToolsOzoneTeamDefs: "tools.ozone.team.defs",
    ToolsOzoneTeamDeleteMember: "tools.ozone.team.deleteMember",
    ToolsOzoneTeamListMembers: "tools.ozone.team.listMembers",
    ToolsOzoneTeamUpdateMember: "tools.ozone.team.updateMember"
  };
})(Ie);
var as = {};
Object.defineProperty(as, "__esModule", { value: !0 });
as.toKnownErr = void 0;
const Ix = Z;
function Ux(t) {
  return t instanceof Ix.XRPCError, t;
}
as.toKnownErr = Ux;
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
ss.toKnownErr = void 0;
const Ox = Z;
function Kx(t) {
  return t instanceof Ox.XRPCError, t;
}
ss.toKnownErr = Kx;
var os = {};
Object.defineProperty(os, "__esModule", { value: !0 });
os.toKnownErr = void 0;
const Mx = Z;
function Nx(t) {
  return t instanceof Mx.XRPCError, t;
}
os.toKnownErr = Nx;
var ls = {};
Object.defineProperty(ls, "__esModule", { value: !0 });
ls.toKnownErr = void 0;
const Vx = Z;
function jx(t) {
  return t instanceof Vx.XRPCError, t;
}
ls.toKnownErr = jx;
var us = {};
Object.defineProperty(us, "__esModule", { value: !0 });
us.toKnownErr = void 0;
const Fx = Z;
function $x(t) {
  return t instanceof Fx.XRPCError, t;
}
us.toKnownErr = $x;
var cs = {};
Object.defineProperty(cs, "__esModule", { value: !0 });
cs.toKnownErr = void 0;
const Gx = Z;
function qx(t) {
  return t instanceof Gx.XRPCError, t;
}
cs.toKnownErr = qx;
var ds = {};
Object.defineProperty(ds, "__esModule", { value: !0 });
ds.toKnownErr = void 0;
const Xx = Z;
function zx(t) {
  return t instanceof Xx.XRPCError, t;
}
ds.toKnownErr = zx;
var fs = {};
Object.defineProperty(fs, "__esModule", { value: !0 });
fs.toKnownErr = void 0;
const Hx = Z;
function Zx(t) {
  return t instanceof Hx.XRPCError, t;
}
fs.toKnownErr = Zx;
var ps = {};
Object.defineProperty(ps, "__esModule", { value: !0 });
ps.toKnownErr = void 0;
const Wx = Z;
function Yx(t) {
  return t instanceof Wx.XRPCError, t;
}
ps.toKnownErr = Yx;
var hs = {};
Object.defineProperty(hs, "__esModule", { value: !0 });
hs.toKnownErr = void 0;
const Jx = Z;
function Qx(t) {
  return t instanceof Jx.XRPCError, t;
}
hs.toKnownErr = Qx;
var ms = {};
Object.defineProperty(ms, "__esModule", { value: !0 });
ms.toKnownErr = void 0;
const eE = Z;
function tE(t) {
  return t instanceof eE.XRPCError, t;
}
ms.toKnownErr = tE;
var ys = {};
Object.defineProperty(ys, "__esModule", { value: !0 });
ys.toKnownErr = void 0;
const rE = Z;
function iE(t) {
  return t instanceof rE.XRPCError, t;
}
ys.toKnownErr = iE;
var bs = {};
Object.defineProperty(bs, "__esModule", { value: !0 });
bs.toKnownErr = void 0;
const nE = Z;
function aE(t) {
  return t instanceof nE.XRPCError, t;
}
bs.toKnownErr = aE;
var gs = {};
Object.defineProperty(gs, "__esModule", { value: !0 });
gs.toKnownErr = void 0;
const sE = Z;
function oE(t) {
  return t instanceof sE.XRPCError, t;
}
gs.toKnownErr = oE;
var xs = {};
Object.defineProperty(xs, "__esModule", { value: !0 });
xs.toKnownErr = void 0;
const lE = Z;
function uE(t) {
  return t instanceof lE.XRPCError, t;
}
xs.toKnownErr = uE;
var Es = {};
Object.defineProperty(Es, "__esModule", { value: !0 });
Es.toKnownErr = void 0;
const cE = Z;
function dE(t) {
  return t instanceof cE.XRPCError, t;
}
Es.toKnownErr = dE;
var vs = {};
Object.defineProperty(vs, "__esModule", { value: !0 });
vs.toKnownErr = void 0;
const fE = Z;
function pE(t) {
  return t instanceof fE.XRPCError, t;
}
vs.toKnownErr = pE;
var Rs = {};
Object.defineProperty(Rs, "__esModule", { value: !0 });
Rs.toKnownErr = void 0;
const hE = Z;
function mE(t) {
  return t instanceof hE.XRPCError, t;
}
Rs.toKnownErr = mE;
var As = {};
Object.defineProperty(As, "__esModule", { value: !0 });
As.toKnownErr = void 0;
const yE = Z;
function bE(t) {
  return t instanceof yE.XRPCError, t;
}
As.toKnownErr = bE;
var _s = {};
Object.defineProperty(_s, "__esModule", { value: !0 });
_s.toKnownErr = void 0;
const gE = Z;
function xE(t) {
  return t instanceof gE.XRPCError, t;
}
_s.toKnownErr = xE;
var ws = {};
Object.defineProperty(ws, "__esModule", { value: !0 });
ws.toKnownErr = void 0;
const EE = Z;
function vE(t) {
  return t instanceof EE.XRPCError, t;
}
ws.toKnownErr = vE;
var Ts = {};
Object.defineProperty(Ts, "__esModule", { value: !0 });
Ts.toKnownErr = void 0;
const RE = Z;
function AE(t) {
  return t instanceof RE.XRPCError, t;
}
Ts.toKnownErr = AE;
var jt = {}, ke = {};
Object.defineProperty(ke, "__esModule", { value: !0 });
ke.hasProp = ke.isObj = void 0;
function _E(t) {
  return typeof t == "object" && t !== null;
}
ke.isObj = _E;
function wE(t, e) {
  return e in t;
}
ke.hasProp = wE;
Object.defineProperty(jt, "__esModule", { value: !0 });
jt.validateDelete = jt.isDelete = jt.validateUpdate = jt.isUpdate = jt.validateCreate = jt.isCreate = jt.toKnownErr = jt.InvalidSwapError = void 0;
const Xf = Z, ma = ke, sc = Ie;
let zf = class extends Xf.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
jt.InvalidSwapError = zf;
function TE(t) {
  return t instanceof Xf.XRPCError && t.error === "InvalidSwap" ? new zf(t) : t;
}
jt.toKnownErr = TE;
function SE(t) {
  return (0, ma.isObj)(t) && (0, ma.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#create";
}
jt.isCreate = SE;
function CE(t) {
  return sc.lexicons.validate("com.atproto.repo.applyWrites#create", t);
}
jt.validateCreate = CE;
function LE(t) {
  return (0, ma.isObj)(t) && (0, ma.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#update";
}
jt.isUpdate = LE;
function kE(t) {
  return sc.lexicons.validate("com.atproto.repo.applyWrites#update", t);
}
jt.validateUpdate = kE;
function DE(t) {
  return (0, ma.isObj)(t) && (0, ma.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#delete";
}
jt.isDelete = DE;
function PE(t) {
  return sc.lexicons.validate("com.atproto.repo.applyWrites#delete", t);
}
jt.validateDelete = PE;
var Un = {};
Object.defineProperty(Un, "__esModule", { value: !0 });
Un.toKnownErr = Un.InvalidSwapError = void 0;
const Hf = Z;
let Zf = class extends Hf.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Un.InvalidSwapError = Zf;
function BE(t) {
  return t instanceof Hf.XRPCError && t.error === "InvalidSwap" ? new Zf(t) : t;
}
Un.toKnownErr = BE;
var On = {};
Object.defineProperty(On, "__esModule", { value: !0 });
On.toKnownErr = On.InvalidSwapError = void 0;
const Wf = Z;
let Yf = class extends Wf.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
On.InvalidSwapError = Yf;
function IE(t) {
  return t instanceof Wf.XRPCError && t.error === "InvalidSwap" ? new Yf(t) : t;
}
On.toKnownErr = IE;
var Ss = {};
Object.defineProperty(Ss, "__esModule", { value: !0 });
Ss.toKnownErr = void 0;
const UE = Z;
function OE(t) {
  return t instanceof UE.XRPCError, t;
}
Ss.toKnownErr = OE;
var Cs = {};
Object.defineProperty(Cs, "__esModule", { value: !0 });
Cs.toKnownErr = void 0;
const KE = Z;
function ME(t) {
  return t instanceof KE.XRPCError, t;
}
Cs.toKnownErr = ME;
var Ls = {};
Object.defineProperty(Ls, "__esModule", { value: !0 });
Ls.toKnownErr = void 0;
const NE = Z;
function VE(t) {
  return t instanceof NE.XRPCError, t;
}
Ls.toKnownErr = VE;
var Zi = {};
Object.defineProperty(Zi, "__esModule", { value: !0 });
Zi.validateRecordBlob = Zi.isRecordBlob = Zi.toKnownErr = void 0;
const jE = Z, Zc = ke, FE = Ie;
function $E(t) {
  return t instanceof jE.XRPCError, t;
}
Zi.toKnownErr = $E;
function GE(t) {
  return (0, Zc.isObj)(t) && (0, Zc.hasProp)(t, "$type") && t.$type === "com.atproto.repo.listMissingBlobs#recordBlob";
}
Zi.isRecordBlob = GE;
function qE(t) {
  return FE.lexicons.validate("com.atproto.repo.listMissingBlobs#recordBlob", t);
}
Zi.validateRecordBlob = qE;
var Wi = {};
Object.defineProperty(Wi, "__esModule", { value: !0 });
Wi.validateRecord = Wi.isRecord = Wi.toKnownErr = void 0;
const XE = Z, Wc = ke, zE = Ie;
function HE(t) {
  return t instanceof XE.XRPCError, t;
}
Wi.toKnownErr = HE;
function ZE(t) {
  return (0, Wc.isObj)(t) && (0, Wc.hasProp)(t, "$type") && t.$type === "com.atproto.repo.listRecords#record";
}
Wi.isRecord = ZE;
function WE(t) {
  return zE.lexicons.validate("com.atproto.repo.listRecords#record", t);
}
Wi.validateRecord = WE;
var Kn = {};
Object.defineProperty(Kn, "__esModule", { value: !0 });
Kn.toKnownErr = Kn.InvalidSwapError = void 0;
const Jf = Z;
class Qf extends Jf.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Kn.InvalidSwapError = Qf;
function YE(t) {
  return t instanceof Jf.XRPCError && t.error === "InvalidSwap" ? new Qf(t) : t;
}
Kn.toKnownErr = YE;
var ks = {};
Object.defineProperty(ks, "__esModule", { value: !0 });
ks.toKnownErr = void 0;
const JE = Z;
function QE(t) {
  return t instanceof JE.XRPCError, t;
}
ks.toKnownErr = QE;
var Ds = {};
Object.defineProperty(Ds, "__esModule", { value: !0 });
Ds.toKnownErr = void 0;
const ev = Z;
function tv(t) {
  return t instanceof ev.XRPCError, t;
}
Ds.toKnownErr = tv;
var Ps = {};
Object.defineProperty(Ps, "__esModule", { value: !0 });
Ps.toKnownErr = void 0;
const rv = Z;
function iv(t) {
  return t instanceof rv.XRPCError, t;
}
Ps.toKnownErr = iv;
var Pr = {};
Object.defineProperty(Pr, "__esModule", { value: !0 });
Pr.toKnownErr = Pr.InvalidEmailError = Pr.InvalidTokenError = Pr.ExpiredTokenError = Pr.AccountNotFoundError = void 0;
const Bs = Z;
class ep extends Bs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Pr.AccountNotFoundError = ep;
let tp = class extends Bs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Pr.ExpiredTokenError = tp;
let rp = class extends Bs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Pr.InvalidTokenError = rp;
class ip extends Bs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Pr.InvalidEmailError = ip;
function nv(t) {
  if (t instanceof Bs.XRPCError) {
    if (t.error === "AccountNotFound")
      return new ep(t);
    if (t.error === "ExpiredToken")
      return new tp(t);
    if (t.error === "InvalidToken")
      return new rp(t);
    if (t.error === "InvalidEmail")
      return new ip(t);
  }
  return t;
}
Pr.toKnownErr = nv;
var Ft = {};
Object.defineProperty(Ft, "__esModule", { value: !0 });
Ft.toKnownErr = Ft.IncompatibleDidDocError = Ft.UnresolvableDidError = Ft.UnsupportedDomainError = Ft.HandleNotAvailableError = Ft.InvalidInviteCodeError = Ft.InvalidPasswordError = Ft.InvalidHandleError = void 0;
const Sn = Z;
class np extends Sn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ft.InvalidHandleError = np;
class ap extends Sn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ft.InvalidPasswordError = ap;
class sp extends Sn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ft.InvalidInviteCodeError = sp;
class op extends Sn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ft.HandleNotAvailableError = op;
class lp extends Sn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ft.UnsupportedDomainError = lp;
class up extends Sn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ft.UnresolvableDidError = up;
class cp extends Sn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ft.IncompatibleDidDocError = cp;
function av(t) {
  if (t instanceof Sn.XRPCError) {
    if (t.error === "InvalidHandle")
      return new np(t);
    if (t.error === "InvalidPassword")
      return new ap(t);
    if (t.error === "InvalidInviteCode")
      return new sp(t);
    if (t.error === "HandleNotAvailable")
      return new op(t);
    if (t.error === "UnsupportedDomain")
      return new lp(t);
    if (t.error === "UnresolvableDid")
      return new up(t);
    if (t.error === "IncompatibleDidDoc")
      return new cp(t);
  }
  return t;
}
Ft.toKnownErr = av;
var ri = {};
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.validateAppPassword = ri.isAppPassword = ri.toKnownErr = ri.AccountTakedownError = void 0;
const dp = Z, Yc = ke, sv = Ie;
let fp = class extends dp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ri.AccountTakedownError = fp;
function ov(t) {
  return t instanceof dp.XRPCError && t.error === "AccountTakedown" ? new fp(t) : t;
}
ri.toKnownErr = ov;
function lv(t) {
  return (0, Yc.isObj)(t) && (0, Yc.hasProp)(t, "$type") && t.$type === "com.atproto.server.createAppPassword#appPassword";
}
ri.isAppPassword = lv;
function uv(t) {
  return sv.lexicons.validate("com.atproto.server.createAppPassword#appPassword", t);
}
ri.validateAppPassword = uv;
var Is = {};
Object.defineProperty(Is, "__esModule", { value: !0 });
Is.toKnownErr = void 0;
const cv = Z;
function dv(t) {
  return t instanceof cv.XRPCError, t;
}
Is.toKnownErr = dv;
var Yi = {};
Object.defineProperty(Yi, "__esModule", { value: !0 });
Yi.validateAccountCodes = Yi.isAccountCodes = Yi.toKnownErr = void 0;
const fv = Z, Jc = ke, pv = Ie;
function hv(t) {
  return t instanceof fv.XRPCError, t;
}
Yi.toKnownErr = hv;
function mv(t) {
  return (0, Jc.isObj)(t) && (0, Jc.hasProp)(t, "$type") && t.$type === "com.atproto.server.createInviteCodes#accountCodes";
}
Yi.isAccountCodes = mv;
function yv(t) {
  return pv.lexicons.validate("com.atproto.server.createInviteCodes#accountCodes", t);
}
Yi.validateAccountCodes = yv;
var Ji = {};
Object.defineProperty(Ji, "__esModule", { value: !0 });
Ji.toKnownErr = Ji.AuthFactorTokenRequiredError = Ji.AccountTakedownError = void 0;
const oc = Z;
let pp = class extends oc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ji.AccountTakedownError = pp;
class hp extends oc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ji.AuthFactorTokenRequiredError = hp;
function bv(t) {
  if (t instanceof oc.XRPCError) {
    if (t.error === "AccountTakedown")
      return new pp(t);
    if (t.error === "AuthFactorTokenRequired")
      return new hp(t);
  }
  return t;
}
Ji.toKnownErr = bv;
var Us = {};
Object.defineProperty(Us, "__esModule", { value: !0 });
Us.toKnownErr = void 0;
const gv = Z;
function xv(t) {
  return t instanceof gv.XRPCError, t;
}
Us.toKnownErr = xv;
var Qi = {};
Object.defineProperty(Qi, "__esModule", { value: !0 });
Qi.toKnownErr = Qi.InvalidTokenError = Qi.ExpiredTokenError = void 0;
const lc = Z;
let mp = class extends lc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Qi.ExpiredTokenError = mp;
let yp = class extends lc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Qi.InvalidTokenError = yp;
function Ev(t) {
  if (t instanceof lc.XRPCError) {
    if (t.error === "ExpiredToken")
      return new mp(t);
    if (t.error === "InvalidToken")
      return new yp(t);
  }
  return t;
}
Qi.toKnownErr = Ev;
var Os = {};
Object.defineProperty(Os, "__esModule", { value: !0 });
Os.toKnownErr = void 0;
const vv = Z;
function Rv(t) {
  return t instanceof vv.XRPCError, t;
}
Os.toKnownErr = Rv;
var Br = {};
Object.defineProperty(Br, "__esModule", { value: !0 });
Br.validateContact = Br.isContact = Br.validateLinks = Br.isLinks = Br.toKnownErr = void 0;
const Av = Z, Vl = ke, bp = Ie;
function _v(t) {
  return t instanceof Av.XRPCError, t;
}
Br.toKnownErr = _v;
function wv(t) {
  return (0, Vl.isObj)(t) && (0, Vl.hasProp)(t, "$type") && t.$type === "com.atproto.server.describeServer#links";
}
Br.isLinks = wv;
function Tv(t) {
  return bp.lexicons.validate("com.atproto.server.describeServer#links", t);
}
Br.validateLinks = Tv;
function Sv(t) {
  return (0, Vl.isObj)(t) && (0, Vl.hasProp)(t, "$type") && t.$type === "com.atproto.server.describeServer#contact";
}
Br.isContact = Sv;
function Cv(t) {
  return bp.lexicons.validate("com.atproto.server.describeServer#contact", t);
}
Br.validateContact = Cv;
var Mn = {};
Object.defineProperty(Mn, "__esModule", { value: !0 });
Mn.toKnownErr = Mn.DuplicateCreateError = void 0;
const gp = Z;
class xp extends gp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Mn.DuplicateCreateError = xp;
function Lv(t) {
  return t instanceof gp.XRPCError && t.error === "DuplicateCreate" ? new xp(t) : t;
}
Mn.toKnownErr = Lv;
var Nn = {};
Object.defineProperty(Nn, "__esModule", { value: !0 });
Nn.toKnownErr = Nn.BadExpirationError = void 0;
const Ep = Z;
class vp extends Ep.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Nn.BadExpirationError = vp;
function kv(t) {
  return t instanceof Ep.XRPCError && t.error === "BadExpiration" ? new vp(t) : t;
}
Nn.toKnownErr = kv;
var Ks = {};
Object.defineProperty(Ks, "__esModule", { value: !0 });
Ks.toKnownErr = void 0;
const Dv = Z;
function Pv(t) {
  return t instanceof Dv.XRPCError, t;
}
Ks.toKnownErr = Pv;
var ii = {};
Object.defineProperty(ii, "__esModule", { value: !0 });
ii.validateAppPassword = ii.isAppPassword = ii.toKnownErr = ii.AccountTakedownError = void 0;
const Rp = Z, Qc = ke, Bv = Ie;
let Ap = class extends Rp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ii.AccountTakedownError = Ap;
function Iv(t) {
  return t instanceof Rp.XRPCError && t.error === "AccountTakedown" ? new Ap(t) : t;
}
ii.toKnownErr = Iv;
function Uv(t) {
  return (0, Qc.isObj)(t) && (0, Qc.hasProp)(t, "$type") && t.$type === "com.atproto.server.listAppPasswords#appPassword";
}
ii.isAppPassword = Uv;
function Ov(t) {
  return Bv.lexicons.validate("com.atproto.server.listAppPasswords#appPassword", t);
}
ii.validateAppPassword = Ov;
var Vn = {};
Object.defineProperty(Vn, "__esModule", { value: !0 });
Vn.toKnownErr = Vn.AccountTakedownError = void 0;
const _p = Z;
class wp extends _p.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Vn.AccountTakedownError = wp;
function Kv(t) {
  return t instanceof _p.XRPCError && t.error === "AccountTakedown" ? new wp(t) : t;
}
Vn.toKnownErr = Kv;
var Ms = {};
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.toKnownErr = void 0;
const Mv = Z;
function Nv(t) {
  return t instanceof Mv.XRPCError, t;
}
Ms.toKnownErr = Nv;
var Ns = {};
Object.defineProperty(Ns, "__esModule", { value: !0 });
Ns.toKnownErr = void 0;
const Vv = Z;
function jv(t) {
  return t instanceof Vv.XRPCError, t;
}
Ns.toKnownErr = jv;
var Vs = {};
Object.defineProperty(Vs, "__esModule", { value: !0 });
Vs.toKnownErr = void 0;
const Fv = Z;
function $v(t) {
  return t instanceof Fv.XRPCError, t;
}
Vs.toKnownErr = $v;
var js = {};
Object.defineProperty(js, "__esModule", { value: !0 });
js.toKnownErr = void 0;
const Gv = Z;
function qv(t) {
  return t instanceof Gv.XRPCError, t;
}
js.toKnownErr = qv;
var Fs = {};
Object.defineProperty(Fs, "__esModule", { value: !0 });
Fs.toKnownErr = void 0;
const Xv = Z;
function zv(t) {
  return t instanceof Xv.XRPCError, t;
}
Fs.toKnownErr = zv;
var en = {};
Object.defineProperty(en, "__esModule", { value: !0 });
en.toKnownErr = en.InvalidTokenError = en.ExpiredTokenError = void 0;
const uc = Z;
let Tp = class extends uc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
en.ExpiredTokenError = Tp;
let Sp = class extends uc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
en.InvalidTokenError = Sp;
function Hv(t) {
  if (t instanceof uc.XRPCError) {
    if (t.error === "ExpiredToken")
      return new Tp(t);
    if (t.error === "InvalidToken")
      return new Sp(t);
  }
  return t;
}
en.toKnownErr = Hv;
var $s = {};
Object.defineProperty($s, "__esModule", { value: !0 });
$s.toKnownErr = void 0;
const Zv = Z;
function Wv(t) {
  return t instanceof Zv.XRPCError, t;
}
$s.toKnownErr = Wv;
var ni = {};
Object.defineProperty(ni, "__esModule", { value: !0 });
ni.toKnownErr = ni.TokenRequiredError = ni.InvalidTokenError = ni.ExpiredTokenError = void 0;
const ru = Z;
class Cp extends ru.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ni.ExpiredTokenError = Cp;
class Lp extends ru.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ni.InvalidTokenError = Lp;
class kp extends ru.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ni.TokenRequiredError = kp;
function Yv(t) {
  if (t instanceof ru.XRPCError) {
    if (t.error === "ExpiredToken")
      return new Cp(t);
    if (t.error === "InvalidToken")
      return new Lp(t);
    if (t.error === "TokenRequired")
      return new kp(t);
  }
  return t;
}
ni.toKnownErr = Yv;
var xr = {};
Object.defineProperty(xr, "__esModule", { value: !0 });
xr.toKnownErr = xr.RepoDeactivatedError = xr.RepoSuspendedError = xr.RepoTakendownError = xr.RepoNotFoundError = xr.BlobNotFoundError = void 0;
const Ia = Z;
class Dp extends Ia.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
xr.BlobNotFoundError = Dp;
let Pp = class extends Ia.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
xr.RepoNotFoundError = Pp;
let Bp = class extends Ia.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
xr.RepoTakendownError = Bp;
let Ip = class extends Ia.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
xr.RepoSuspendedError = Ip;
let Up = class extends Ia.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
xr.RepoDeactivatedError = Up;
function Jv(t) {
  if (t instanceof Ia.XRPCError) {
    if (t.error === "BlobNotFound")
      return new Dp(t);
    if (t.error === "RepoNotFound")
      return new Pp(t);
    if (t.error === "RepoTakendown")
      return new Bp(t);
    if (t.error === "RepoSuspended")
      return new Ip(t);
    if (t.error === "RepoDeactivated")
      return new Up(t);
  }
  return t;
}
xr.toKnownErr = Jv;
var Er = {};
Object.defineProperty(Er, "__esModule", { value: !0 });
Er.toKnownErr = Er.RepoDeactivatedError = Er.RepoSuspendedError = Er.RepoTakendownError = Er.RepoNotFoundError = Er.BlockNotFoundError = void 0;
const Ua = Z;
class Op extends Ua.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Er.BlockNotFoundError = Op;
let Kp = class extends Ua.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Er.RepoNotFoundError = Kp;
let Mp = class extends Ua.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Er.RepoTakendownError = Mp;
let Np = class extends Ua.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Er.RepoSuspendedError = Np;
let Vp = class extends Ua.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Er.RepoDeactivatedError = Vp;
function Qv(t) {
  if (t instanceof Ua.XRPCError) {
    if (t.error === "BlockNotFound")
      return new Op(t);
    if (t.error === "RepoNotFound")
      return new Kp(t);
    if (t.error === "RepoTakendown")
      return new Mp(t);
    if (t.error === "RepoSuspended")
      return new Np(t);
    if (t.error === "RepoDeactivated")
      return new Vp(t);
  }
  return t;
}
Er.toKnownErr = Qv;
var Gs = {};
Object.defineProperty(Gs, "__esModule", { value: !0 });
Gs.toKnownErr = void 0;
const eR = Z;
function tR(t) {
  return t instanceof eR.XRPCError, t;
}
Gs.toKnownErr = tR;
var jn = {};
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.toKnownErr = jn.HeadNotFoundError = void 0;
const jp = Z;
class Fp extends jp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
jn.HeadNotFoundError = Fp;
function rR(t) {
  return t instanceof jp.XRPCError && t.error === "HeadNotFound" ? new Fp(t) : t;
}
jn.toKnownErr = rR;
var Ir = {};
Object.defineProperty(Ir, "__esModule", { value: !0 });
Ir.toKnownErr = Ir.RepoDeactivatedError = Ir.RepoSuspendedError = Ir.RepoTakendownError = Ir.RepoNotFoundError = void 0;
const qs = Z;
let $p = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ir.RepoNotFoundError = $p;
let Gp = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ir.RepoTakendownError = Gp;
let qp = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ir.RepoSuspendedError = qp;
let Xp = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ir.RepoDeactivatedError = Xp;
function iR(t) {
  if (t instanceof qs.XRPCError) {
    if (t.error === "RepoNotFound")
      return new $p(t);
    if (t.error === "RepoTakendown")
      return new Gp(t);
    if (t.error === "RepoSuspended")
      return new qp(t);
    if (t.error === "RepoDeactivated")
      return new Xp(t);
  }
  return t;
}
Ir.toKnownErr = iR;
var vr = {};
Object.defineProperty(vr, "__esModule", { value: !0 });
vr.toKnownErr = vr.RepoDeactivatedError = vr.RepoSuspendedError = vr.RepoTakendownError = vr.RepoNotFoundError = vr.RecordNotFoundError = void 0;
const Oa = Z;
let zp = class extends Oa.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
vr.RecordNotFoundError = zp;
let Hp = class extends Oa.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
vr.RepoNotFoundError = Hp;
let Zp = class extends Oa.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
vr.RepoTakendownError = Zp;
let Wp = class extends Oa.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
vr.RepoSuspendedError = Wp;
let Yp = class extends Oa.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
vr.RepoDeactivatedError = Yp;
function nR(t) {
  if (t instanceof Oa.XRPCError) {
    if (t.error === "RecordNotFound")
      return new zp(t);
    if (t.error === "RepoNotFound")
      return new Hp(t);
    if (t.error === "RepoTakendown")
      return new Zp(t);
    if (t.error === "RepoSuspended")
      return new Wp(t);
    if (t.error === "RepoDeactivated")
      return new Yp(t);
  }
  return t;
}
vr.toKnownErr = nR;
var Ur = {};
Object.defineProperty(Ur, "__esModule", { value: !0 });
Ur.toKnownErr = Ur.RepoDeactivatedError = Ur.RepoSuspendedError = Ur.RepoTakendownError = Ur.RepoNotFoundError = void 0;
const Xs = Z;
let Jp = class extends Xs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ur.RepoNotFoundError = Jp;
let Qp = class extends Xs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ur.RepoTakendownError = Qp;
let eh = class extends Xs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ur.RepoSuspendedError = eh;
let th = class extends Xs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ur.RepoDeactivatedError = th;
function aR(t) {
  if (t instanceof Xs.XRPCError) {
    if (t.error === "RepoNotFound")
      return new Jp(t);
    if (t.error === "RepoTakendown")
      return new Qp(t);
    if (t.error === "RepoSuspended")
      return new eh(t);
    if (t.error === "RepoDeactivated")
      return new th(t);
  }
  return t;
}
Ur.toKnownErr = aR;
var Fn = {};
Object.defineProperty(Fn, "__esModule", { value: !0 });
Fn.toKnownErr = Fn.RepoNotFoundError = void 0;
const rh = Z;
let ih = class extends rh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Fn.RepoNotFoundError = ih;
function sR(t) {
  return t instanceof rh.XRPCError && t.error === "RepoNotFound" ? new ih(t) : t;
}
Fn.toKnownErr = sR;
var Or = {};
Object.defineProperty(Or, "__esModule", { value: !0 });
Or.toKnownErr = Or.RepoDeactivatedError = Or.RepoSuspendedError = Or.RepoTakendownError = Or.RepoNotFoundError = void 0;
const zs = Z;
let nh = class extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Or.RepoNotFoundError = nh;
class ah extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Or.RepoTakendownError = ah;
class sh extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Or.RepoSuspendedError = sh;
class oh extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Or.RepoDeactivatedError = oh;
function oR(t) {
  if (t instanceof zs.XRPCError) {
    if (t.error === "RepoNotFound")
      return new nh(t);
    if (t.error === "RepoTakendown")
      return new ah(t);
    if (t.error === "RepoSuspended")
      return new sh(t);
    if (t.error === "RepoDeactivated")
      return new oh(t);
  }
  return t;
}
Or.toKnownErr = oR;
var tn = {};
Object.defineProperty(tn, "__esModule", { value: !0 });
tn.validateRepo = tn.isRepo = tn.toKnownErr = void 0;
const lR = Z, ed = ke, uR = Ie;
function cR(t) {
  return t instanceof lR.XRPCError, t;
}
tn.toKnownErr = cR;
function dR(t) {
  return (0, ed.isObj)(t) && (0, ed.hasProp)(t, "$type") && t.$type === "com.atproto.sync.listRepos#repo";
}
tn.isRepo = dR;
function fR(t) {
  return uR.lexicons.validate("com.atproto.sync.listRepos#repo", t);
}
tn.validateRepo = fR;
var Hs = {};
Object.defineProperty(Hs, "__esModule", { value: !0 });
Hs.toKnownErr = void 0;
const pR = Z;
function hR(t) {
  return t instanceof pR.XRPCError, t;
}
Hs.toKnownErr = hR;
var Zs = {};
Object.defineProperty(Zs, "__esModule", { value: !0 });
Zs.toKnownErr = void 0;
const mR = Z;
function yR(t) {
  return t instanceof mR.XRPCError, t;
}
Zs.toKnownErr = yR;
var Ws = {};
Object.defineProperty(Ws, "__esModule", { value: !0 });
Ws.toKnownErr = void 0;
const bR = Z;
function gR(t) {
  return t instanceof bR.XRPCError, t;
}
Ws.toKnownErr = gR;
var Ys = {};
Object.defineProperty(Ys, "__esModule", { value: !0 });
Ys.toKnownErr = void 0;
const xR = Z;
function ER(t) {
  return t instanceof xR.XRPCError, t;
}
Ys.toKnownErr = ER;
var Js = {};
Object.defineProperty(Js, "__esModule", { value: !0 });
Js.toKnownErr = void 0;
const vR = Z;
function RR(t) {
  return t instanceof vR.XRPCError, t;
}
Js.toKnownErr = RR;
var Qs = {};
Object.defineProperty(Qs, "__esModule", { value: !0 });
Qs.toKnownErr = void 0;
const AR = Z;
function _R(t) {
  return t instanceof AR.XRPCError, t;
}
Qs.toKnownErr = _R;
var eo = {};
Object.defineProperty(eo, "__esModule", { value: !0 });
eo.toKnownErr = void 0;
const wR = Z;
function TR(t) {
  return t instanceof wR.XRPCError, t;
}
eo.toKnownErr = TR;
var to = {};
Object.defineProperty(to, "__esModule", { value: !0 });
to.toKnownErr = void 0;
const SR = Z;
function CR(t) {
  return t instanceof SR.XRPCError, t;
}
to.toKnownErr = CR;
var ro = {};
Object.defineProperty(ro, "__esModule", { value: !0 });
ro.toKnownErr = void 0;
const LR = Z;
function kR(t) {
  return t instanceof LR.XRPCError, t;
}
ro.toKnownErr = kR;
var io = {};
Object.defineProperty(io, "__esModule", { value: !0 });
io.toKnownErr = void 0;
const DR = Z;
function PR(t) {
  return t instanceof DR.XRPCError, t;
}
io.toKnownErr = PR;
var no = {};
Object.defineProperty(no, "__esModule", { value: !0 });
no.toKnownErr = void 0;
const BR = Z;
function IR(t) {
  return t instanceof BR.XRPCError, t;
}
no.toKnownErr = IR;
var ao = {};
Object.defineProperty(ao, "__esModule", { value: !0 });
ao.toKnownErr = void 0;
const UR = Z;
function OR(t) {
  return t instanceof UR.XRPCError, t;
}
ao.toKnownErr = OR;
var Kr = {};
Object.defineProperty(Kr, "__esModule", { value: !0 });
Kr.validateLinks = Kr.isLinks = Kr.validateFeed = Kr.isFeed = Kr.toKnownErr = void 0;
const KR = Z, jl = ke, lh = Ie;
function MR(t) {
  return t instanceof KR.XRPCError, t;
}
Kr.toKnownErr = MR;
function NR(t) {
  return (0, jl.isObj)(t) && (0, jl.hasProp)(t, "$type") && t.$type === "app.bsky.feed.describeFeedGenerator#feed";
}
Kr.isFeed = NR;
function VR(t) {
  return lh.lexicons.validate("app.bsky.feed.describeFeedGenerator#feed", t);
}
Kr.validateFeed = VR;
function jR(t) {
  return (0, jl.isObj)(t) && (0, jl.hasProp)(t, "$type") && t.$type === "app.bsky.feed.describeFeedGenerator#links";
}
Kr.isLinks = jR;
function FR(t) {
  return lh.lexicons.validate("app.bsky.feed.describeFeedGenerator#links", t);
}
Kr.validateLinks = FR;
var so = {};
Object.defineProperty(so, "__esModule", { value: !0 });
so.toKnownErr = void 0;
const $R = Z;
function GR(t) {
  return t instanceof $R.XRPCError, t;
}
so.toKnownErr = GR;
var rn = {};
Object.defineProperty(rn, "__esModule", { value: !0 });
rn.toKnownErr = rn.BlockedByActorError = rn.BlockedActorError = void 0;
const cc = Z;
let uh = class extends cc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
rn.BlockedActorError = uh;
let ch = class extends cc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
rn.BlockedByActorError = ch;
function qR(t) {
  if (t instanceof cc.XRPCError) {
    if (t.error === "BlockedActor")
      return new uh(t);
    if (t.error === "BlockedByActor")
      return new ch(t);
  }
  return t;
}
rn.toKnownErr = qR;
var nn = {};
Object.defineProperty(nn, "__esModule", { value: !0 });
nn.toKnownErr = nn.BlockedByActorError = nn.BlockedActorError = void 0;
const dc = Z;
class dh extends dc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
nn.BlockedActorError = dh;
class fh extends dc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
nn.BlockedByActorError = fh;
function XR(t) {
  if (t instanceof dc.XRPCError) {
    if (t.error === "BlockedActor")
      return new dh(t);
    if (t.error === "BlockedByActor")
      return new fh(t);
  }
  return t;
}
nn.toKnownErr = XR;
var $n = {};
Object.defineProperty($n, "__esModule", { value: !0 });
$n.toKnownErr = $n.UnknownFeedError = void 0;
const ph = Z;
let hh = class extends ph.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
$n.UnknownFeedError = hh;
function zR(t) {
  return t instanceof ph.XRPCError && t.error === "UnknownFeed" ? new hh(t) : t;
}
$n.toKnownErr = zR;
var oo = {};
Object.defineProperty(oo, "__esModule", { value: !0 });
oo.toKnownErr = void 0;
const HR = Z;
function ZR(t) {
  return t instanceof HR.XRPCError, t;
}
oo.toKnownErr = ZR;
var lo = {};
Object.defineProperty(lo, "__esModule", { value: !0 });
lo.toKnownErr = void 0;
const WR = Z;
function YR(t) {
  return t instanceof WR.XRPCError, t;
}
lo.toKnownErr = YR;
var Gn = {};
Object.defineProperty(Gn, "__esModule", { value: !0 });
Gn.toKnownErr = Gn.UnknownFeedError = void 0;
const mh = Z;
class yh extends mh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Gn.UnknownFeedError = yh;
function JR(t) {
  return t instanceof mh.XRPCError && t.error === "UnknownFeed" ? new yh(t) : t;
}
Gn.toKnownErr = JR;
var an = {};
Object.defineProperty(an, "__esModule", { value: !0 });
an.validateLike = an.isLike = an.toKnownErr = void 0;
const QR = Z, td = ke, eA = Ie;
function tA(t) {
  return t instanceof QR.XRPCError, t;
}
an.toKnownErr = tA;
function rA(t) {
  return (0, td.isObj)(t) && (0, td.hasProp)(t, "$type") && t.$type === "app.bsky.feed.getLikes#like";
}
an.isLike = rA;
function iA(t) {
  return eA.lexicons.validate("app.bsky.feed.getLikes#like", t);
}
an.validateLike = iA;
var qn = {};
Object.defineProperty(qn, "__esModule", { value: !0 });
qn.toKnownErr = qn.UnknownListError = void 0;
const bh = Z;
class gh extends bh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
qn.UnknownListError = gh;
function nA(t) {
  return t instanceof bh.XRPCError && t.error === "UnknownList" ? new gh(t) : t;
}
qn.toKnownErr = nA;
var Xn = {};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.toKnownErr = Xn.NotFoundError = void 0;
const xh = Z;
class Eh extends xh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Xn.NotFoundError = Eh;
function aA(t) {
  return t instanceof xh.XRPCError && t.error === "NotFound" ? new Eh(t) : t;
}
Xn.toKnownErr = aA;
var uo = {};
Object.defineProperty(uo, "__esModule", { value: !0 });
uo.toKnownErr = void 0;
const sA = Z;
function oA(t) {
  return t instanceof sA.XRPCError, t;
}
uo.toKnownErr = oA;
var co = {};
Object.defineProperty(co, "__esModule", { value: !0 });
co.toKnownErr = void 0;
const lA = Z;
function uA(t) {
  return t instanceof lA.XRPCError, t;
}
co.toKnownErr = uA;
var fo = {};
Object.defineProperty(fo, "__esModule", { value: !0 });
fo.toKnownErr = void 0;
const cA = Z;
function dA(t) {
  return t instanceof cA.XRPCError, t;
}
fo.toKnownErr = dA;
var po = {};
Object.defineProperty(po, "__esModule", { value: !0 });
po.toKnownErr = void 0;
const fA = Z;
function pA(t) {
  return t instanceof fA.XRPCError, t;
}
po.toKnownErr = pA;
var zn = {};
Object.defineProperty(zn, "__esModule", { value: !0 });
zn.toKnownErr = zn.BadQueryStringError = void 0;
const vh = Z;
let Rh = class extends vh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
zn.BadQueryStringError = Rh;
function hA(t) {
  return t instanceof vh.XRPCError && t.error === "BadQueryString" ? new Rh(t) : t;
}
zn.toKnownErr = hA;
var ho = {};
Object.defineProperty(ho, "__esModule", { value: !0 });
ho.toKnownErr = void 0;
const mA = Z;
function yA(t) {
  return t instanceof mA.XRPCError, t;
}
ho.toKnownErr = yA;
var mo = {};
Object.defineProperty(mo, "__esModule", { value: !0 });
mo.toKnownErr = void 0;
const bA = Z;
function gA(t) {
  return t instanceof bA.XRPCError, t;
}
mo.toKnownErr = gA;
var yo = {};
Object.defineProperty(yo, "__esModule", { value: !0 });
yo.toKnownErr = void 0;
const xA = Z;
function EA(t) {
  return t instanceof xA.XRPCError, t;
}
yo.toKnownErr = EA;
var bo = {};
Object.defineProperty(bo, "__esModule", { value: !0 });
bo.toKnownErr = void 0;
const vA = Z;
function RA(t) {
  return t instanceof vA.XRPCError, t;
}
bo.toKnownErr = RA;
var go = {};
Object.defineProperty(go, "__esModule", { value: !0 });
go.toKnownErr = void 0;
const AA = Z;
function _A(t) {
  return t instanceof AA.XRPCError, t;
}
go.toKnownErr = _A;
var xo = {};
Object.defineProperty(xo, "__esModule", { value: !0 });
xo.toKnownErr = void 0;
const wA = Z;
function TA(t) {
  return t instanceof wA.XRPCError, t;
}
xo.toKnownErr = TA;
var Eo = {};
Object.defineProperty(Eo, "__esModule", { value: !0 });
Eo.toKnownErr = void 0;
const SA = Z;
function CA(t) {
  return t instanceof SA.XRPCError, t;
}
Eo.toKnownErr = CA;
var vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 });
vo.toKnownErr = void 0;
const LA = Z;
function kA(t) {
  return t instanceof LA.XRPCError, t;
}
vo.toKnownErr = kA;
var Ro = {};
Object.defineProperty(Ro, "__esModule", { value: !0 });
Ro.toKnownErr = void 0;
const DA = Z;
function PA(t) {
  return t instanceof DA.XRPCError, t;
}
Ro.toKnownErr = PA;
var Ao = {};
Object.defineProperty(Ao, "__esModule", { value: !0 });
Ao.toKnownErr = void 0;
const BA = Z;
function IA(t) {
  return t instanceof BA.XRPCError, t;
}
Ao.toKnownErr = IA;
var _o = {};
Object.defineProperty(_o, "__esModule", { value: !0 });
_o.toKnownErr = void 0;
const UA = Z;
function OA(t) {
  return t instanceof UA.XRPCError, t;
}
_o.toKnownErr = OA;
var Hn = {};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.toKnownErr = Hn.ActorNotFoundError = void 0;
const Ah = Z;
class _h extends Ah.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Hn.ActorNotFoundError = _h;
function KA(t) {
  return t instanceof Ah.XRPCError && t.error === "ActorNotFound" ? new _h(t) : t;
}
Hn.toKnownErr = KA;
var wo = {};
Object.defineProperty(wo, "__esModule", { value: !0 });
wo.toKnownErr = void 0;
const MA = Z;
function NA(t) {
  return t instanceof MA.XRPCError, t;
}
wo.toKnownErr = NA;
var To = {};
Object.defineProperty(To, "__esModule", { value: !0 });
To.toKnownErr = void 0;
const VA = Z;
function jA(t) {
  return t instanceof VA.XRPCError, t;
}
To.toKnownErr = jA;
var So = {};
Object.defineProperty(So, "__esModule", { value: !0 });
So.toKnownErr = void 0;
const FA = Z;
function $A(t) {
  return t instanceof FA.XRPCError, t;
}
So.toKnownErr = $A;
var Co = {};
Object.defineProperty(Co, "__esModule", { value: !0 });
Co.toKnownErr = void 0;
const GA = Z;
function qA(t) {
  return t instanceof GA.XRPCError, t;
}
Co.toKnownErr = qA;
var Lo = {};
Object.defineProperty(Lo, "__esModule", { value: !0 });
Lo.toKnownErr = void 0;
const XA = Z;
function zA(t) {
  return t instanceof XA.XRPCError, t;
}
Lo.toKnownErr = zA;
var ko = {};
Object.defineProperty(ko, "__esModule", { value: !0 });
ko.toKnownErr = void 0;
const HA = Z;
function ZA(t) {
  return t instanceof HA.XRPCError, t;
}
ko.toKnownErr = ZA;
var Do = {};
Object.defineProperty(Do, "__esModule", { value: !0 });
Do.toKnownErr = void 0;
const WA = Z;
function YA(t) {
  return t instanceof WA.XRPCError, t;
}
Do.toKnownErr = YA;
var Po = {};
Object.defineProperty(Po, "__esModule", { value: !0 });
Po.toKnownErr = void 0;
const JA = Z;
function QA(t) {
  return t instanceof JA.XRPCError, t;
}
Po.toKnownErr = QA;
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.toKnownErr = void 0;
const e_ = Z;
function t_(t) {
  return t instanceof e_.XRPCError, t;
}
Bo.toKnownErr = t_;
var Io = {};
Object.defineProperty(Io, "__esModule", { value: !0 });
Io.toKnownErr = void 0;
const r_ = Z;
function i_(t) {
  return t instanceof r_.XRPCError, t;
}
Io.toKnownErr = i_;
var Uo = {};
Object.defineProperty(Uo, "__esModule", { value: !0 });
Uo.toKnownErr = void 0;
const n_ = Z;
function a_(t) {
  return t instanceof n_.XRPCError, t;
}
Uo.toKnownErr = a_;
var sn = {};
Object.defineProperty(sn, "__esModule", { value: !0 });
sn.validateNotification = sn.isNotification = sn.toKnownErr = void 0;
const s_ = Z, rd = ke, o_ = Ie;
function l_(t) {
  return t instanceof s_.XRPCError, t;
}
sn.toKnownErr = l_;
function u_(t) {
  return (0, rd.isObj)(t) && (0, rd.hasProp)(t, "$type") && t.$type === "app.bsky.notification.listNotifications#notification";
}
sn.isNotification = u_;
function c_(t) {
  return o_.lexicons.validate("app.bsky.notification.listNotifications#notification", t);
}
sn.validateNotification = c_;
var Oo = {};
Object.defineProperty(Oo, "__esModule", { value: !0 });
Oo.toKnownErr = void 0;
const d_ = Z;
function f_(t) {
  return t instanceof d_.XRPCError, t;
}
Oo.toKnownErr = f_;
var Ko = {};
Object.defineProperty(Ko, "__esModule", { value: !0 });
Ko.toKnownErr = void 0;
const p_ = Z;
function h_(t) {
  return t instanceof p_.XRPCError, t;
}
Ko.toKnownErr = h_;
var Mo = {};
Object.defineProperty(Mo, "__esModule", { value: !0 });
Mo.toKnownErr = void 0;
const m_ = Z;
function y_(t) {
  return t instanceof m_.XRPCError, t;
}
Mo.toKnownErr = y_;
var No = {};
Object.defineProperty(No, "__esModule", { value: !0 });
No.toKnownErr = void 0;
const b_ = Z;
function g_(t) {
  return t instanceof b_.XRPCError, t;
}
No.toKnownErr = g_;
var Vo = {};
Object.defineProperty(Vo, "__esModule", { value: !0 });
Vo.toKnownErr = void 0;
const x_ = Z;
function E_(t) {
  return t instanceof x_.XRPCError, t;
}
Vo.toKnownErr = E_;
var on = {};
Object.defineProperty(on, "__esModule", { value: !0 });
on.validateSuggestion = on.isSuggestion = on.toKnownErr = void 0;
const v_ = Z, id = ke, R_ = Ie;
function A_(t) {
  return t instanceof v_.XRPCError, t;
}
on.toKnownErr = A_;
function __(t) {
  return (0, id.isObj)(t) && (0, id.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.getTaggedSuggestions#suggestion";
}
on.isSuggestion = __;
function w_(t) {
  return R_.lexicons.validate("app.bsky.unspecced.getTaggedSuggestions#suggestion", t);
}
on.validateSuggestion = w_;
var Zn = {};
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.toKnownErr = Zn.BadQueryStringError = void 0;
const wh = Z;
let Th = class extends wh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Zn.BadQueryStringError = Th;
function T_(t) {
  return t instanceof wh.XRPCError && t.error === "BadQueryString" ? new Th(t) : t;
}
Zn.toKnownErr = T_;
var Wn = {};
Object.defineProperty(Wn, "__esModule", { value: !0 });
Wn.toKnownErr = Wn.BadQueryStringError = void 0;
const Sh = Z;
class Ch extends Sh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Wn.BadQueryStringError = Ch;
function S_(t) {
  return t instanceof Sh.XRPCError && t.error === "BadQueryString" ? new Ch(t) : t;
}
Wn.toKnownErr = S_;
var jo = {};
Object.defineProperty(jo, "__esModule", { value: !0 });
jo.toKnownErr = void 0;
const C_ = Z;
function L_(t) {
  return t instanceof C_.XRPCError, t;
}
jo.toKnownErr = L_;
var Fo = {};
Object.defineProperty(Fo, "__esModule", { value: !0 });
Fo.toKnownErr = void 0;
const k_ = Z;
function D_(t) {
  return t instanceof k_.XRPCError, t;
}
Fo.toKnownErr = D_;
var $o = {};
Object.defineProperty($o, "__esModule", { value: !0 });
$o.toKnownErr = void 0;
const P_ = Z;
function B_(t) {
  return t instanceof P_.XRPCError, t;
}
$o.toKnownErr = B_;
var Go = {};
Object.defineProperty(Go, "__esModule", { value: !0 });
Go.toKnownErr = void 0;
const I_ = Z;
function U_(t) {
  return t instanceof I_.XRPCError, t;
}
Go.toKnownErr = U_;
var qo = {};
Object.defineProperty(qo, "__esModule", { value: !0 });
qo.toKnownErr = void 0;
const O_ = Z;
function K_(t) {
  return t instanceof O_.XRPCError, t;
}
qo.toKnownErr = K_;
var Xo = {};
Object.defineProperty(Xo, "__esModule", { value: !0 });
Xo.toKnownErr = void 0;
const M_ = Z;
function N_(t) {
  return t instanceof M_.XRPCError, t;
}
Xo.toKnownErr = N_;
var zo = {};
Object.defineProperty(zo, "__esModule", { value: !0 });
zo.toKnownErr = void 0;
const V_ = Z;
function j_(t) {
  return t instanceof V_.XRPCError, t;
}
zo.toKnownErr = j_;
var Ho = {};
Object.defineProperty(Ho, "__esModule", { value: !0 });
Ho.toKnownErr = void 0;
const F_ = Z;
function $_(t) {
  return t instanceof F_.XRPCError, t;
}
Ho.toKnownErr = $_;
var Zo = {};
Object.defineProperty(Zo, "__esModule", { value: !0 });
Zo.toKnownErr = void 0;
const G_ = Z;
function q_(t) {
  return t instanceof G_.XRPCError, t;
}
Zo.toKnownErr = q_;
var Wo = {};
Object.defineProperty(Wo, "__esModule", { value: !0 });
Wo.toKnownErr = void 0;
const X_ = Z;
function z_(t) {
  return t instanceof X_.XRPCError, t;
}
Wo.toKnownErr = z_;
var Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.toKnownErr = void 0;
const H_ = Z;
function Z_(t) {
  return t instanceof H_.XRPCError, t;
}
Yo.toKnownErr = Z_;
var ln = {};
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.validateBatchItem = ln.isBatchItem = ln.toKnownErr = void 0;
const W_ = Z, nd = ke, Y_ = Ie;
function J_(t) {
  return t instanceof W_.XRPCError, t;
}
ln.toKnownErr = J_;
function Q_(t) {
  return (0, nd.isObj)(t) && (0, nd.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.sendMessageBatch#batchItem";
}
ln.isBatchItem = Q_;
function ew(t) {
  return Y_.lexicons.validate("chat.bsky.convo.sendMessageBatch#batchItem", t);
}
ln.validateBatchItem = ew;
var Jo = {};
Object.defineProperty(Jo, "__esModule", { value: !0 });
Jo.toKnownErr = void 0;
const tw = Z;
function rw(t) {
  return t instanceof tw.XRPCError, t;
}
Jo.toKnownErr = rw;
var Qo = {};
Object.defineProperty(Qo, "__esModule", { value: !0 });
Qo.toKnownErr = void 0;
const iw = Z;
function nw(t) {
  return t instanceof iw.XRPCError, t;
}
Qo.toKnownErr = nw;
var un = {};
Object.defineProperty(un, "__esModule", { value: !0 });
un.validateMetadata = un.isMetadata = un.toKnownErr = void 0;
const aw = Z, ad = ke, sw = Ie;
function ow(t) {
  return t instanceof aw.XRPCError, t;
}
un.toKnownErr = ow;
function lw(t) {
  return (0, ad.isObj)(t) && (0, ad.hasProp)(t, "$type") && t.$type === "chat.bsky.moderation.getActorMetadata#metadata";
}
un.isMetadata = lw;
function uw(t) {
  return sw.lexicons.validate("chat.bsky.moderation.getActorMetadata#metadata", t);
}
un.validateMetadata = uw;
var el = {};
Object.defineProperty(el, "__esModule", { value: !0 });
el.toKnownErr = void 0;
const cw = Z;
function dw(t) {
  return t instanceof cw.XRPCError, t;
}
el.toKnownErr = dw;
var tl = {};
Object.defineProperty(tl, "__esModule", { value: !0 });
tl.toKnownErr = void 0;
const fw = Z;
function pw(t) {
  return t instanceof fw.XRPCError, t;
}
tl.toKnownErr = pw;
var rl = {};
Object.defineProperty(rl, "__esModule", { value: !0 });
rl.toKnownErr = void 0;
const hw = Z;
function mw(t) {
  return t instanceof hw.XRPCError, t;
}
rl.toKnownErr = mw;
var il = {};
Object.defineProperty(il, "__esModule", { value: !0 });
il.toKnownErr = void 0;
const yw = Z;
function bw(t) {
  return t instanceof yw.XRPCError, t;
}
il.toKnownErr = bw;
var nl = {};
Object.defineProperty(nl, "__esModule", { value: !0 });
nl.toKnownErr = void 0;
const gw = Z;
function xw(t) {
  return t instanceof gw.XRPCError, t;
}
nl.toKnownErr = xw;
var al = {};
Object.defineProperty(al, "__esModule", { value: !0 });
al.toKnownErr = void 0;
const Ew = Z;
function vw(t) {
  return t instanceof Ew.XRPCError, t;
}
al.toKnownErr = vw;
var Yn = {};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.toKnownErr = Yn.SubjectHasActionError = void 0;
const Lh = Z;
class kh extends Lh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Yn.SubjectHasActionError = kh;
function Rw(t) {
  return t instanceof Lh.XRPCError && t.error === "SubjectHasAction" ? new kh(t) : t;
}
Yn.toKnownErr = Rw;
var sl = {};
Object.defineProperty(sl, "__esModule", { value: !0 });
sl.toKnownErr = void 0;
const Aw = Z;
function _w(t) {
  return t instanceof Aw.XRPCError, t;
}
sl.toKnownErr = _w;
var Jn = {};
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.toKnownErr = Jn.RecordNotFoundError = void 0;
const Dh = Z;
class Ph extends Dh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Jn.RecordNotFoundError = Ph;
function ww(t) {
  return t instanceof Dh.XRPCError && t.error === "RecordNotFound" ? new Ph(t) : t;
}
Jn.toKnownErr = ww;
var Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.toKnownErr = Qn.RepoNotFoundError = void 0;
const Bh = Z;
class Ih extends Bh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Qn.RepoNotFoundError = Ih;
function Tw(t) {
  return t instanceof Bh.XRPCError && t.error === "RepoNotFound" ? new Ih(t) : t;
}
Qn.toKnownErr = Tw;
var ol = {};
Object.defineProperty(ol, "__esModule", { value: !0 });
ol.toKnownErr = void 0;
const Sw = Z;
function Cw(t) {
  return t instanceof Sw.XRPCError, t;
}
ol.toKnownErr = Cw;
var ll = {};
Object.defineProperty(ll, "__esModule", { value: !0 });
ll.toKnownErr = void 0;
const Lw = Z;
function kw(t) {
  return t instanceof Lw.XRPCError, t;
}
ll.toKnownErr = kw;
var ul = {};
Object.defineProperty(ul, "__esModule", { value: !0 });
ul.toKnownErr = void 0;
const Dw = Z;
function Pw(t) {
  return t instanceof Dw.XRPCError, t;
}
ul.toKnownErr = Pw;
var Mr = {};
Object.defineProperty(Mr, "__esModule", { value: !0 });
Mr.validateViewerConfig = Mr.isViewerConfig = Mr.validateServiceConfig = Mr.isServiceConfig = Mr.toKnownErr = void 0;
const Bw = Z, Fl = ke, Uh = Ie;
function Iw(t) {
  return t instanceof Bw.XRPCError, t;
}
Mr.toKnownErr = Iw;
function Uw(t) {
  return (0, Fl.isObj)(t) && (0, Fl.hasProp)(t, "$type") && t.$type === "tools.ozone.server.getConfig#serviceConfig";
}
Mr.isServiceConfig = Uw;
function Ow(t) {
  return Uh.lexicons.validate("tools.ozone.server.getConfig#serviceConfig", t);
}
Mr.validateServiceConfig = Ow;
function Kw(t) {
  return (0, Fl.isObj)(t) && (0, Fl.hasProp)(t, "$type") && t.$type === "tools.ozone.server.getConfig#viewerConfig";
}
Mr.isViewerConfig = Kw;
function Mw(t) {
  return Uh.lexicons.validate("tools.ozone.server.getConfig#viewerConfig", t);
}
Mr.validateViewerConfig = Mw;
var ea = {};
Object.defineProperty(ea, "__esModule", { value: !0 });
ea.toKnownErr = ea.MemberAlreadyExistsError = void 0;
const Oh = Z;
class Kh extends Oh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ea.MemberAlreadyExistsError = Kh;
function Nw(t) {
  return t instanceof Oh.XRPCError && t.error === "MemberAlreadyExists" ? new Kh(t) : t;
}
ea.toKnownErr = Nw;
var cn = {};
Object.defineProperty(cn, "__esModule", { value: !0 });
cn.toKnownErr = cn.CannotDeleteSelfError = cn.MemberNotFoundError = void 0;
const fc = Z;
let Mh = class extends fc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
cn.MemberNotFoundError = Mh;
class Nh extends fc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
cn.CannotDeleteSelfError = Nh;
function Vw(t) {
  if (t instanceof fc.XRPCError) {
    if (t.error === "MemberNotFound")
      return new Mh(t);
    if (t.error === "CannotDeleteSelf")
      return new Nh(t);
  }
  return t;
}
cn.toKnownErr = Vw;
var cl = {};
Object.defineProperty(cl, "__esModule", { value: !0 });
cl.toKnownErr = void 0;
const jw = Z;
function Fw(t) {
  return t instanceof jw.XRPCError, t;
}
cl.toKnownErr = Fw;
var ta = {};
Object.defineProperty(ta, "__esModule", { value: !0 });
ta.toKnownErr = ta.MemberNotFoundError = void 0;
const Vh = Z;
class jh extends Vh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ta.MemberNotFoundError = jh;
function $w(t) {
  return t instanceof Vh.XRPCError && t.error === "MemberNotFound" ? new jh(t) : t;
}
ta.toKnownErr = $w;
var Wt = {};
Object.defineProperty(Wt, "__esModule", { value: !0 });
Wt.validateRepoBlobRef = Wt.isRepoBlobRef = Wt.validateRepoRef = Wt.isRepoRef = Wt.validateAccountView = Wt.isAccountView = Wt.validateStatusAttr = Wt.isStatusAttr = void 0;
const xn = ke, iu = Ie;
function Gw(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#statusAttr";
}
Wt.isStatusAttr = Gw;
function qw(t) {
  return iu.lexicons.validate("com.atproto.admin.defs#statusAttr", t);
}
Wt.validateStatusAttr = qw;
function Xw(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#accountView";
}
Wt.isAccountView = Xw;
function zw(t) {
  return iu.lexicons.validate("com.atproto.admin.defs#accountView", t);
}
Wt.validateAccountView = zw;
function Hw(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#repoRef";
}
Wt.isRepoRef = Hw;
function Zw(t) {
  return iu.lexicons.validate("com.atproto.admin.defs#repoRef", t);
}
Wt.validateRepoRef = Zw;
function Ww(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#repoBlobRef";
}
Wt.isRepoBlobRef = Ww;
function Yw(t) {
  return iu.lexicons.validate("com.atproto.admin.defs#repoBlobRef", t);
}
Wt.validateRepoBlobRef = Yw;
var Dt = {};
Object.defineProperty(Dt, "__esModule", { value: !0 });
Dt.validateLabelValueDefinitionStrings = Dt.isLabelValueDefinitionStrings = Dt.validateLabelValueDefinition = Dt.isLabelValueDefinition = Dt.validateSelfLabel = Dt.isSelfLabel = Dt.validateSelfLabels = Dt.isSelfLabels = Dt.validateLabel = Dt.isLabel = void 0;
const Ti = ke, dl = Ie;
function Jw(t) {
  return (0, Ti.isObj)(t) && (0, Ti.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#label";
}
Dt.isLabel = Jw;
function Qw(t) {
  return dl.lexicons.validate("com.atproto.label.defs#label", t);
}
Dt.validateLabel = Qw;
function eT(t) {
  return (0, Ti.isObj)(t) && (0, Ti.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#selfLabels";
}
Dt.isSelfLabels = eT;
function tT(t) {
  return dl.lexicons.validate("com.atproto.label.defs#selfLabels", t);
}
Dt.validateSelfLabels = tT;
function rT(t) {
  return (0, Ti.isObj)(t) && (0, Ti.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#selfLabel";
}
Dt.isSelfLabel = rT;
function iT(t) {
  return dl.lexicons.validate("com.atproto.label.defs#selfLabel", t);
}
Dt.validateSelfLabel = iT;
function nT(t) {
  return (0, Ti.isObj)(t) && (0, Ti.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#labelValueDefinition";
}
Dt.isLabelValueDefinition = nT;
function aT(t) {
  return dl.lexicons.validate("com.atproto.label.defs#labelValueDefinition", t);
}
Dt.validateLabelValueDefinition = aT;
function sT(t) {
  return (0, Ti.isObj)(t) && (0, Ti.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#labelValueDefinitionStrings";
}
Dt.isLabelValueDefinitionStrings = sT;
function oT(t) {
  return dl.lexicons.validate("com.atproto.label.defs#labelValueDefinitionStrings", t);
}
Dt.validateLabelValueDefinitionStrings = oT;
var bi = {};
Object.defineProperty(bi, "__esModule", { value: !0 });
bi.validateInfo = bi.isInfo = bi.validateLabels = bi.isLabels = void 0;
const $l = ke, Fh = Ie;
function lT(t) {
  return (0, $l.isObj)(t) && (0, $l.hasProp)(t, "$type") && t.$type === "com.atproto.label.subscribeLabels#labels";
}
bi.isLabels = lT;
function uT(t) {
  return Fh.lexicons.validate("com.atproto.label.subscribeLabels#labels", t);
}
bi.validateLabels = uT;
function cT(t) {
  return (0, $l.isObj)(t) && (0, $l.hasProp)(t, "$type") && t.$type === "com.atproto.label.subscribeLabels#info";
}
bi.isInfo = cT;
function dT(t) {
  return Fh.lexicons.validate("com.atproto.label.subscribeLabels#info", t);
}
bi.validateInfo = dT;
var dr = {};
Object.defineProperty(dr, "__esModule", { value: !0 });
dr.REASONAPPEAL = dr.REASONOTHER = dr.REASONRUDE = dr.REASONSEXUAL = dr.REASONMISLEADING = dr.REASONVIOLATION = dr.REASONSPAM = void 0;
dr.REASONSPAM = "com.atproto.moderation.defs#reasonSpam";
dr.REASONVIOLATION = "com.atproto.moderation.defs#reasonViolation";
dr.REASONMISLEADING = "com.atproto.moderation.defs#reasonMisleading";
dr.REASONSEXUAL = "com.atproto.moderation.defs#reasonSexual";
dr.REASONRUDE = "com.atproto.moderation.defs#reasonRude";
dr.REASONOTHER = "com.atproto.moderation.defs#reasonOther";
dr.REASONAPPEAL = "com.atproto.moderation.defs#reasonAppeal";
var ya = {};
Object.defineProperty(ya, "__esModule", { value: !0 });
ya.validateMain = ya.isMain = void 0;
const sd = ke, fT = Ie;
function pT(t) {
  return (0, sd.isObj)(t) && (0, sd.hasProp)(t, "$type") && (t.$type === "com.atproto.repo.strongRef#main" || t.$type === "com.atproto.repo.strongRef");
}
ya.isMain = pT;
function hT(t) {
  return fT.lexicons.validate("com.atproto.repo.strongRef#main", t);
}
ya.validateMain = hT;
var gi = {};
Object.defineProperty(gi, "__esModule", { value: !0 });
gi.validateInviteCodeUse = gi.isInviteCodeUse = gi.validateInviteCode = gi.isInviteCode = void 0;
const Gl = ke, $h = Ie;
function mT(t) {
  return (0, Gl.isObj)(t) && (0, Gl.hasProp)(t, "$type") && t.$type === "com.atproto.server.defs#inviteCode";
}
gi.isInviteCode = mT;
function yT(t) {
  return $h.lexicons.validate("com.atproto.server.defs#inviteCode", t);
}
gi.validateInviteCode = yT;
function bT(t) {
  return (0, Gl.isObj)(t) && (0, Gl.hasProp)(t, "$type") && t.$type === "com.atproto.server.defs#inviteCodeUse";
}
gi.isInviteCodeUse = bT;
function gT(t) {
  return $h.lexicons.validate("com.atproto.server.defs#inviteCodeUse", t);
}
gi.validateInviteCodeUse = gT;
var We = {};
Object.defineProperty(We, "__esModule", { value: !0 });
We.validateRepoOp = We.isRepoOp = We.validateInfo = We.isInfo = We.validateTombstone = We.isTombstone = We.validateMigrate = We.isMigrate = We.validateHandle = We.isHandle = We.validateAccount = We.isAccount = We.validateIdentity = We.isIdentity = We.validateCommit = We.isCommit = void 0;
const pr = ke, Cn = Ie;
function xT(t) {
  return (0, pr.isObj)(t) && (0, pr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#commit";
}
We.isCommit = xT;
function ET(t) {
  return Cn.lexicons.validate("com.atproto.sync.subscribeRepos#commit", t);
}
We.validateCommit = ET;
function vT(t) {
  return (0, pr.isObj)(t) && (0, pr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#identity";
}
We.isIdentity = vT;
function RT(t) {
  return Cn.lexicons.validate("com.atproto.sync.subscribeRepos#identity", t);
}
We.validateIdentity = RT;
function AT(t) {
  return (0, pr.isObj)(t) && (0, pr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#account";
}
We.isAccount = AT;
function _T(t) {
  return Cn.lexicons.validate("com.atproto.sync.subscribeRepos#account", t);
}
We.validateAccount = _T;
function wT(t) {
  return (0, pr.isObj)(t) && (0, pr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#handle";
}
We.isHandle = wT;
function TT(t) {
  return Cn.lexicons.validate("com.atproto.sync.subscribeRepos#handle", t);
}
We.validateHandle = TT;
function ST(t) {
  return (0, pr.isObj)(t) && (0, pr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#migrate";
}
We.isMigrate = ST;
function CT(t) {
  return Cn.lexicons.validate("com.atproto.sync.subscribeRepos#migrate", t);
}
We.validateMigrate = CT;
function LT(t) {
  return (0, pr.isObj)(t) && (0, pr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#tombstone";
}
We.isTombstone = LT;
function kT(t) {
  return Cn.lexicons.validate("com.atproto.sync.subscribeRepos#tombstone", t);
}
We.validateTombstone = kT;
function DT(t) {
  return (0, pr.isObj)(t) && (0, pr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#info";
}
We.isInfo = DT;
function PT(t) {
  return Cn.lexicons.validate("com.atproto.sync.subscribeRepos#info", t);
}
We.validateInfo = PT;
function BT(t) {
  return (0, pr.isObj)(t) && (0, pr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#repoOp";
}
We.isRepoOp = BT;
function IT(t) {
  return Cn.lexicons.validate("com.atproto.sync.subscribeRepos#repoOp", t);
}
We.validateRepoOp = IT;
var pe = {};
Object.defineProperty(pe, "__esModule", { value: !0 });
pe.validateBskyAppProgressGuide = pe.isBskyAppProgressGuide = pe.validateBskyAppStatePref = pe.isBskyAppStatePref = pe.validateLabelerPrefItem = pe.isLabelerPrefItem = pe.validateLabelersPref = pe.isLabelersPref = pe.validateHiddenPostsPref = pe.isHiddenPostsPref = pe.validateMutedWordsPref = pe.isMutedWordsPref = pe.validateMutedWord = pe.isMutedWord = pe.validateInterestsPref = pe.isInterestsPref = pe.validateThreadViewPref = pe.isThreadViewPref = pe.validateFeedViewPref = pe.isFeedViewPref = pe.validatePersonalDetailsPref = pe.isPersonalDetailsPref = pe.validateSavedFeedsPref = pe.isSavedFeedsPref = pe.validateSavedFeedsPrefV2 = pe.isSavedFeedsPrefV2 = pe.validateSavedFeed = pe.isSavedFeed = pe.validateContentLabelPref = pe.isContentLabelPref = pe.validateAdultContentPref = pe.isAdultContentPref = pe.validateKnownFollowers = pe.isKnownFollowers = pe.validateViewerState = pe.isViewerState = pe.validateProfileAssociatedChat = pe.isProfileAssociatedChat = pe.validateProfileAssociated = pe.isProfileAssociated = pe.validateProfileViewDetailed = pe.isProfileViewDetailed = pe.validateProfileView = pe.isProfileView = pe.validateProfileViewBasic = pe.isProfileViewBasic = void 0;
const Me = ke, wt = Ie;
function UT(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileViewBasic";
}
pe.isProfileViewBasic = UT;
function OT(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#profileViewBasic", t);
}
pe.validateProfileViewBasic = OT;
function KT(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileView";
}
pe.isProfileView = KT;
function MT(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#profileView", t);
}
pe.validateProfileView = MT;
function NT(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileViewDetailed";
}
pe.isProfileViewDetailed = NT;
function VT(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#profileViewDetailed", t);
}
pe.validateProfileViewDetailed = VT;
function jT(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileAssociated";
}
pe.isProfileAssociated = jT;
function FT(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#profileAssociated", t);
}
pe.validateProfileAssociated = FT;
function $T(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileAssociatedChat";
}
pe.isProfileAssociatedChat = $T;
function GT(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#profileAssociatedChat", t);
}
pe.validateProfileAssociatedChat = GT;
function qT(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#viewerState";
}
pe.isViewerState = qT;
function XT(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#viewerState", t);
}
pe.validateViewerState = XT;
function zT(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#knownFollowers";
}
pe.isKnownFollowers = zT;
function HT(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#knownFollowers", t);
}
pe.validateKnownFollowers = HT;
function ZT(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#adultContentPref";
}
pe.isAdultContentPref = ZT;
function WT(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#adultContentPref", t);
}
pe.validateAdultContentPref = WT;
function YT(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#contentLabelPref";
}
pe.isContentLabelPref = YT;
function JT(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#contentLabelPref", t);
}
pe.validateContentLabelPref = JT;
function QT(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeed";
}
pe.isSavedFeed = QT;
function eS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#savedFeed", t);
}
pe.validateSavedFeed = eS;
function tS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeedsPrefV2";
}
pe.isSavedFeedsPrefV2 = tS;
function rS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#savedFeedsPrefV2", t);
}
pe.validateSavedFeedsPrefV2 = rS;
function iS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeedsPref";
}
pe.isSavedFeedsPref = iS;
function nS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#savedFeedsPref", t);
}
pe.validateSavedFeedsPref = nS;
function aS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#personalDetailsPref";
}
pe.isPersonalDetailsPref = aS;
function sS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#personalDetailsPref", t);
}
pe.validatePersonalDetailsPref = sS;
function oS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#feedViewPref";
}
pe.isFeedViewPref = oS;
function lS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#feedViewPref", t);
}
pe.validateFeedViewPref = lS;
function uS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#threadViewPref";
}
pe.isThreadViewPref = uS;
function cS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#threadViewPref", t);
}
pe.validateThreadViewPref = cS;
function dS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#interestsPref";
}
pe.isInterestsPref = dS;
function fS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#interestsPref", t);
}
pe.validateInterestsPref = fS;
function pS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#mutedWord";
}
pe.isMutedWord = pS;
function hS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#mutedWord", t);
}
pe.validateMutedWord = hS;
function mS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#mutedWordsPref";
}
pe.isMutedWordsPref = mS;
function yS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#mutedWordsPref", t);
}
pe.validateMutedWordsPref = yS;
function bS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#hiddenPostsPref";
}
pe.isHiddenPostsPref = bS;
function gS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#hiddenPostsPref", t);
}
pe.validateHiddenPostsPref = gS;
function xS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#labelersPref";
}
pe.isLabelersPref = xS;
function ES(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#labelersPref", t);
}
pe.validateLabelersPref = ES;
function vS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#labelerPrefItem";
}
pe.isLabelerPrefItem = vS;
function RS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#labelerPrefItem", t);
}
pe.validateLabelerPrefItem = RS;
function AS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#bskyAppStatePref";
}
pe.isBskyAppStatePref = AS;
function _S(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#bskyAppStatePref", t);
}
pe.validateBskyAppStatePref = _S;
function wS(t) {
  return (0, Me.isObj)(t) && (0, Me.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#bskyAppProgressGuide";
}
pe.isBskyAppProgressGuide = wS;
function TS(t) {
  return wt.lexicons.validate("app.bsky.actor.defs#bskyAppProgressGuide", t);
}
pe.validateBskyAppProgressGuide = TS;
var ba = {};
Object.defineProperty(ba, "__esModule", { value: !0 });
ba.validateRecord = ba.isRecord = void 0;
const od = ke, SS = Ie;
function CS(t) {
  return (0, od.isObj)(t) && (0, od.hasProp)(t, "$type") && (t.$type === "app.bsky.actor.profile#main" || t.$type === "app.bsky.actor.profile");
}
ba.isRecord = CS;
function LS(t) {
  return SS.lexicons.validate("app.bsky.actor.profile#main", t);
}
ba.validateRecord = LS;
var Yt = {};
Object.defineProperty(Yt, "__esModule", { value: !0 });
Yt.validateViewExternal = Yt.isViewExternal = Yt.validateView = Yt.isView = Yt.validateExternal = Yt.isExternal = Yt.validateMain = Yt.isMain = void 0;
const En = ke, nu = Ie;
function kS(t) {
  return (0, En.isObj)(t) && (0, En.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.external#main" || t.$type === "app.bsky.embed.external");
}
Yt.isMain = kS;
function DS(t) {
  return nu.lexicons.validate("app.bsky.embed.external#main", t);
}
Yt.validateMain = DS;
function PS(t) {
  return (0, En.isObj)(t) && (0, En.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#external";
}
Yt.isExternal = PS;
function BS(t) {
  return nu.lexicons.validate("app.bsky.embed.external#external", t);
}
Yt.validateExternal = BS;
function IS(t) {
  return (0, En.isObj)(t) && (0, En.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#view";
}
Yt.isView = IS;
function US(t) {
  return nu.lexicons.validate("app.bsky.embed.external#view", t);
}
Yt.validateView = US;
function OS(t) {
  return (0, En.isObj)(t) && (0, En.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#viewExternal";
}
Yt.isViewExternal = OS;
function KS(t) {
  return nu.lexicons.validate("app.bsky.embed.external#viewExternal", t);
}
Yt.validateViewExternal = KS;
var Pt = {};
Object.defineProperty(Pt, "__esModule", { value: !0 });
Pt.validateViewImage = Pt.isViewImage = Pt.validateView = Pt.isView = Pt.validateAspectRatio = Pt.isAspectRatio = Pt.validateImage = Pt.isImage = Pt.validateMain = Pt.isMain = void 0;
const Si = ke, fl = Ie;
function MS(t) {
  return (0, Si.isObj)(t) && (0, Si.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.images#main" || t.$type === "app.bsky.embed.images");
}
Pt.isMain = MS;
function NS(t) {
  return fl.lexicons.validate("app.bsky.embed.images#main", t);
}
Pt.validateMain = NS;
function VS(t) {
  return (0, Si.isObj)(t) && (0, Si.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#image";
}
Pt.isImage = VS;
function jS(t) {
  return fl.lexicons.validate("app.bsky.embed.images#image", t);
}
Pt.validateImage = jS;
function FS(t) {
  return (0, Si.isObj)(t) && (0, Si.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#aspectRatio";
}
Pt.isAspectRatio = FS;
function $S(t) {
  return fl.lexicons.validate("app.bsky.embed.images#aspectRatio", t);
}
Pt.validateAspectRatio = $S;
function GS(t) {
  return (0, Si.isObj)(t) && (0, Si.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#view";
}
Pt.isView = GS;
function qS(t) {
  return fl.lexicons.validate("app.bsky.embed.images#view", t);
}
Pt.validateView = qS;
function XS(t) {
  return (0, Si.isObj)(t) && (0, Si.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#viewImage";
}
Pt.isViewImage = XS;
function zS(t) {
  return fl.lexicons.validate("app.bsky.embed.images#viewImage", t);
}
Pt.validateViewImage = zS;
var Bt = {};
Object.defineProperty(Bt, "__esModule", { value: !0 });
Bt.validateViewBlocked = Bt.isViewBlocked = Bt.validateViewNotFound = Bt.isViewNotFound = Bt.validateViewRecord = Bt.isViewRecord = Bt.validateView = Bt.isView = Bt.validateMain = Bt.isMain = void 0;
const Ci = ke, pl = Ie;
function HS(t) {
  return (0, Ci.isObj)(t) && (0, Ci.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.record#main" || t.$type === "app.bsky.embed.record");
}
Bt.isMain = HS;
function ZS(t) {
  return pl.lexicons.validate("app.bsky.embed.record#main", t);
}
Bt.validateMain = ZS;
function WS(t) {
  return (0, Ci.isObj)(t) && (0, Ci.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#view";
}
Bt.isView = WS;
function YS(t) {
  return pl.lexicons.validate("app.bsky.embed.record#view", t);
}
Bt.validateView = YS;
function JS(t) {
  return (0, Ci.isObj)(t) && (0, Ci.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewRecord";
}
Bt.isViewRecord = JS;
function QS(t) {
  return pl.lexicons.validate("app.bsky.embed.record#viewRecord", t);
}
Bt.validateViewRecord = QS;
function eC(t) {
  return (0, Ci.isObj)(t) && (0, Ci.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewNotFound";
}
Bt.isViewNotFound = eC;
function tC(t) {
  return pl.lexicons.validate("app.bsky.embed.record#viewNotFound", t);
}
Bt.validateViewNotFound = tC;
function rC(t) {
  return (0, Ci.isObj)(t) && (0, Ci.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewBlocked";
}
Bt.isViewBlocked = rC;
function iC(t) {
  return pl.lexicons.validate("app.bsky.embed.record#viewBlocked", t);
}
Bt.validateViewBlocked = iC;
var xi = {};
Object.defineProperty(xi, "__esModule", { value: !0 });
xi.validateView = xi.isView = xi.validateMain = xi.isMain = void 0;
const ql = ke, Gh = Ie;
function nC(t) {
  return (0, ql.isObj)(t) && (0, ql.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.recordWithMedia#main" || t.$type === "app.bsky.embed.recordWithMedia");
}
xi.isMain = nC;
function aC(t) {
  return Gh.lexicons.validate("app.bsky.embed.recordWithMedia#main", t);
}
xi.validateMain = aC;
function sC(t) {
  return (0, ql.isObj)(t) && (0, ql.hasProp)(t, "$type") && t.$type === "app.bsky.embed.recordWithMedia#view";
}
xi.isView = sC;
function oC(t) {
  return Gh.lexicons.validate("app.bsky.embed.recordWithMedia#view", t);
}
xi.validateView = oC;
var be = {};
Object.defineProperty(be, "__esModule", { value: !0 });
be.INTERACTIONSHARE = be.INTERACTIONQUOTE = be.INTERACTIONREPLY = be.INTERACTIONREPOST = be.INTERACTIONLIKE = be.INTERACTIONSEEN = be.CLICKTHROUGHEMBED = be.CLICKTHROUGHREPOSTER = be.CLICKTHROUGHAUTHOR = be.CLICKTHROUGHITEM = be.REQUESTMORE = be.REQUESTLESS = be.validateInteraction = be.isInteraction = be.validateThreadgateView = be.isThreadgateView = be.validateSkeletonReasonRepost = be.isSkeletonReasonRepost = be.validateSkeletonFeedPost = be.isSkeletonFeedPost = be.validateGeneratorViewerState = be.isGeneratorViewerState = be.validateGeneratorView = be.isGeneratorView = be.validateBlockedAuthor = be.isBlockedAuthor = be.validateBlockedPost = be.isBlockedPost = be.validateNotFoundPost = be.isNotFoundPost = be.validateThreadViewPost = be.isThreadViewPost = be.validateReasonRepost = be.isReasonRepost = be.validateReplyRef = be.isReplyRef = be.validateFeedViewPost = be.isFeedViewPost = be.validateViewerState = be.isViewerState = be.validatePostView = be.isPostView = void 0;
const at = ke, Ar = Ie;
function lC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#postView";
}
be.isPostView = lC;
function uC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#postView", t);
}
be.validatePostView = uC;
function cC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#viewerState";
}
be.isViewerState = cC;
function dC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#viewerState", t);
}
be.validateViewerState = dC;
function fC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#feedViewPost";
}
be.isFeedViewPost = fC;
function pC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#feedViewPost", t);
}
be.validateFeedViewPost = pC;
function hC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#replyRef";
}
be.isReplyRef = hC;
function mC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#replyRef", t);
}
be.validateReplyRef = mC;
function yC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#reasonRepost";
}
be.isReasonRepost = yC;
function bC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#reasonRepost", t);
}
be.validateReasonRepost = bC;
function gC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#threadViewPost";
}
be.isThreadViewPost = gC;
function xC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#threadViewPost", t);
}
be.validateThreadViewPost = xC;
function EC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#notFoundPost";
}
be.isNotFoundPost = EC;
function vC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#notFoundPost", t);
}
be.validateNotFoundPost = vC;
function RC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#blockedPost";
}
be.isBlockedPost = RC;
function AC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#blockedPost", t);
}
be.validateBlockedPost = AC;
function _C(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#blockedAuthor";
}
be.isBlockedAuthor = _C;
function wC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#blockedAuthor", t);
}
be.validateBlockedAuthor = wC;
function TC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#generatorView";
}
be.isGeneratorView = TC;
function SC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#generatorView", t);
}
be.validateGeneratorView = SC;
function CC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#generatorViewerState";
}
be.isGeneratorViewerState = CC;
function LC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#generatorViewerState", t);
}
be.validateGeneratorViewerState = LC;
function kC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#skeletonFeedPost";
}
be.isSkeletonFeedPost = kC;
function DC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#skeletonFeedPost", t);
}
be.validateSkeletonFeedPost = DC;
function PC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#skeletonReasonRepost";
}
be.isSkeletonReasonRepost = PC;
function BC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#skeletonReasonRepost", t);
}
be.validateSkeletonReasonRepost = BC;
function IC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#threadgateView";
}
be.isThreadgateView = IC;
function UC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#threadgateView", t);
}
be.validateThreadgateView = UC;
function OC(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#interaction";
}
be.isInteraction = OC;
function KC(t) {
  return Ar.lexicons.validate("app.bsky.feed.defs#interaction", t);
}
be.validateInteraction = KC;
be.REQUESTLESS = "app.bsky.feed.defs#requestLess";
be.REQUESTMORE = "app.bsky.feed.defs#requestMore";
be.CLICKTHROUGHITEM = "app.bsky.feed.defs#clickthroughItem";
be.CLICKTHROUGHAUTHOR = "app.bsky.feed.defs#clickthroughAuthor";
be.CLICKTHROUGHREPOSTER = "app.bsky.feed.defs#clickthroughReposter";
be.CLICKTHROUGHEMBED = "app.bsky.feed.defs#clickthroughEmbed";
be.INTERACTIONSEEN = "app.bsky.feed.defs#interactionSeen";
be.INTERACTIONLIKE = "app.bsky.feed.defs#interactionLike";
be.INTERACTIONREPOST = "app.bsky.feed.defs#interactionRepost";
be.INTERACTIONREPLY = "app.bsky.feed.defs#interactionReply";
be.INTERACTIONQUOTE = "app.bsky.feed.defs#interactionQuote";
be.INTERACTIONSHARE = "app.bsky.feed.defs#interactionShare";
var ga = {};
Object.defineProperty(ga, "__esModule", { value: !0 });
ga.validateRecord = ga.isRecord = void 0;
const ld = ke, MC = Ie;
function NC(t) {
  return (0, ld.isObj)(t) && (0, ld.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.generator#main" || t.$type === "app.bsky.feed.generator");
}
ga.isRecord = NC;
function VC(t) {
  return MC.lexicons.validate("app.bsky.feed.generator#main", t);
}
ga.validateRecord = VC;
var xa = {};
Object.defineProperty(xa, "__esModule", { value: !0 });
xa.validateRecord = xa.isRecord = void 0;
const ud = ke, jC = Ie;
function FC(t) {
  return (0, ud.isObj)(t) && (0, ud.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.like#main" || t.$type === "app.bsky.feed.like");
}
xa.isRecord = FC;
function $C(t) {
  return jC.lexicons.validate("app.bsky.feed.like#main", t);
}
xa.validateRecord = $C;
var Jt = {};
Object.defineProperty(Jt, "__esModule", { value: !0 });
Jt.validateTextSlice = Jt.isTextSlice = Jt.validateEntity = Jt.isEntity = Jt.validateReplyRef = Jt.isReplyRef = Jt.validateRecord = Jt.isRecord = void 0;
const vn = ke, au = Ie;
function GC(t) {
  return (0, vn.isObj)(t) && (0, vn.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.post#main" || t.$type === "app.bsky.feed.post");
}
Jt.isRecord = GC;
function qC(t) {
  return au.lexicons.validate("app.bsky.feed.post#main", t);
}
Jt.validateRecord = qC;
function XC(t) {
  return (0, vn.isObj)(t) && (0, vn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#replyRef";
}
Jt.isReplyRef = XC;
function zC(t) {
  return au.lexicons.validate("app.bsky.feed.post#replyRef", t);
}
Jt.validateReplyRef = zC;
function HC(t) {
  return (0, vn.isObj)(t) && (0, vn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#entity";
}
Jt.isEntity = HC;
function ZC(t) {
  return au.lexicons.validate("app.bsky.feed.post#entity", t);
}
Jt.validateEntity = ZC;
function WC(t) {
  return (0, vn.isObj)(t) && (0, vn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#textSlice";
}
Jt.isTextSlice = WC;
function YC(t) {
  return au.lexicons.validate("app.bsky.feed.post#textSlice", t);
}
Jt.validateTextSlice = YC;
var Ea = {};
Object.defineProperty(Ea, "__esModule", { value: !0 });
Ea.validateRecord = Ea.isRecord = void 0;
const cd = ke, JC = Ie;
function QC(t) {
  return (0, cd.isObj)(t) && (0, cd.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.repost#main" || t.$type === "app.bsky.feed.repost");
}
Ea.isRecord = QC;
function e1(t) {
  return JC.lexicons.validate("app.bsky.feed.repost#main", t);
}
Ea.validateRecord = e1;
var Qt = {};
Object.defineProperty(Qt, "__esModule", { value: !0 });
Qt.validateListRule = Qt.isListRule = Qt.validateFollowingRule = Qt.isFollowingRule = Qt.validateMentionRule = Qt.isMentionRule = Qt.validateRecord = Qt.isRecord = void 0;
const Rn = ke, su = Ie;
function t1(t) {
  return (0, Rn.isObj)(t) && (0, Rn.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.threadgate#main" || t.$type === "app.bsky.feed.threadgate");
}
Qt.isRecord = t1;
function r1(t) {
  return su.lexicons.validate("app.bsky.feed.threadgate#main", t);
}
Qt.validateRecord = r1;
function i1(t) {
  return (0, Rn.isObj)(t) && (0, Rn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#mentionRule";
}
Qt.isMentionRule = i1;
function n1(t) {
  return su.lexicons.validate("app.bsky.feed.threadgate#mentionRule", t);
}
Qt.validateMentionRule = n1;
function a1(t) {
  return (0, Rn.isObj)(t) && (0, Rn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#followingRule";
}
Qt.isFollowingRule = a1;
function s1(t) {
  return su.lexicons.validate("app.bsky.feed.threadgate#followingRule", t);
}
Qt.validateFollowingRule = s1;
function o1(t) {
  return (0, Rn.isObj)(t) && (0, Rn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#listRule";
}
Qt.isListRule = o1;
function l1(t) {
  return su.lexicons.validate("app.bsky.feed.threadgate#listRule", t);
}
Qt.validateListRule = l1;
var va = {};
Object.defineProperty(va, "__esModule", { value: !0 });
va.validateRecord = va.isRecord = void 0;
const dd = ke, u1 = Ie;
function c1(t) {
  return (0, dd.isObj)(t) && (0, dd.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.block#main" || t.$type === "app.bsky.graph.block");
}
va.isRecord = c1;
function d1(t) {
  return u1.lexicons.validate("app.bsky.graph.block#main", t);
}
va.validateRecord = d1;
var Ge = {};
Object.defineProperty(Ge, "__esModule", { value: !0 });
Ge.validateRelationship = Ge.isRelationship = Ge.validateNotFoundActor = Ge.isNotFoundActor = Ge.validateListViewerState = Ge.isListViewerState = Ge.REFERENCELIST = Ge.CURATELIST = Ge.MODLIST = Ge.validateStarterPackViewBasic = Ge.isStarterPackViewBasic = Ge.validateStarterPackView = Ge.isStarterPackView = Ge.validateListItemView = Ge.isListItemView = Ge.validateListView = Ge.isListView = Ge.validateListViewBasic = Ge.isListViewBasic = void 0;
const hr = ke, Ln = Ie;
function f1(t) {
  return (0, hr.isObj)(t) && (0, hr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listViewBasic";
}
Ge.isListViewBasic = f1;
function p1(t) {
  return Ln.lexicons.validate("app.bsky.graph.defs#listViewBasic", t);
}
Ge.validateListViewBasic = p1;
function h1(t) {
  return (0, hr.isObj)(t) && (0, hr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listView";
}
Ge.isListView = h1;
function m1(t) {
  return Ln.lexicons.validate("app.bsky.graph.defs#listView", t);
}
Ge.validateListView = m1;
function y1(t) {
  return (0, hr.isObj)(t) && (0, hr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listItemView";
}
Ge.isListItemView = y1;
function b1(t) {
  return Ln.lexicons.validate("app.bsky.graph.defs#listItemView", t);
}
Ge.validateListItemView = b1;
function g1(t) {
  return (0, hr.isObj)(t) && (0, hr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#starterPackView";
}
Ge.isStarterPackView = g1;
function x1(t) {
  return Ln.lexicons.validate("app.bsky.graph.defs#starterPackView", t);
}
Ge.validateStarterPackView = x1;
function E1(t) {
  return (0, hr.isObj)(t) && (0, hr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#starterPackViewBasic";
}
Ge.isStarterPackViewBasic = E1;
function v1(t) {
  return Ln.lexicons.validate("app.bsky.graph.defs#starterPackViewBasic", t);
}
Ge.validateStarterPackViewBasic = v1;
Ge.MODLIST = "app.bsky.graph.defs#modlist";
Ge.CURATELIST = "app.bsky.graph.defs#curatelist";
Ge.REFERENCELIST = "app.bsky.graph.defs#referencelist";
function R1(t) {
  return (0, hr.isObj)(t) && (0, hr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listViewerState";
}
Ge.isListViewerState = R1;
function A1(t) {
  return Ln.lexicons.validate("app.bsky.graph.defs#listViewerState", t);
}
Ge.validateListViewerState = A1;
function _1(t) {
  return (0, hr.isObj)(t) && (0, hr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#notFoundActor";
}
Ge.isNotFoundActor = _1;
function w1(t) {
  return Ln.lexicons.validate("app.bsky.graph.defs#notFoundActor", t);
}
Ge.validateNotFoundActor = w1;
function T1(t) {
  return (0, hr.isObj)(t) && (0, hr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#relationship";
}
Ge.isRelationship = T1;
function S1(t) {
  return Ln.lexicons.validate("app.bsky.graph.defs#relationship", t);
}
Ge.validateRelationship = S1;
var Ra = {};
Object.defineProperty(Ra, "__esModule", { value: !0 });
Ra.validateRecord = Ra.isRecord = void 0;
const fd = ke, C1 = Ie;
function L1(t) {
  return (0, fd.isObj)(t) && (0, fd.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.follow#main" || t.$type === "app.bsky.graph.follow");
}
Ra.isRecord = L1;
function k1(t) {
  return C1.lexicons.validate("app.bsky.graph.follow#main", t);
}
Ra.validateRecord = k1;
var Aa = {};
Object.defineProperty(Aa, "__esModule", { value: !0 });
Aa.validateRecord = Aa.isRecord = void 0;
const pd = ke, D1 = Ie;
function P1(t) {
  return (0, pd.isObj)(t) && (0, pd.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.list#main" || t.$type === "app.bsky.graph.list");
}
Aa.isRecord = P1;
function B1(t) {
  return D1.lexicons.validate("app.bsky.graph.list#main", t);
}
Aa.validateRecord = B1;
var _a = {};
Object.defineProperty(_a, "__esModule", { value: !0 });
_a.validateRecord = _a.isRecord = void 0;
const hd = ke, I1 = Ie;
function U1(t) {
  return (0, hd.isObj)(t) && (0, hd.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.listblock#main" || t.$type === "app.bsky.graph.listblock");
}
_a.isRecord = U1;
function O1(t) {
  return I1.lexicons.validate("app.bsky.graph.listblock#main", t);
}
_a.validateRecord = O1;
var wa = {};
Object.defineProperty(wa, "__esModule", { value: !0 });
wa.validateRecord = wa.isRecord = void 0;
const md = ke, K1 = Ie;
function M1(t) {
  return (0, md.isObj)(t) && (0, md.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.listitem#main" || t.$type === "app.bsky.graph.listitem");
}
wa.isRecord = M1;
function N1(t) {
  return K1.lexicons.validate("app.bsky.graph.listitem#main", t);
}
wa.validateRecord = N1;
var Ei = {};
Object.defineProperty(Ei, "__esModule", { value: !0 });
Ei.validateFeedItem = Ei.isFeedItem = Ei.validateRecord = Ei.isRecord = void 0;
const Xl = ke, qh = Ie;
function V1(t) {
  return (0, Xl.isObj)(t) && (0, Xl.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.starterpack#main" || t.$type === "app.bsky.graph.starterpack");
}
Ei.isRecord = V1;
function j1(t) {
  return qh.lexicons.validate("app.bsky.graph.starterpack#main", t);
}
Ei.validateRecord = j1;
function F1(t) {
  return (0, Xl.isObj)(t) && (0, Xl.hasProp)(t, "$type") && t.$type === "app.bsky.graph.starterpack#feedItem";
}
Ei.isFeedItem = F1;
function $1(t) {
  return qh.lexicons.validate("app.bsky.graph.starterpack#feedItem", t);
}
Ei.validateFeedItem = $1;
var er = {};
Object.defineProperty(er, "__esModule", { value: !0 });
er.validateLabelerPolicies = er.isLabelerPolicies = er.validateLabelerViewerState = er.isLabelerViewerState = er.validateLabelerViewDetailed = er.isLabelerViewDetailed = er.validateLabelerView = er.isLabelerView = void 0;
const An = ke, ou = Ie;
function G1(t) {
  return (0, An.isObj)(t) && (0, An.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerView";
}
er.isLabelerView = G1;
function q1(t) {
  return ou.lexicons.validate("app.bsky.labeler.defs#labelerView", t);
}
er.validateLabelerView = q1;
function X1(t) {
  return (0, An.isObj)(t) && (0, An.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerViewDetailed";
}
er.isLabelerViewDetailed = X1;
function z1(t) {
  return ou.lexicons.validate("app.bsky.labeler.defs#labelerViewDetailed", t);
}
er.validateLabelerViewDetailed = z1;
function H1(t) {
  return (0, An.isObj)(t) && (0, An.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerViewerState";
}
er.isLabelerViewerState = H1;
function Z1(t) {
  return ou.lexicons.validate("app.bsky.labeler.defs#labelerViewerState", t);
}
er.validateLabelerViewerState = Z1;
function W1(t) {
  return (0, An.isObj)(t) && (0, An.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerPolicies";
}
er.isLabelerPolicies = W1;
function Y1(t) {
  return ou.lexicons.validate("app.bsky.labeler.defs#labelerPolicies", t);
}
er.validateLabelerPolicies = Y1;
var Ta = {};
Object.defineProperty(Ta, "__esModule", { value: !0 });
Ta.validateRecord = Ta.isRecord = void 0;
const yd = ke, J1 = Ie;
function Q1(t) {
  return (0, yd.isObj)(t) && (0, yd.hasProp)(t, "$type") && (t.$type === "app.bsky.labeler.service#main" || t.$type === "app.bsky.labeler.service");
}
Ta.isRecord = Q1;
function eL(t) {
  return J1.lexicons.validate("app.bsky.labeler.service#main", t);
}
Ta.validateRecord = eL;
var It = {};
Object.defineProperty(It, "__esModule", { value: !0 });
It.validateByteSlice = It.isByteSlice = It.validateTag = It.isTag = It.validateLink = It.isLink = It.validateMention = It.isMention = It.validateMain = It.isMain = void 0;
const Li = ke, hl = Ie;
function tL(t) {
  return (0, Li.isObj)(t) && (0, Li.hasProp)(t, "$type") && (t.$type === "app.bsky.richtext.facet#main" || t.$type === "app.bsky.richtext.facet");
}
It.isMain = tL;
function rL(t) {
  return hl.lexicons.validate("app.bsky.richtext.facet#main", t);
}
It.validateMain = rL;
function iL(t) {
  return (0, Li.isObj)(t) && (0, Li.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#mention";
}
It.isMention = iL;
function nL(t) {
  return hl.lexicons.validate("app.bsky.richtext.facet#mention", t);
}
It.validateMention = nL;
function aL(t) {
  return (0, Li.isObj)(t) && (0, Li.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#link";
}
It.isLink = aL;
function sL(t) {
  return hl.lexicons.validate("app.bsky.richtext.facet#link", t);
}
It.validateLink = sL;
function oL(t) {
  return (0, Li.isObj)(t) && (0, Li.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#tag";
}
It.isTag = oL;
function lL(t) {
  return hl.lexicons.validate("app.bsky.richtext.facet#tag", t);
}
It.validateTag = lL;
function uL(t) {
  return (0, Li.isObj)(t) && (0, Li.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#byteSlice";
}
It.isByteSlice = uL;
function cL(t) {
  return hl.lexicons.validate("app.bsky.richtext.facet#byteSlice", t);
}
It.validateByteSlice = cL;
var vi = {};
Object.defineProperty(vi, "__esModule", { value: !0 });
vi.validateSkeletonSearchActor = vi.isSkeletonSearchActor = vi.validateSkeletonSearchPost = vi.isSkeletonSearchPost = void 0;
const zl = ke, Xh = Ie;
function dL(t) {
  return (0, zl.isObj)(t) && (0, zl.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.defs#skeletonSearchPost";
}
vi.isSkeletonSearchPost = dL;
function fL(t) {
  return Xh.lexicons.validate("app.bsky.unspecced.defs#skeletonSearchPost", t);
}
vi.validateSkeletonSearchPost = fL;
function pL(t) {
  return (0, zl.isObj)(t) && (0, zl.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.defs#skeletonSearchActor";
}
vi.isSkeletonSearchActor = pL;
function hL(t) {
  return Xh.lexicons.validate("app.bsky.unspecced.defs#skeletonSearchActor", t);
}
vi.validateSkeletonSearchActor = hL;
var Sa = {};
Object.defineProperty(Sa, "__esModule", { value: !0 });
Sa.validateRecord = Sa.isRecord = void 0;
const bd = ke, mL = Ie;
function yL(t) {
  return (0, bd.isObj)(t) && (0, bd.hasProp)(t, "$type") && (t.$type === "chat.bsky.actor.declaration#main" || t.$type === "chat.bsky.actor.declaration");
}
Sa.isRecord = yL;
function bL(t) {
  return mL.lexicons.validate("chat.bsky.actor.declaration#main", t);
}
Sa.validateRecord = bL;
var Ca = {};
Object.defineProperty(Ca, "__esModule", { value: !0 });
Ca.validateProfileViewBasic = Ca.isProfileViewBasic = void 0;
const gd = ke, gL = Ie;
function xL(t) {
  return (0, gd.isObj)(t) && (0, gd.hasProp)(t, "$type") && t.$type === "chat.bsky.actor.defs#profileViewBasic";
}
Ca.isProfileViewBasic = xL;
function EL(t) {
  return gL.lexicons.validate("chat.bsky.actor.defs#profileViewBasic", t);
}
Ca.validateProfileViewBasic = EL;
var je = {};
Object.defineProperty(je, "__esModule", { value: !0 });
je.validateLogDeleteMessage = je.isLogDeleteMessage = je.validateLogCreateMessage = je.isLogCreateMessage = je.validateLogLeaveConvo = je.isLogLeaveConvo = je.validateLogBeginConvo = je.isLogBeginConvo = je.validateConvoView = je.isConvoView = je.validateMessageViewSender = je.isMessageViewSender = je.validateDeletedMessageView = je.isDeletedMessageView = je.validateMessageView = je.isMessageView = je.validateMessageInput = je.isMessageInput = je.validateMessageRef = je.isMessageRef = void 0;
const Vt = ke, Bi = Ie;
function vL(t) {
  return (0, Vt.isObj)(t) && (0, Vt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageRef";
}
je.isMessageRef = vL;
function RL(t) {
  return Bi.lexicons.validate("chat.bsky.convo.defs#messageRef", t);
}
je.validateMessageRef = RL;
function AL(t) {
  return (0, Vt.isObj)(t) && (0, Vt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageInput";
}
je.isMessageInput = AL;
function _L(t) {
  return Bi.lexicons.validate("chat.bsky.convo.defs#messageInput", t);
}
je.validateMessageInput = _L;
function wL(t) {
  return (0, Vt.isObj)(t) && (0, Vt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageView";
}
je.isMessageView = wL;
function TL(t) {
  return Bi.lexicons.validate("chat.bsky.convo.defs#messageView", t);
}
je.validateMessageView = TL;
function SL(t) {
  return (0, Vt.isObj)(t) && (0, Vt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#deletedMessageView";
}
je.isDeletedMessageView = SL;
function CL(t) {
  return Bi.lexicons.validate("chat.bsky.convo.defs#deletedMessageView", t);
}
je.validateDeletedMessageView = CL;
function LL(t) {
  return (0, Vt.isObj)(t) && (0, Vt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageViewSender";
}
je.isMessageViewSender = LL;
function kL(t) {
  return Bi.lexicons.validate("chat.bsky.convo.defs#messageViewSender", t);
}
je.validateMessageViewSender = kL;
function DL(t) {
  return (0, Vt.isObj)(t) && (0, Vt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#convoView";
}
je.isConvoView = DL;
function PL(t) {
  return Bi.lexicons.validate("chat.bsky.convo.defs#convoView", t);
}
je.validateConvoView = PL;
function BL(t) {
  return (0, Vt.isObj)(t) && (0, Vt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logBeginConvo";
}
je.isLogBeginConvo = BL;
function IL(t) {
  return Bi.lexicons.validate("chat.bsky.convo.defs#logBeginConvo", t);
}
je.validateLogBeginConvo = IL;
function UL(t) {
  return (0, Vt.isObj)(t) && (0, Vt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logLeaveConvo";
}
je.isLogLeaveConvo = UL;
function OL(t) {
  return Bi.lexicons.validate("chat.bsky.convo.defs#logLeaveConvo", t);
}
je.validateLogLeaveConvo = OL;
function KL(t) {
  return (0, Vt.isObj)(t) && (0, Vt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logCreateMessage";
}
je.isLogCreateMessage = KL;
function ML(t) {
  return Bi.lexicons.validate("chat.bsky.convo.defs#logCreateMessage", t);
}
je.validateLogCreateMessage = ML;
function NL(t) {
  return (0, Vt.isObj)(t) && (0, Vt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logDeleteMessage";
}
je.isLogDeleteMessage = NL;
function VL(t) {
  return Bi.lexicons.validate("chat.bsky.convo.defs#logDeleteMessage", t);
}
je.validateLogDeleteMessage = VL;
var La = {};
Object.defineProperty(La, "__esModule", { value: !0 });
La.validateTemplateView = La.isTemplateView = void 0;
const xd = ke, jL = Ie;
function FL(t) {
  return (0, xd.isObj)(t) && (0, xd.hasProp)(t, "$type") && t.$type === "tools.ozone.communication.defs#templateView";
}
La.isTemplateView = FL;
function $L(t) {
  return jL.lexicons.validate("tools.ozone.communication.defs#templateView", t);
}
La.validateTemplateView = $L;
var ne = {};
Object.defineProperty(ne, "__esModule", { value: !0 });
ne.validateRecordViewDetail = ne.isRecordViewDetail = ne.validateRecordView = ne.isRecordView = ne.validateRepoViewNotFound = ne.isRepoViewNotFound = ne.validateRepoViewDetail = ne.isRepoViewDetail = ne.validateRepoView = ne.isRepoView = ne.validateModEventTag = ne.isModEventTag = ne.validateModEventDivert = ne.isModEventDivert = ne.validateModEventEmail = ne.isModEventEmail = ne.validateModEventUnmuteReporter = ne.isModEventUnmuteReporter = ne.validateModEventMuteReporter = ne.isModEventMuteReporter = ne.validateModEventUnmute = ne.isModEventUnmute = ne.validateModEventMute = ne.isModEventMute = ne.validateModEventEscalate = ne.isModEventEscalate = ne.validateModEventAcknowledge = ne.isModEventAcknowledge = ne.validateModEventLabel = ne.isModEventLabel = ne.validateModEventReport = ne.isModEventReport = ne.validateModEventComment = ne.isModEventComment = ne.validateModEventResolveAppeal = ne.isModEventResolveAppeal = ne.validateModEventReverseTakedown = ne.isModEventReverseTakedown = ne.validateModEventTakedown = ne.isModEventTakedown = ne.REVIEWNONE = ne.REVIEWCLOSED = ne.REVIEWESCALATED = ne.REVIEWOPEN = ne.validateSubjectStatusView = ne.isSubjectStatusView = ne.validateModEventViewDetail = ne.isModEventViewDetail = ne.validateModEventView = ne.isModEventView = void 0;
ne.validateVideoDetails = ne.isVideoDetails = ne.validateImageDetails = ne.isImageDetails = ne.validateBlobView = ne.isBlobView = ne.validateModerationDetail = ne.isModerationDetail = ne.validateModeration = ne.isModeration = ne.validateRecordViewNotFound = ne.isRecordViewNotFound = void 0;
const Se = ke, lt = Ie;
function GL(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventView";
}
ne.isModEventView = GL;
function qL(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventView", t);
}
ne.validateModEventView = qL;
function XL(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventViewDetail";
}
ne.isModEventViewDetail = XL;
function zL(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventViewDetail", t);
}
ne.validateModEventViewDetail = zL;
function HL(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#subjectStatusView";
}
ne.isSubjectStatusView = HL;
function ZL(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#subjectStatusView", t);
}
ne.validateSubjectStatusView = ZL;
ne.REVIEWOPEN = "tools.ozone.moderation.defs#reviewOpen";
ne.REVIEWESCALATED = "tools.ozone.moderation.defs#reviewEscalated";
ne.REVIEWCLOSED = "tools.ozone.moderation.defs#reviewClosed";
ne.REVIEWNONE = "tools.ozone.moderation.defs#reviewNone";
function WL(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventTakedown";
}
ne.isModEventTakedown = WL;
function YL(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventTakedown", t);
}
ne.validateModEventTakedown = YL;
function JL(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventReverseTakedown";
}
ne.isModEventReverseTakedown = JL;
function QL(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventReverseTakedown", t);
}
ne.validateModEventReverseTakedown = QL;
function ek(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventResolveAppeal";
}
ne.isModEventResolveAppeal = ek;
function tk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventResolveAppeal", t);
}
ne.validateModEventResolveAppeal = tk;
function rk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventComment";
}
ne.isModEventComment = rk;
function ik(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventComment", t);
}
ne.validateModEventComment = ik;
function nk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventReport";
}
ne.isModEventReport = nk;
function ak(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventReport", t);
}
ne.validateModEventReport = ak;
function sk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventLabel";
}
ne.isModEventLabel = sk;
function ok(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventLabel", t);
}
ne.validateModEventLabel = ok;
function lk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventAcknowledge";
}
ne.isModEventAcknowledge = lk;
function uk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventAcknowledge", t);
}
ne.validateModEventAcknowledge = uk;
function ck(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventEscalate";
}
ne.isModEventEscalate = ck;
function dk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventEscalate", t);
}
ne.validateModEventEscalate = dk;
function fk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventMute";
}
ne.isModEventMute = fk;
function pk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventMute", t);
}
ne.validateModEventMute = pk;
function hk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventUnmute";
}
ne.isModEventUnmute = hk;
function mk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventUnmute", t);
}
ne.validateModEventUnmute = mk;
function yk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventMuteReporter";
}
ne.isModEventMuteReporter = yk;
function bk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventMuteReporter", t);
}
ne.validateModEventMuteReporter = bk;
function gk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventUnmuteReporter";
}
ne.isModEventUnmuteReporter = gk;
function xk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventUnmuteReporter", t);
}
ne.validateModEventUnmuteReporter = xk;
function Ek(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventEmail";
}
ne.isModEventEmail = Ek;
function vk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventEmail", t);
}
ne.validateModEventEmail = vk;
function Rk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventDivert";
}
ne.isModEventDivert = Rk;
function Ak(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventDivert", t);
}
ne.validateModEventDivert = Ak;
function _k(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventTag";
}
ne.isModEventTag = _k;
function wk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#modEventTag", t);
}
ne.validateModEventTag = wk;
function Tk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoView";
}
ne.isRepoView = Tk;
function Sk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#repoView", t);
}
ne.validateRepoView = Sk;
function Ck(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoViewDetail";
}
ne.isRepoViewDetail = Ck;
function Lk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#repoViewDetail", t);
}
ne.validateRepoViewDetail = Lk;
function kk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoViewNotFound";
}
ne.isRepoViewNotFound = kk;
function Dk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#repoViewNotFound", t);
}
ne.validateRepoViewNotFound = Dk;
function Pk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordView";
}
ne.isRecordView = Pk;
function Bk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#recordView", t);
}
ne.validateRecordView = Bk;
function Ik(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordViewDetail";
}
ne.isRecordViewDetail = Ik;
function Uk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#recordViewDetail", t);
}
ne.validateRecordViewDetail = Uk;
function Ok(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordViewNotFound";
}
ne.isRecordViewNotFound = Ok;
function Kk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#recordViewNotFound", t);
}
ne.validateRecordViewNotFound = Kk;
function Mk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#moderation";
}
ne.isModeration = Mk;
function Nk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#moderation", t);
}
ne.validateModeration = Nk;
function Vk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#moderationDetail";
}
ne.isModerationDetail = Vk;
function jk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#moderationDetail", t);
}
ne.validateModerationDetail = jk;
function Fk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#blobView";
}
ne.isBlobView = Fk;
function $k(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#blobView", t);
}
ne.validateBlobView = $k;
function Gk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#imageDetails";
}
ne.isImageDetails = Gk;
function qk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#imageDetails", t);
}
ne.validateImageDetails = qk;
function Xk(t) {
  return (0, Se.isObj)(t) && (0, Se.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#videoDetails";
}
ne.isVideoDetails = Xk;
function zk(t) {
  return lt.lexicons.validate("tools.ozone.moderation.defs#videoDetails", t);
}
ne.validateVideoDetails = zk;
var Gr = {};
Object.defineProperty(Gr, "__esModule", { value: !0 });
Gr.ROLETRIAGE = Gr.ROLEMODERATOR = Gr.ROLEADMIN = Gr.validateMember = Gr.isMember = void 0;
const Ed = ke, Hk = Ie;
function Zk(t) {
  return (0, Ed.isObj)(t) && (0, Ed.hasProp)(t, "$type") && t.$type === "tools.ozone.team.defs#member";
}
Gr.isMember = Zk;
function Wk(t) {
  return Hk.lexicons.validate("tools.ozone.team.defs#member", t);
}
Gr.validateMember = Wk;
Gr.ROLEADMIN = "tools.ozone.team.defs#roleAdmin";
Gr.ROLEMODERATOR = "tools.ozone.team.defs#roleModerator";
Gr.ROLETRIAGE = "tools.ozone.team.defs#roleTriage";
var Yk = de && de.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, u);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), Jk = de && de.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), S = de && de.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && Yk(e, t, r);
  return Jk(e, t), e;
};
Object.defineProperty(E, "__esModule", { value: !0 });
E.ComAtprotoServerDescribeServer = E.ComAtprotoServerDeleteSession = E.ComAtprotoServerDeleteAccount = E.ComAtprotoServerDefs = E.ComAtprotoServerDeactivateAccount = E.ComAtprotoServerCreateSession = E.ComAtprotoServerCreateInviteCodes = E.ComAtprotoServerCreateInviteCode = E.ComAtprotoServerCreateAppPassword = E.ComAtprotoServerCreateAccount = E.ComAtprotoServerConfirmEmail = E.ComAtprotoServerCheckAccountStatus = E.ComAtprotoServerActivateAccount = E.ComAtprotoRepoUploadBlob = E.ComAtprotoRepoStrongRef = E.ComAtprotoRepoPutRecord = E.ComAtprotoRepoListRecords = E.ComAtprotoRepoListMissingBlobs = E.ComAtprotoRepoImportRepo = E.ComAtprotoRepoGetRecord = E.ComAtprotoRepoDescribeRepo = E.ComAtprotoRepoDeleteRecord = E.ComAtprotoRepoCreateRecord = E.ComAtprotoRepoApplyWrites = E.ComAtprotoModerationDefs = E.ComAtprotoModerationCreateReport = E.ComAtprotoLabelSubscribeLabels = E.ComAtprotoLabelQueryLabels = E.ComAtprotoLabelDefs = E.ComAtprotoIdentityUpdateHandle = E.ComAtprotoIdentitySubmitPlcOperation = E.ComAtprotoIdentitySignPlcOperation = E.ComAtprotoIdentityResolveHandle = E.ComAtprotoIdentityRequestPlcOperationSignature = E.ComAtprotoIdentityGetRecommendedDidCredentials = E.ComAtprotoAdminUpdateSubjectStatus = E.ComAtprotoAdminUpdateAccountPassword = E.ComAtprotoAdminUpdateAccountHandle = E.ComAtprotoAdminUpdateAccountEmail = E.ComAtprotoAdminSendEmail = E.ComAtprotoAdminSearchAccounts = E.ComAtprotoAdminGetSubjectStatus = E.ComAtprotoAdminGetInviteCodes = E.ComAtprotoAdminGetAccountInfos = E.ComAtprotoAdminGetAccountInfo = E.ComAtprotoAdminEnableAccountInvites = E.ComAtprotoAdminDisableInviteCodes = E.ComAtprotoAdminDisableAccountInvites = E.ComAtprotoAdminDeleteAccount = E.ComAtprotoAdminDefs = void 0;
E.AppBskyFeedGetFeedGenerator = E.AppBskyFeedGetFeed = E.AppBskyFeedGetAuthorFeed = E.AppBskyFeedGetActorLikes = E.AppBskyFeedGetActorFeeds = E.AppBskyFeedGenerator = E.AppBskyFeedDescribeFeedGenerator = E.AppBskyFeedDefs = E.AppBskyEmbedRecordWithMedia = E.AppBskyEmbedRecord = E.AppBskyEmbedImages = E.AppBskyEmbedExternal = E.AppBskyActorSearchActorsTypeahead = E.AppBskyActorSearchActors = E.AppBskyActorPutPreferences = E.AppBskyActorProfile = E.AppBskyActorGetSuggestions = E.AppBskyActorGetProfiles = E.AppBskyActorGetProfile = E.AppBskyActorGetPreferences = E.AppBskyActorDefs = E.ComAtprotoTempRequestPhoneVerification = E.ComAtprotoTempFetchLabels = E.ComAtprotoTempCheckSignupQueue = E.ComAtprotoSyncSubscribeRepos = E.ComAtprotoSyncRequestCrawl = E.ComAtprotoSyncNotifyOfUpdate = E.ComAtprotoSyncListRepos = E.ComAtprotoSyncListBlobs = E.ComAtprotoSyncGetRepoStatus = E.ComAtprotoSyncGetRepo = E.ComAtprotoSyncGetRecord = E.ComAtprotoSyncGetLatestCommit = E.ComAtprotoSyncGetHead = E.ComAtprotoSyncGetCheckout = E.ComAtprotoSyncGetBlocks = E.ComAtprotoSyncGetBlob = E.ComAtprotoServerUpdateEmail = E.ComAtprotoServerRevokeAppPassword = E.ComAtprotoServerResetPassword = E.ComAtprotoServerReserveSigningKey = E.ComAtprotoServerRequestPasswordReset = E.ComAtprotoServerRequestEmailUpdate = E.ComAtprotoServerRequestEmailConfirmation = E.ComAtprotoServerRequestAccountDelete = E.ComAtprotoServerRefreshSession = E.ComAtprotoServerListAppPasswords = E.ComAtprotoServerGetSession = E.ComAtprotoServerGetServiceAuth = E.ComAtprotoServerGetAccountInviteCodes = void 0;
E.AppBskyNotificationUpdateSeen = E.AppBskyNotificationRegisterPush = E.AppBskyNotificationPutPreferences = E.AppBskyNotificationListNotifications = E.AppBskyNotificationGetUnreadCount = E.AppBskyLabelerService = E.AppBskyLabelerGetServices = E.AppBskyLabelerDefs = E.AppBskyGraphUnmuteThread = E.AppBskyGraphUnmuteActorList = E.AppBskyGraphUnmuteActor = E.AppBskyGraphStarterpack = E.AppBskyGraphMuteThread = E.AppBskyGraphMuteActorList = E.AppBskyGraphMuteActor = E.AppBskyGraphListitem = E.AppBskyGraphListblock = E.AppBskyGraphList = E.AppBskyGraphGetSuggestedFollowsByActor = E.AppBskyGraphGetStarterPacks = E.AppBskyGraphGetStarterPack = E.AppBskyGraphGetRelationships = E.AppBskyGraphGetMutes = E.AppBskyGraphGetLists = E.AppBskyGraphGetListMutes = E.AppBskyGraphGetListBlocks = E.AppBskyGraphGetList = E.AppBskyGraphGetKnownFollowers = E.AppBskyGraphGetFollows = E.AppBskyGraphGetFollowers = E.AppBskyGraphGetBlocks = E.AppBskyGraphGetActorStarterPacks = E.AppBskyGraphFollow = E.AppBskyGraphDefs = E.AppBskyGraphBlock = E.AppBskyFeedThreadgate = E.AppBskyFeedSendInteractions = E.AppBskyFeedSearchPosts = E.AppBskyFeedRepost = E.AppBskyFeedPost = E.AppBskyFeedLike = E.AppBskyFeedGetTimeline = E.AppBskyFeedGetSuggestedFeeds = E.AppBskyFeedGetRepostedBy = E.AppBskyFeedGetPosts = E.AppBskyFeedGetPostThread = E.AppBskyFeedGetListFeed = E.AppBskyFeedGetLikes = E.AppBskyFeedGetFeedSkeleton = E.AppBskyFeedGetFeedGenerators = void 0;
E.TOOLS_OZONE_MODERATION = E.APP_BSKY_GRAPH = E.APP_BSKY_FEED = E.COM_ATPROTO_MODERATION = E.ToolsOzoneTeamUpdateMember = E.ToolsOzoneTeamListMembers = E.ToolsOzoneTeamDeleteMember = E.ToolsOzoneTeamDefs = E.ToolsOzoneTeamAddMember = E.ToolsOzoneServerGetConfig = E.ToolsOzoneModerationSearchRepos = E.ToolsOzoneModerationQueryStatuses = E.ToolsOzoneModerationQueryEvents = E.ToolsOzoneModerationGetRepo = E.ToolsOzoneModerationGetRecord = E.ToolsOzoneModerationGetEvent = E.ToolsOzoneModerationEmitEvent = E.ToolsOzoneModerationDefs = E.ToolsOzoneCommunicationUpdateTemplate = E.ToolsOzoneCommunicationListTemplates = E.ToolsOzoneCommunicationDeleteTemplate = E.ToolsOzoneCommunicationDefs = E.ToolsOzoneCommunicationCreateTemplate = E.ChatBskyModerationUpdateActorAccess = E.ChatBskyModerationGetMessageContext = E.ChatBskyModerationGetActorMetadata = E.ChatBskyConvoUpdateRead = E.ChatBskyConvoUnmuteConvo = E.ChatBskyConvoSendMessageBatch = E.ChatBskyConvoSendMessage = E.ChatBskyConvoMuteConvo = E.ChatBskyConvoListConvos = E.ChatBskyConvoLeaveConvo = E.ChatBskyConvoGetMessages = E.ChatBskyConvoGetLog = E.ChatBskyConvoGetConvoForMembers = E.ChatBskyConvoGetConvo = E.ChatBskyConvoDeleteMessageForSelf = E.ChatBskyConvoDefs = E.ChatBskyActorExportAccountData = E.ChatBskyActorDeleteAccount = E.ChatBskyActorDefs = E.ChatBskyActorDeclaration = E.AppBskyUnspeccedSearchPostsSkeleton = E.AppBskyUnspeccedSearchActorsSkeleton = E.AppBskyUnspeccedGetTaggedSuggestions = E.AppBskyUnspeccedGetSuggestionsSkeleton = E.AppBskyUnspeccedGetPopularFeedGenerators = E.AppBskyUnspeccedDefs = E.AppBskyRichtextFacet = void 0;
E.ToolsOzoneTeamNS = E.ToolsOzoneServerNS = E.ToolsOzoneModerationNS = E.ToolsOzoneCommunicationNS = E.ToolsOzoneNS = E.ToolsNS = E.ChatBskyModerationNS = E.ChatBskyConvoNS = E.DeclarationRecord = E.ChatBskyActorNS = E.ChatBskyNS = E.ChatNS = E.AppBskyUnspeccedNS = E.AppBskyRichtextNS = E.AppBskyNotificationNS = E.ServiceRecord = E.AppBskyLabelerNS = E.StarterpackRecord = E.ListitemRecord = E.ListblockRecord = E.ListRecord = E.FollowRecord = E.BlockRecord = E.AppBskyGraphNS = E.ThreadgateRecord = E.RepostRecord = E.PostRecord = E.LikeRecord = E.GeneratorRecord = E.AppBskyFeedNS = E.AppBskyEmbedNS = E.ProfileRecord = E.AppBskyActorNS = E.AppBskyNS = E.AppNS = E.ComAtprotoTempNS = E.ComAtprotoSyncNS = E.ComAtprotoServerNS = E.ComAtprotoRepoNS = E.ComAtprotoModerationNS = E.ComAtprotoLabelNS = E.ComAtprotoIdentityNS = E.ComAtprotoAdminNS = E.ComAtprotoNS = E.ComNS = E.AtpServiceClient = E.AtpBaseClient = E.TOOLS_OZONE_TEAM = void 0;
const Qk = Z, eD = Ie, tD = S(as), rD = S(ss), iD = S(os), nD = S(ls), aD = S(us), sD = S(cs), oD = S(ds), lD = S(fs), uD = S(ps), cD = S(hs), dD = S(ms), fD = S(ys), pD = S(bs), hD = S(gs), mD = S(xs), yD = S(Es), bD = S(vs), gD = S(Rs), xD = S(As), ED = S(_s), vD = S(ws), RD = S(Ts), AD = S(jt), _D = S(Un), wD = S(On), TD = S(Ss), SD = S(Cs), CD = S(Ls), LD = S(Zi), kD = S(Wi), DD = S(Kn), PD = S(ks), BD = S(Ds), ID = S(Ps), UD = S(Pr), OD = S(Ft), KD = S(ri), MD = S(Is), ND = S(Yi), VD = S(Ji), jD = S(Us), FD = S(Qi), $D = S(Os), GD = S(Br), qD = S(Mn), XD = S(Nn), zD = S(Ks), HD = S(ii), ZD = S(Vn), WD = S(Ms), YD = S(Ns), JD = S(Vs), QD = S(js), eP = S(Fs), tP = S(en), rP = S($s), iP = S(ni), nP = S(xr), aP = S(Er), sP = S(Gs), oP = S(jn), lP = S(Ir), uP = S(vr), cP = S(Ur), dP = S(Fn), fP = S(Or), pP = S(tn), hP = S(Hs), mP = S(Zs), yP = S(Ws), bP = S(Ys), gP = S(Js), xP = S(Qs), EP = S(eo), vP = S(to), RP = S(ro), AP = S(io), _P = S(no), wP = S(ao), TP = S(Kr), SP = S(so), CP = S(rn), LP = S(nn), kP = S($n), DP = S(oo), PP = S(lo), BP = S(Gn), IP = S(an), UP = S(qn), OP = S(Xn), KP = S(uo), MP = S(co), NP = S(fo), VP = S(po), jP = S(zn), FP = S(ho), $P = S(mo), GP = S(yo), qP = S(bo), XP = S(go), zP = S(xo), HP = S(Eo), ZP = S(vo), WP = S(Ro), YP = S(Ao), JP = S(_o), QP = S(Hn), eB = S(wo), tB = S(To), rB = S(So), iB = S(Co), nB = S(Lo), aB = S(ko), sB = S(Do), oB = S(Po), lB = S(Bo), uB = S(Io), cB = S(Uo), dB = S(sn), fB = S(Oo), pB = S(Ko), hB = S(Mo), mB = S(No), yB = S(Vo), bB = S(on), gB = S(Zn), xB = S(Wn), EB = S(jo), vB = S(Fo), RB = S($o), AB = S(Go), _B = S(qo), wB = S(Xo), TB = S(zo), SB = S(Ho), CB = S(Zo), LB = S(Wo), kB = S(Yo), DB = S(ln), PB = S(Jo), BB = S(Qo), IB = S(un), UB = S(el), OB = S(tl), KB = S(rl), MB = S(il), NB = S(nl), VB = S(al), jB = S(Yn), FB = S(sl), $B = S(Jn), GB = S(Qn), qB = S(ol), XB = S(ll), zB = S(ul), HB = S(Mr), ZB = S(ea), WB = S(cn), YB = S(cl), JB = S(ta);
E.ComAtprotoAdminDefs = S(Wt);
E.ComAtprotoAdminDeleteAccount = S(as);
E.ComAtprotoAdminDisableAccountInvites = S(ss);
E.ComAtprotoAdminDisableInviteCodes = S(os);
E.ComAtprotoAdminEnableAccountInvites = S(ls);
E.ComAtprotoAdminGetAccountInfo = S(us);
E.ComAtprotoAdminGetAccountInfos = S(cs);
E.ComAtprotoAdminGetInviteCodes = S(ds);
E.ComAtprotoAdminGetSubjectStatus = S(fs);
E.ComAtprotoAdminSearchAccounts = S(ps);
E.ComAtprotoAdminSendEmail = S(hs);
E.ComAtprotoAdminUpdateAccountEmail = S(ms);
E.ComAtprotoAdminUpdateAccountHandle = S(ys);
E.ComAtprotoAdminUpdateAccountPassword = S(bs);
E.ComAtprotoAdminUpdateSubjectStatus = S(gs);
E.ComAtprotoIdentityGetRecommendedDidCredentials = S(xs);
E.ComAtprotoIdentityRequestPlcOperationSignature = S(Es);
E.ComAtprotoIdentityResolveHandle = S(vs);
E.ComAtprotoIdentitySignPlcOperation = S(Rs);
E.ComAtprotoIdentitySubmitPlcOperation = S(As);
E.ComAtprotoIdentityUpdateHandle = S(_s);
E.ComAtprotoLabelDefs = S(Dt);
E.ComAtprotoLabelQueryLabels = S(ws);
E.ComAtprotoLabelSubscribeLabels = S(bi);
E.ComAtprotoModerationCreateReport = S(Ts);
E.ComAtprotoModerationDefs = S(dr);
E.ComAtprotoRepoApplyWrites = S(jt);
E.ComAtprotoRepoCreateRecord = S(Un);
E.ComAtprotoRepoDeleteRecord = S(On);
E.ComAtprotoRepoDescribeRepo = S(Ss);
E.ComAtprotoRepoGetRecord = S(Cs);
E.ComAtprotoRepoImportRepo = S(Ls);
E.ComAtprotoRepoListMissingBlobs = S(Zi);
E.ComAtprotoRepoListRecords = S(Wi);
E.ComAtprotoRepoPutRecord = S(Kn);
E.ComAtprotoRepoStrongRef = S(ya);
E.ComAtprotoRepoUploadBlob = S(ks);
E.ComAtprotoServerActivateAccount = S(Ds);
E.ComAtprotoServerCheckAccountStatus = S(Ps);
E.ComAtprotoServerConfirmEmail = S(Pr);
E.ComAtprotoServerCreateAccount = S(Ft);
E.ComAtprotoServerCreateAppPassword = S(ri);
E.ComAtprotoServerCreateInviteCode = S(Is);
E.ComAtprotoServerCreateInviteCodes = S(Yi);
E.ComAtprotoServerCreateSession = S(Ji);
E.ComAtprotoServerDeactivateAccount = S(Us);
E.ComAtprotoServerDefs = S(gi);
E.ComAtprotoServerDeleteAccount = S(Qi);
E.ComAtprotoServerDeleteSession = S(Os);
E.ComAtprotoServerDescribeServer = S(Br);
E.ComAtprotoServerGetAccountInviteCodes = S(Mn);
E.ComAtprotoServerGetServiceAuth = S(Nn);
E.ComAtprotoServerGetSession = S(Ks);
E.ComAtprotoServerListAppPasswords = S(ii);
E.ComAtprotoServerRefreshSession = S(Vn);
E.ComAtprotoServerRequestAccountDelete = S(Ms);
E.ComAtprotoServerRequestEmailConfirmation = S(Ns);
E.ComAtprotoServerRequestEmailUpdate = S(Vs);
E.ComAtprotoServerRequestPasswordReset = S(js);
E.ComAtprotoServerReserveSigningKey = S(Fs);
E.ComAtprotoServerResetPassword = S(en);
E.ComAtprotoServerRevokeAppPassword = S($s);
E.ComAtprotoServerUpdateEmail = S(ni);
E.ComAtprotoSyncGetBlob = S(xr);
E.ComAtprotoSyncGetBlocks = S(Er);
E.ComAtprotoSyncGetCheckout = S(Gs);
E.ComAtprotoSyncGetHead = S(jn);
E.ComAtprotoSyncGetLatestCommit = S(Ir);
E.ComAtprotoSyncGetRecord = S(vr);
E.ComAtprotoSyncGetRepo = S(Ur);
E.ComAtprotoSyncGetRepoStatus = S(Fn);
E.ComAtprotoSyncListBlobs = S(Or);
E.ComAtprotoSyncListRepos = S(tn);
E.ComAtprotoSyncNotifyOfUpdate = S(Hs);
E.ComAtprotoSyncRequestCrawl = S(Zs);
E.ComAtprotoSyncSubscribeRepos = S(We);
E.ComAtprotoTempCheckSignupQueue = S(Ws);
E.ComAtprotoTempFetchLabels = S(Ys);
E.ComAtprotoTempRequestPhoneVerification = S(Js);
E.AppBskyActorDefs = S(pe);
E.AppBskyActorGetPreferences = S(Qs);
E.AppBskyActorGetProfile = S(eo);
E.AppBskyActorGetProfiles = S(to);
E.AppBskyActorGetSuggestions = S(ro);
E.AppBskyActorProfile = S(ba);
E.AppBskyActorPutPreferences = S(io);
E.AppBskyActorSearchActors = S(no);
E.AppBskyActorSearchActorsTypeahead = S(ao);
E.AppBskyEmbedExternal = S(Yt);
E.AppBskyEmbedImages = S(Pt);
E.AppBskyEmbedRecord = S(Bt);
E.AppBskyEmbedRecordWithMedia = S(xi);
E.AppBskyFeedDefs = S(be);
E.AppBskyFeedDescribeFeedGenerator = S(Kr);
E.AppBskyFeedGenerator = S(ga);
E.AppBskyFeedGetActorFeeds = S(so);
E.AppBskyFeedGetActorLikes = S(rn);
E.AppBskyFeedGetAuthorFeed = S(nn);
E.AppBskyFeedGetFeed = S($n);
E.AppBskyFeedGetFeedGenerator = S(oo);
E.AppBskyFeedGetFeedGenerators = S(lo);
E.AppBskyFeedGetFeedSkeleton = S(Gn);
E.AppBskyFeedGetLikes = S(an);
E.AppBskyFeedGetListFeed = S(qn);
E.AppBskyFeedGetPostThread = S(Xn);
E.AppBskyFeedGetPosts = S(uo);
E.AppBskyFeedGetRepostedBy = S(co);
E.AppBskyFeedGetSuggestedFeeds = S(fo);
E.AppBskyFeedGetTimeline = S(po);
E.AppBskyFeedLike = S(xa);
E.AppBskyFeedPost = S(Jt);
E.AppBskyFeedRepost = S(Ea);
E.AppBskyFeedSearchPosts = S(zn);
E.AppBskyFeedSendInteractions = S(ho);
E.AppBskyFeedThreadgate = S(Qt);
E.AppBskyGraphBlock = S(va);
E.AppBskyGraphDefs = S(Ge);
E.AppBskyGraphFollow = S(Ra);
E.AppBskyGraphGetActorStarterPacks = S(mo);
E.AppBskyGraphGetBlocks = S(yo);
E.AppBskyGraphGetFollowers = S(bo);
E.AppBskyGraphGetFollows = S(go);
E.AppBskyGraphGetKnownFollowers = S(xo);
E.AppBskyGraphGetList = S(Eo);
E.AppBskyGraphGetListBlocks = S(vo);
E.AppBskyGraphGetListMutes = S(Ro);
E.AppBskyGraphGetLists = S(Ao);
E.AppBskyGraphGetMutes = S(_o);
E.AppBskyGraphGetRelationships = S(Hn);
E.AppBskyGraphGetStarterPack = S(wo);
E.AppBskyGraphGetStarterPacks = S(To);
E.AppBskyGraphGetSuggestedFollowsByActor = S(So);
E.AppBskyGraphList = S(Aa);
E.AppBskyGraphListblock = S(_a);
E.AppBskyGraphListitem = S(wa);
E.AppBskyGraphMuteActor = S(Co);
E.AppBskyGraphMuteActorList = S(Lo);
E.AppBskyGraphMuteThread = S(ko);
E.AppBskyGraphStarterpack = S(Ei);
E.AppBskyGraphUnmuteActor = S(Do);
E.AppBskyGraphUnmuteActorList = S(Po);
E.AppBskyGraphUnmuteThread = S(Bo);
E.AppBskyLabelerDefs = S(er);
E.AppBskyLabelerGetServices = S(Io);
E.AppBskyLabelerService = S(Ta);
E.AppBskyNotificationGetUnreadCount = S(Uo);
E.AppBskyNotificationListNotifications = S(sn);
E.AppBskyNotificationPutPreferences = S(Oo);
E.AppBskyNotificationRegisterPush = S(Ko);
E.AppBskyNotificationUpdateSeen = S(Mo);
E.AppBskyRichtextFacet = S(It);
E.AppBskyUnspeccedDefs = S(vi);
E.AppBskyUnspeccedGetPopularFeedGenerators = S(No);
E.AppBskyUnspeccedGetSuggestionsSkeleton = S(Vo);
E.AppBskyUnspeccedGetTaggedSuggestions = S(on);
E.AppBskyUnspeccedSearchActorsSkeleton = S(Zn);
E.AppBskyUnspeccedSearchPostsSkeleton = S(Wn);
E.ChatBskyActorDeclaration = S(Sa);
E.ChatBskyActorDefs = S(Ca);
E.ChatBskyActorDeleteAccount = S(jo);
E.ChatBskyActorExportAccountData = S(Fo);
E.ChatBskyConvoDefs = S(je);
E.ChatBskyConvoDeleteMessageForSelf = S($o);
E.ChatBskyConvoGetConvo = S(Go);
E.ChatBskyConvoGetConvoForMembers = S(qo);
E.ChatBskyConvoGetLog = S(Xo);
E.ChatBskyConvoGetMessages = S(zo);
E.ChatBskyConvoLeaveConvo = S(Ho);
E.ChatBskyConvoListConvos = S(Zo);
E.ChatBskyConvoMuteConvo = S(Wo);
E.ChatBskyConvoSendMessage = S(Yo);
E.ChatBskyConvoSendMessageBatch = S(ln);
E.ChatBskyConvoUnmuteConvo = S(Jo);
E.ChatBskyConvoUpdateRead = S(Qo);
E.ChatBskyModerationGetActorMetadata = S(un);
E.ChatBskyModerationGetMessageContext = S(el);
E.ChatBskyModerationUpdateActorAccess = S(tl);
E.ToolsOzoneCommunicationCreateTemplate = S(rl);
E.ToolsOzoneCommunicationDefs = S(La);
E.ToolsOzoneCommunicationDeleteTemplate = S(il);
E.ToolsOzoneCommunicationListTemplates = S(nl);
E.ToolsOzoneCommunicationUpdateTemplate = S(al);
E.ToolsOzoneModerationDefs = S(ne);
E.ToolsOzoneModerationEmitEvent = S(Yn);
E.ToolsOzoneModerationGetEvent = S(sl);
E.ToolsOzoneModerationGetRecord = S(Jn);
E.ToolsOzoneModerationGetRepo = S(Qn);
E.ToolsOzoneModerationQueryEvents = S(ol);
E.ToolsOzoneModerationQueryStatuses = S(ll);
E.ToolsOzoneModerationSearchRepos = S(ul);
E.ToolsOzoneServerGetConfig = S(Mr);
E.ToolsOzoneTeamAddMember = S(ea);
E.ToolsOzoneTeamDefs = S(Gr);
E.ToolsOzoneTeamDeleteMember = S(cn);
E.ToolsOzoneTeamListMembers = S(cl);
E.ToolsOzoneTeamUpdateMember = S(ta);
E.COM_ATPROTO_MODERATION = {
  DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
  DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
  DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
  DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
  DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
  DefsReasonOther: "com.atproto.moderation.defs#reasonOther",
  DefsReasonAppeal: "com.atproto.moderation.defs#reasonAppeal"
};
E.APP_BSKY_FEED = {
  DefsRequestLess: "app.bsky.feed.defs#requestLess",
  DefsRequestMore: "app.bsky.feed.defs#requestMore",
  DefsClickthroughItem: "app.bsky.feed.defs#clickthroughItem",
  DefsClickthroughAuthor: "app.bsky.feed.defs#clickthroughAuthor",
  DefsClickthroughReposter: "app.bsky.feed.defs#clickthroughReposter",
  DefsClickthroughEmbed: "app.bsky.feed.defs#clickthroughEmbed",
  DefsInteractionSeen: "app.bsky.feed.defs#interactionSeen",
  DefsInteractionLike: "app.bsky.feed.defs#interactionLike",
  DefsInteractionRepost: "app.bsky.feed.defs#interactionRepost",
  DefsInteractionReply: "app.bsky.feed.defs#interactionReply",
  DefsInteractionQuote: "app.bsky.feed.defs#interactionQuote",
  DefsInteractionShare: "app.bsky.feed.defs#interactionShare"
};
E.APP_BSKY_GRAPH = {
  DefsModlist: "app.bsky.graph.defs#modlist",
  DefsCuratelist: "app.bsky.graph.defs#curatelist",
  DefsReferencelist: "app.bsky.graph.defs#referencelist"
};
E.TOOLS_OZONE_MODERATION = {
  DefsReviewOpen: "tools.ozone.moderation.defs#reviewOpen",
  DefsReviewEscalated: "tools.ozone.moderation.defs#reviewEscalated",
  DefsReviewClosed: "tools.ozone.moderation.defs#reviewClosed",
  DefsReviewNone: "tools.ozone.moderation.defs#reviewNone"
};
E.TOOLS_OZONE_TEAM = {
  DefsRoleAdmin: "tools.ozone.team.defs#roleAdmin",
  DefsRoleModerator: "tools.ozone.team.defs#roleModerator",
  DefsRoleTriage: "tools.ozone.team.defs#roleTriage"
};
class QB {
  constructor() {
    Object.defineProperty(this, "xrpc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Qk.Client()
    }), this.xrpc.addLexicons(eD.schemas);
  }
  service(e) {
    return new zh(this, this.xrpc.service(e));
  }
}
E.AtpBaseClient = QB;
class zh {
  constructor(e, r) {
    Object.defineProperty(this, "_baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "xrpc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "com", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "app", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tools", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._baseClient = e, this.xrpc = r, this.com = new Hh(this), this.app = new n0(this), this.chat = new S0(this), this.tools = new B0(this);
  }
  setHeader(e, r) {
    this.xrpc.setHeader(e, r);
  }
}
E.AtpServiceClient = zh;
class Hh {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "atproto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.atproto = new Zh(e);
  }
}
E.ComNS = Hh;
class Zh {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "admin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "identity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "label", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "server", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sync", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.admin = new Wh(e), this.identity = new Yh(e), this.label = new Jh(e), this.moderation = new Qh(e), this.repo = new e0(e), this.server = new t0(e), this.sync = new r0(e), this.temp = new i0(e);
  }
}
E.ComAtprotoNS = Zh;
class Wh {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("com.atproto.admin.deleteAccount", r?.qp, e, r).catch((n) => {
      throw tD.toKnownErr(n);
    });
  }
  disableAccountInvites(e, r) {
    return this._service.xrpc.call("com.atproto.admin.disableAccountInvites", r?.qp, e, r).catch((n) => {
      throw rD.toKnownErr(n);
    });
  }
  disableInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.admin.disableInviteCodes", r?.qp, e, r).catch((n) => {
      throw iD.toKnownErr(n);
    });
  }
  enableAccountInvites(e, r) {
    return this._service.xrpc.call("com.atproto.admin.enableAccountInvites", r?.qp, e, r).catch((n) => {
      throw nD.toKnownErr(n);
    });
  }
  getAccountInfo(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getAccountInfo", e, void 0, r).catch((n) => {
      throw aD.toKnownErr(n);
    });
  }
  getAccountInfos(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getAccountInfos", e, void 0, r).catch((n) => {
      throw sD.toKnownErr(n);
    });
  }
  getInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getInviteCodes", e, void 0, r).catch((n) => {
      throw oD.toKnownErr(n);
    });
  }
  getSubjectStatus(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getSubjectStatus", e, void 0, r).catch((n) => {
      throw lD.toKnownErr(n);
    });
  }
  searchAccounts(e, r) {
    return this._service.xrpc.call("com.atproto.admin.searchAccounts", e, void 0, r).catch((n) => {
      throw uD.toKnownErr(n);
    });
  }
  sendEmail(e, r) {
    return this._service.xrpc.call("com.atproto.admin.sendEmail", r?.qp, e, r).catch((n) => {
      throw cD.toKnownErr(n);
    });
  }
  updateAccountEmail(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountEmail", r?.qp, e, r).catch((n) => {
      throw dD.toKnownErr(n);
    });
  }
  updateAccountHandle(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountHandle", r?.qp, e, r).catch((n) => {
      throw fD.toKnownErr(n);
    });
  }
  updateAccountPassword(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountPassword", r?.qp, e, r).catch((n) => {
      throw pD.toKnownErr(n);
    });
  }
  updateSubjectStatus(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateSubjectStatus", r?.qp, e, r).catch((n) => {
      throw hD.toKnownErr(n);
    });
  }
}
E.ComAtprotoAdminNS = Wh;
class Yh {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getRecommendedDidCredentials(e, r) {
    return this._service.xrpc.call("com.atproto.identity.getRecommendedDidCredentials", e, void 0, r).catch((n) => {
      throw mD.toKnownErr(n);
    });
  }
  requestPlcOperationSignature(e, r) {
    return this._service.xrpc.call("com.atproto.identity.requestPlcOperationSignature", r?.qp, e, r).catch((n) => {
      throw yD.toKnownErr(n);
    });
  }
  resolveHandle(e, r) {
    return this._service.xrpc.call("com.atproto.identity.resolveHandle", e, void 0, r).catch((n) => {
      throw bD.toKnownErr(n);
    });
  }
  signPlcOperation(e, r) {
    return this._service.xrpc.call("com.atproto.identity.signPlcOperation", r?.qp, e, r).catch((n) => {
      throw gD.toKnownErr(n);
    });
  }
  submitPlcOperation(e, r) {
    return this._service.xrpc.call("com.atproto.identity.submitPlcOperation", r?.qp, e, r).catch((n) => {
      throw xD.toKnownErr(n);
    });
  }
  updateHandle(e, r) {
    return this._service.xrpc.call("com.atproto.identity.updateHandle", r?.qp, e, r).catch((n) => {
      throw ED.toKnownErr(n);
    });
  }
}
E.ComAtprotoIdentityNS = Yh;
class Jh {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  queryLabels(e, r) {
    return this._service.xrpc.call("com.atproto.label.queryLabels", e, void 0, r).catch((n) => {
      throw vD.toKnownErr(n);
    });
  }
}
E.ComAtprotoLabelNS = Jh;
class Qh {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  createReport(e, r) {
    return this._service.xrpc.call("com.atproto.moderation.createReport", r?.qp, e, r).catch((n) => {
      throw RD.toKnownErr(n);
    });
  }
}
E.ComAtprotoModerationNS = Qh;
class e0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  applyWrites(e, r) {
    return this._service.xrpc.call("com.atproto.repo.applyWrites", r?.qp, e, r).catch((n) => {
      throw AD.toKnownErr(n);
    });
  }
  createRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.createRecord", r?.qp, e, r).catch((n) => {
      throw _D.toKnownErr(n);
    });
  }
  deleteRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.deleteRecord", r?.qp, e, r).catch((n) => {
      throw wD.toKnownErr(n);
    });
  }
  describeRepo(e, r) {
    return this._service.xrpc.call("com.atproto.repo.describeRepo", e, void 0, r).catch((n) => {
      throw TD.toKnownErr(n);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.getRecord", e, void 0, r).catch((n) => {
      throw SD.toKnownErr(n);
    });
  }
  importRepo(e, r) {
    return this._service.xrpc.call("com.atproto.repo.importRepo", r?.qp, e, r).catch((n) => {
      throw CD.toKnownErr(n);
    });
  }
  listMissingBlobs(e, r) {
    return this._service.xrpc.call("com.atproto.repo.listMissingBlobs", e, void 0, r).catch((n) => {
      throw LD.toKnownErr(n);
    });
  }
  listRecords(e, r) {
    return this._service.xrpc.call("com.atproto.repo.listRecords", e, void 0, r).catch((n) => {
      throw kD.toKnownErr(n);
    });
  }
  putRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.putRecord", r?.qp, e, r).catch((n) => {
      throw DD.toKnownErr(n);
    });
  }
  uploadBlob(e, r) {
    return this._service.xrpc.call("com.atproto.repo.uploadBlob", r?.qp, e, r).catch((n) => {
      throw PD.toKnownErr(n);
    });
  }
}
E.ComAtprotoRepoNS = e0;
class t0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  activateAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.activateAccount", r?.qp, e, r).catch((n) => {
      throw BD.toKnownErr(n);
    });
  }
  checkAccountStatus(e, r) {
    return this._service.xrpc.call("com.atproto.server.checkAccountStatus", e, void 0, r).catch((n) => {
      throw ID.toKnownErr(n);
    });
  }
  confirmEmail(e, r) {
    return this._service.xrpc.call("com.atproto.server.confirmEmail", r?.qp, e, r).catch((n) => {
      throw UD.toKnownErr(n);
    });
  }
  createAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.createAccount", r?.qp, e, r).catch((n) => {
      throw OD.toKnownErr(n);
    });
  }
  createAppPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.createAppPassword", r?.qp, e, r).catch((n) => {
      throw KD.toKnownErr(n);
    });
  }
  createInviteCode(e, r) {
    return this._service.xrpc.call("com.atproto.server.createInviteCode", r?.qp, e, r).catch((n) => {
      throw MD.toKnownErr(n);
    });
  }
  createInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.server.createInviteCodes", r?.qp, e, r).catch((n) => {
      throw ND.toKnownErr(n);
    });
  }
  createSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.createSession", r?.qp, e, r).catch((n) => {
      throw VD.toKnownErr(n);
    });
  }
  deactivateAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.deactivateAccount", r?.qp, e, r).catch((n) => {
      throw jD.toKnownErr(n);
    });
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.deleteAccount", r?.qp, e, r).catch((n) => {
      throw FD.toKnownErr(n);
    });
  }
  deleteSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.deleteSession", r?.qp, e, r).catch((n) => {
      throw $D.toKnownErr(n);
    });
  }
  describeServer(e, r) {
    return this._service.xrpc.call("com.atproto.server.describeServer", e, void 0, r).catch((n) => {
      throw GD.toKnownErr(n);
    });
  }
  getAccountInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.server.getAccountInviteCodes", e, void 0, r).catch((n) => {
      throw qD.toKnownErr(n);
    });
  }
  getServiceAuth(e, r) {
    return this._service.xrpc.call("com.atproto.server.getServiceAuth", e, void 0, r).catch((n) => {
      throw XD.toKnownErr(n);
    });
  }
  getSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.getSession", e, void 0, r).catch((n) => {
      throw zD.toKnownErr(n);
    });
  }
  listAppPasswords(e, r) {
    return this._service.xrpc.call("com.atproto.server.listAppPasswords", e, void 0, r).catch((n) => {
      throw HD.toKnownErr(n);
    });
  }
  refreshSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.refreshSession", r?.qp, e, r).catch((n) => {
      throw ZD.toKnownErr(n);
    });
  }
  requestAccountDelete(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestAccountDelete", r?.qp, e, r).catch((n) => {
      throw WD.toKnownErr(n);
    });
  }
  requestEmailConfirmation(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestEmailConfirmation", r?.qp, e, r).catch((n) => {
      throw YD.toKnownErr(n);
    });
  }
  requestEmailUpdate(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestEmailUpdate", r?.qp, e, r).catch((n) => {
      throw JD.toKnownErr(n);
    });
  }
  requestPasswordReset(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestPasswordReset", r?.qp, e, r).catch((n) => {
      throw QD.toKnownErr(n);
    });
  }
  reserveSigningKey(e, r) {
    return this._service.xrpc.call("com.atproto.server.reserveSigningKey", r?.qp, e, r).catch((n) => {
      throw eP.toKnownErr(n);
    });
  }
  resetPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.resetPassword", r?.qp, e, r).catch((n) => {
      throw tP.toKnownErr(n);
    });
  }
  revokeAppPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.revokeAppPassword", r?.qp, e, r).catch((n) => {
      throw rP.toKnownErr(n);
    });
  }
  updateEmail(e, r) {
    return this._service.xrpc.call("com.atproto.server.updateEmail", r?.qp, e, r).catch((n) => {
      throw iP.toKnownErr(n);
    });
  }
}
E.ComAtprotoServerNS = t0;
class r0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getBlob(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getBlob", e, void 0, r).catch((n) => {
      throw nP.toKnownErr(n);
    });
  }
  getBlocks(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getBlocks", e, void 0, r).catch((n) => {
      throw aP.toKnownErr(n);
    });
  }
  getCheckout(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getCheckout", e, void 0, r).catch((n) => {
      throw sP.toKnownErr(n);
    });
  }
  getHead(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getHead", e, void 0, r).catch((n) => {
      throw oP.toKnownErr(n);
    });
  }
  getLatestCommit(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getLatestCommit", e, void 0, r).catch((n) => {
      throw lP.toKnownErr(n);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRecord", e, void 0, r).catch((n) => {
      throw uP.toKnownErr(n);
    });
  }
  getRepo(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRepo", e, void 0, r).catch((n) => {
      throw cP.toKnownErr(n);
    });
  }
  getRepoStatus(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRepoStatus", e, void 0, r).catch((n) => {
      throw dP.toKnownErr(n);
    });
  }
  listBlobs(e, r) {
    return this._service.xrpc.call("com.atproto.sync.listBlobs", e, void 0, r).catch((n) => {
      throw fP.toKnownErr(n);
    });
  }
  listRepos(e, r) {
    return this._service.xrpc.call("com.atproto.sync.listRepos", e, void 0, r).catch((n) => {
      throw pP.toKnownErr(n);
    });
  }
  notifyOfUpdate(e, r) {
    return this._service.xrpc.call("com.atproto.sync.notifyOfUpdate", r?.qp, e, r).catch((n) => {
      throw hP.toKnownErr(n);
    });
  }
  requestCrawl(e, r) {
    return this._service.xrpc.call("com.atproto.sync.requestCrawl", r?.qp, e, r).catch((n) => {
      throw mP.toKnownErr(n);
    });
  }
}
E.ComAtprotoSyncNS = r0;
class i0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  checkSignupQueue(e, r) {
    return this._service.xrpc.call("com.atproto.temp.checkSignupQueue", e, void 0, r).catch((n) => {
      throw yP.toKnownErr(n);
    });
  }
  fetchLabels(e, r) {
    return this._service.xrpc.call("com.atproto.temp.fetchLabels", e, void 0, r).catch((n) => {
      throw bP.toKnownErr(n);
    });
  }
  requestPhoneVerification(e, r) {
    return this._service.xrpc.call("com.atproto.temp.requestPhoneVerification", r?.qp, e, r).catch((n) => {
      throw gP.toKnownErr(n);
    });
  }
}
E.ComAtprotoTempNS = i0;
class n0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bsky", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.bsky = new a0(e);
  }
}
E.AppNS = n0;
class a0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "actor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "embed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "feed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "graph", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labeler", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "notification", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "richtext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "unspecced", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.actor = new s0(e), this.embed = new l0(e), this.feed = new u0(e), this.graph = new m0(e), this.labeler = new R0(e), this.notification = new _0(e), this.richtext = new w0(e), this.unspecced = new T0(e);
  }
}
E.AppBskyNS = a0;
class s0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "profile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.profile = new o0(e);
  }
  getPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getPreferences", e, void 0, r).catch((n) => {
      throw xP.toKnownErr(n);
    });
  }
  getProfile(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getProfile", e, void 0, r).catch((n) => {
      throw EP.toKnownErr(n);
    });
  }
  getProfiles(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getProfiles", e, void 0, r).catch((n) => {
      throw vP.toKnownErr(n);
    });
  }
  getSuggestions(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getSuggestions", e, void 0, r).catch((n) => {
      throw RP.toKnownErr(n);
    });
  }
  putPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.actor.putPreferences", r?.qp, e, r).catch((n) => {
      throw AP.toKnownErr(n);
    });
  }
  searchActors(e, r) {
    return this._service.xrpc.call("app.bsky.actor.searchActors", e, void 0, r).catch((n) => {
      throw _P.toKnownErr(n);
    });
  }
  searchActorsTypeahead(e, r) {
    return this._service.xrpc.call("app.bsky.actor.searchActorsTypeahead", e, void 0, r).catch((n) => {
      throw wP.toKnownErr(n);
    });
  }
}
E.AppBskyActorNS = s0;
class o0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.actor.profile",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.actor.profile",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.actor.profile", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.actor.profile", rkey: "self", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.actor.profile", ...e }, { headers: r });
  }
}
E.ProfileRecord = o0;
class l0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
}
E.AppBskyEmbedNS = l0;
class u0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "generator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "like", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "post", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "threadgate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.generator = new c0(e), this.like = new d0(e), this.post = new f0(e), this.repost = new p0(e), this.threadgate = new h0(e);
  }
  describeFeedGenerator(e, r) {
    return this._service.xrpc.call("app.bsky.feed.describeFeedGenerator", e, void 0, r).catch((n) => {
      throw TP.toKnownErr(n);
    });
  }
  getActorFeeds(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getActorFeeds", e, void 0, r).catch((n) => {
      throw SP.toKnownErr(n);
    });
  }
  getActorLikes(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getActorLikes", e, void 0, r).catch((n) => {
      throw CP.toKnownErr(n);
    });
  }
  getAuthorFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getAuthorFeed", e, void 0, r).catch((n) => {
      throw LP.toKnownErr(n);
    });
  }
  getFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeed", e, void 0, r).catch((n) => {
      throw kP.toKnownErr(n);
    });
  }
  getFeedGenerator(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedGenerator", e, void 0, r).catch((n) => {
      throw DP.toKnownErr(n);
    });
  }
  getFeedGenerators(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedGenerators", e, void 0, r).catch((n) => {
      throw PP.toKnownErr(n);
    });
  }
  getFeedSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedSkeleton", e, void 0, r).catch((n) => {
      throw BP.toKnownErr(n);
    });
  }
  getLikes(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getLikes", e, void 0, r).catch((n) => {
      throw IP.toKnownErr(n);
    });
  }
  getListFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getListFeed", e, void 0, r).catch((n) => {
      throw UP.toKnownErr(n);
    });
  }
  getPostThread(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getPostThread", e, void 0, r).catch((n) => {
      throw OP.toKnownErr(n);
    });
  }
  getPosts(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getPosts", e, void 0, r).catch((n) => {
      throw KP.toKnownErr(n);
    });
  }
  getRepostedBy(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getRepostedBy", e, void 0, r).catch((n) => {
      throw MP.toKnownErr(n);
    });
  }
  getSuggestedFeeds(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getSuggestedFeeds", e, void 0, r).catch((n) => {
      throw NP.toKnownErr(n);
    });
  }
  getTimeline(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getTimeline", e, void 0, r).catch((n) => {
      throw VP.toKnownErr(n);
    });
  }
  searchPosts(e, r) {
    return this._service.xrpc.call("app.bsky.feed.searchPosts", e, void 0, r).catch((n) => {
      throw jP.toKnownErr(n);
    });
  }
  sendInteractions(e, r) {
    return this._service.xrpc.call("app.bsky.feed.sendInteractions", r?.qp, e, r).catch((n) => {
      throw FP.toKnownErr(n);
    });
  }
}
E.AppBskyFeedNS = u0;
class c0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.generator",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.generator",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.feed.generator", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.generator", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.generator", ...e }, { headers: r });
  }
}
E.GeneratorRecord = c0;
class d0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.like",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.like",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.feed.like", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.like", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.like", ...e }, { headers: r });
  }
}
E.LikeRecord = d0;
class f0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.post",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.post",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.feed.post", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.post", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.post", ...e }, { headers: r });
  }
}
E.PostRecord = f0;
class p0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.repost",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.repost",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.feed.repost", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.repost", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.repost", ...e }, { headers: r });
  }
}
E.RepostRecord = p0;
class h0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.threadgate",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.threadgate",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.feed.threadgate", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.threadgate", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.threadgate", ...e }, { headers: r });
  }
}
E.ThreadgateRecord = h0;
class m0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "block", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "follow", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "list", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "listblock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "listitem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "starterpack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.block = new y0(e), this.follow = new b0(e), this.list = new g0(e), this.listblock = new x0(e), this.listitem = new E0(e), this.starterpack = new v0(e);
  }
  getActorStarterPacks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getActorStarterPacks", e, void 0, r).catch((n) => {
      throw $P.toKnownErr(n);
    });
  }
  getBlocks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getBlocks", e, void 0, r).catch((n) => {
      throw GP.toKnownErr(n);
    });
  }
  getFollowers(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getFollowers", e, void 0, r).catch((n) => {
      throw qP.toKnownErr(n);
    });
  }
  getFollows(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getFollows", e, void 0, r).catch((n) => {
      throw XP.toKnownErr(n);
    });
  }
  getKnownFollowers(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getKnownFollowers", e, void 0, r).catch((n) => {
      throw zP.toKnownErr(n);
    });
  }
  getList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getList", e, void 0, r).catch((n) => {
      throw HP.toKnownErr(n);
    });
  }
  getListBlocks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getListBlocks", e, void 0, r).catch((n) => {
      throw ZP.toKnownErr(n);
    });
  }
  getListMutes(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getListMutes", e, void 0, r).catch((n) => {
      throw WP.toKnownErr(n);
    });
  }
  getLists(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getLists", e, void 0, r).catch((n) => {
      throw YP.toKnownErr(n);
    });
  }
  getMutes(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getMutes", e, void 0, r).catch((n) => {
      throw JP.toKnownErr(n);
    });
  }
  getRelationships(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getRelationships", e, void 0, r).catch((n) => {
      throw QP.toKnownErr(n);
    });
  }
  getStarterPack(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getStarterPack", e, void 0, r).catch((n) => {
      throw eB.toKnownErr(n);
    });
  }
  getStarterPacks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getStarterPacks", e, void 0, r).catch((n) => {
      throw tB.toKnownErr(n);
    });
  }
  getSuggestedFollowsByActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getSuggestedFollowsByActor", e, void 0, r).catch((n) => {
      throw rB.toKnownErr(n);
    });
  }
  muteActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteActor", r?.qp, e, r).catch((n) => {
      throw iB.toKnownErr(n);
    });
  }
  muteActorList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteActorList", r?.qp, e, r).catch((n) => {
      throw nB.toKnownErr(n);
    });
  }
  muteThread(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteThread", r?.qp, e, r).catch((n) => {
      throw aB.toKnownErr(n);
    });
  }
  unmuteActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteActor", r?.qp, e, r).catch((n) => {
      throw sB.toKnownErr(n);
    });
  }
  unmuteActorList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteActorList", r?.qp, e, r).catch((n) => {
      throw oB.toKnownErr(n);
    });
  }
  unmuteThread(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteThread", r?.qp, e, r).catch((n) => {
      throw lB.toKnownErr(n);
    });
  }
}
E.AppBskyGraphNS = m0;
class y0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.block",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.block",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.block", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.block", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.block", ...e }, { headers: r });
  }
}
E.BlockRecord = y0;
class b0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.follow",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.follow",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.follow", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.follow", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.follow", ...e }, { headers: r });
  }
}
E.FollowRecord = b0;
class g0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.list",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.list",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.list", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.list", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.list", ...e }, { headers: r });
  }
}
E.ListRecord = g0;
class x0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.listblock",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.listblock",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.listblock", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listblock", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listblock", ...e }, { headers: r });
  }
}
E.ListblockRecord = x0;
class E0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.listitem",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.listitem",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.listitem", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listitem", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listitem", ...e }, { headers: r });
  }
}
E.ListitemRecord = E0;
class v0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.starterpack",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.starterpack",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.starterpack", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.starterpack", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.starterpack", ...e }, { headers: r });
  }
}
E.StarterpackRecord = v0;
class R0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.service = new A0(e);
  }
  getServices(e, r) {
    return this._service.xrpc.call("app.bsky.labeler.getServices", e, void 0, r).catch((n) => {
      throw uB.toKnownErr(n);
    });
  }
}
E.AppBskyLabelerNS = R0;
class A0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.labeler.service",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.labeler.service",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.labeler.service", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, {
      collection: "app.bsky.labeler.service",
      rkey: "self",
      ...e,
      record: r
    }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.labeler.service", ...e }, { headers: r });
  }
}
E.ServiceRecord = A0;
class _0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getUnreadCount(e, r) {
    return this._service.xrpc.call("app.bsky.notification.getUnreadCount", e, void 0, r).catch((n) => {
      throw cB.toKnownErr(n);
    });
  }
  listNotifications(e, r) {
    return this._service.xrpc.call("app.bsky.notification.listNotifications", e, void 0, r).catch((n) => {
      throw dB.toKnownErr(n);
    });
  }
  putPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.notification.putPreferences", r?.qp, e, r).catch((n) => {
      throw fB.toKnownErr(n);
    });
  }
  registerPush(e, r) {
    return this._service.xrpc.call("app.bsky.notification.registerPush", r?.qp, e, r).catch((n) => {
      throw pB.toKnownErr(n);
    });
  }
  updateSeen(e, r) {
    return this._service.xrpc.call("app.bsky.notification.updateSeen", r?.qp, e, r).catch((n) => {
      throw hB.toKnownErr(n);
    });
  }
}
E.AppBskyNotificationNS = _0;
class w0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
}
E.AppBskyRichtextNS = w0;
class T0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getPopularFeedGenerators(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getPopularFeedGenerators", e, void 0, r).catch((n) => {
      throw mB.toKnownErr(n);
    });
  }
  getSuggestionsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getSuggestionsSkeleton", e, void 0, r).catch((n) => {
      throw yB.toKnownErr(n);
    });
  }
  getTaggedSuggestions(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getTaggedSuggestions", e, void 0, r).catch((n) => {
      throw bB.toKnownErr(n);
    });
  }
  searchActorsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.searchActorsSkeleton", e, void 0, r).catch((n) => {
      throw gB.toKnownErr(n);
    });
  }
  searchPostsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.searchPostsSkeleton", e, void 0, r).catch((n) => {
      throw xB.toKnownErr(n);
    });
  }
}
E.AppBskyUnspeccedNS = T0;
class S0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bsky", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.bsky = new C0(e);
  }
}
E.ChatNS = S0;
class C0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "actor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "convo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.actor = new L0(e), this.convo = new D0(e), this.moderation = new P0(e);
  }
}
E.ChatBskyNS = C0;
class L0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "declaration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.declaration = new k0(e);
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("chat.bsky.actor.deleteAccount", r?.qp, e, r).catch((n) => {
      throw EB.toKnownErr(n);
    });
  }
  exportAccountData(e, r) {
    return this._service.xrpc.call("chat.bsky.actor.exportAccountData", e, void 0, r).catch((n) => {
      throw vB.toKnownErr(n);
    });
  }
}
E.ChatBskyActorNS = L0;
class k0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "chat.bsky.actor.declaration",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "chat.bsky.actor.declaration",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "chat.bsky.actor.declaration", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, {
      collection: "chat.bsky.actor.declaration",
      rkey: "self",
      ...e,
      record: r
    }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "chat.bsky.actor.declaration", ...e }, { headers: r });
  }
}
E.DeclarationRecord = k0;
class D0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  deleteMessageForSelf(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.deleteMessageForSelf", r?.qp, e, r).catch((n) => {
      throw RB.toKnownErr(n);
    });
  }
  getConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getConvo", e, void 0, r).catch((n) => {
      throw AB.toKnownErr(n);
    });
  }
  getConvoForMembers(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getConvoForMembers", e, void 0, r).catch((n) => {
      throw _B.toKnownErr(n);
    });
  }
  getLog(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getLog", e, void 0, r).catch((n) => {
      throw wB.toKnownErr(n);
    });
  }
  getMessages(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getMessages", e, void 0, r).catch((n) => {
      throw TB.toKnownErr(n);
    });
  }
  leaveConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.leaveConvo", r?.qp, e, r).catch((n) => {
      throw SB.toKnownErr(n);
    });
  }
  listConvos(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.listConvos", e, void 0, r).catch((n) => {
      throw CB.toKnownErr(n);
    });
  }
  muteConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.muteConvo", r?.qp, e, r).catch((n) => {
      throw LB.toKnownErr(n);
    });
  }
  sendMessage(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.sendMessage", r?.qp, e, r).catch((n) => {
      throw kB.toKnownErr(n);
    });
  }
  sendMessageBatch(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.sendMessageBatch", r?.qp, e, r).catch((n) => {
      throw DB.toKnownErr(n);
    });
  }
  unmuteConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.unmuteConvo", r?.qp, e, r).catch((n) => {
      throw PB.toKnownErr(n);
    });
  }
  updateRead(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.updateRead", r?.qp, e, r).catch((n) => {
      throw BB.toKnownErr(n);
    });
  }
}
E.ChatBskyConvoNS = D0;
class P0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getActorMetadata(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.getActorMetadata", e, void 0, r).catch((n) => {
      throw IB.toKnownErr(n);
    });
  }
  getMessageContext(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.getMessageContext", e, void 0, r).catch((n) => {
      throw UB.toKnownErr(n);
    });
  }
  updateActorAccess(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.updateActorAccess", r?.qp, e, r).catch((n) => {
      throw OB.toKnownErr(n);
    });
  }
}
E.ChatBskyModerationNS = P0;
class B0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ozone", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.ozone = new I0(e);
  }
}
E.ToolsNS = B0;
class I0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "communication", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "server", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "team", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.communication = new U0(e), this.moderation = new O0(e), this.server = new K0(e), this.team = new M0(e);
  }
}
E.ToolsOzoneNS = I0;
class U0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  createTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.createTemplate", r?.qp, e, r).catch((n) => {
      throw KB.toKnownErr(n);
    });
  }
  deleteTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.deleteTemplate", r?.qp, e, r).catch((n) => {
      throw MB.toKnownErr(n);
    });
  }
  listTemplates(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.listTemplates", e, void 0, r).catch((n) => {
      throw NB.toKnownErr(n);
    });
  }
  updateTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.updateTemplate", r?.qp, e, r).catch((n) => {
      throw VB.toKnownErr(n);
    });
  }
}
E.ToolsOzoneCommunicationNS = U0;
class O0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  emitEvent(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.emitEvent", r?.qp, e, r).catch((n) => {
      throw jB.toKnownErr(n);
    });
  }
  getEvent(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getEvent", e, void 0, r).catch((n) => {
      throw FB.toKnownErr(n);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getRecord", e, void 0, r).catch((n) => {
      throw $B.toKnownErr(n);
    });
  }
  getRepo(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getRepo", e, void 0, r).catch((n) => {
      throw GB.toKnownErr(n);
    });
  }
  queryEvents(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.queryEvents", e, void 0, r).catch((n) => {
      throw qB.toKnownErr(n);
    });
  }
  queryStatuses(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.queryStatuses", e, void 0, r).catch((n) => {
      throw XB.toKnownErr(n);
    });
  }
  searchRepos(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.searchRepos", e, void 0, r).catch((n) => {
      throw zB.toKnownErr(n);
    });
  }
}
E.ToolsOzoneModerationNS = O0;
class K0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getConfig(e, r) {
    return this._service.xrpc.call("tools.ozone.server.getConfig", e, void 0, r).catch((n) => {
      throw HB.toKnownErr(n);
    });
  }
}
E.ToolsOzoneServerNS = K0;
class M0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  addMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.addMember", r?.qp, e, r).catch((n) => {
      throw ZB.toKnownErr(n);
    });
  }
  deleteMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.deleteMember", r?.qp, e, r).catch((n) => {
      throw WB.toKnownErr(n);
    });
  }
  listMembers(e, r) {
    return this._service.xrpc.call("tools.ozone.team.listMembers", e, void 0, r).catch((n) => {
      throw YB.toKnownErr(n);
    });
  }
  updateMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.updateMember", r?.qp, e, r).catch((n) => {
      throw JB.toKnownErr(n);
    });
  }
}
E.ToolsOzoneTeamNS = M0;
var ka = {};
Object.defineProperty(ka, "__esModule", { value: !0 });
ka.AtpAgent = void 0;
const eI = Z, kl = Z, vd = Pi, tI = E, rI = ns, iI = "com.atproto.server.refreshSession";
class Dr {
  get com() {
    return this.api.com;
  }
  /**
   * Configures the API globally.
   */
  static configure(e) {
    e.fetch && (Dr.fetch = e.fetch), e.appLabelers && (Dr.appLabelers = e.appLabelers);
  }
  constructor(e) {
    Object.defineProperty(this, "service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "api", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "session", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labelersHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "proxyHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pdsUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_persistSession", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_refreshSessionPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uploadBlob", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, n) => this.api.com.atproto.repo.uploadBlob(r, n)
    }), Object.defineProperty(this, "resolveHandle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, n) => this.api.com.atproto.identity.resolveHandle(r, n)
    }), Object.defineProperty(this, "updateHandle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, n) => this.api.com.atproto.identity.updateHandle(r, n)
    }), Object.defineProperty(this, "createModerationReport", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, n) => this.api.com.atproto.moderation.createReport(r, n)
    }), this.service = e.service instanceof URL ? e.service : new URL(e.service), this._persistSession = e.persistSession, this._baseClient = new tI.AtpBaseClient(), this._baseClient.xrpc.fetch = this._fetch.bind(this), this.api = this._baseClient.service(e.service);
  }
  clone() {
    const e = new Dr({
      service: this.service
    });
    return this.copyInto(e), e;
  }
  copyInto(e) {
    e.session = this.session, e.labelersHeader = this.labelersHeader, e.proxyHeader = this.proxyHeader, e.pdsUrl = this.pdsUrl, e.api.xrpc.uri = this.pdsUrl || this.service;
  }
  withProxy(e, r) {
    const n = this.clone();
    return n.configureProxyHeader(e, r), n;
  }
  /**
   * Is there any active session?
   */
  get hasSession() {
    return !!this.session;
  }
  /**
   * Sets the "Persist Session" method which can be used to store access tokens
   * as they change.
   */
  setPersistSessionHandler(e) {
    this._persistSession = e;
  }
  /**
   * Configures the moderation services to be applied on requests.
   * NOTE: this is called automatically by getPreferences() and the relevant moderation config
   * methods in BskyAgent instances.
   */
  configureLabelersHeader(e) {
    this.labelersHeader = e;
  }
  /**
   * Configures the atproto-proxy header to be applied on requests
   */
  configureProxyHeader(e, r) {
    r.startsWith("did:") && (this.proxyHeader = `${r}#${e}`);
  }
  /**
   * Create a new account and hydrate its session in this agent.
   */
  async createAccount(e) {
    try {
      const r = await this.api.com.atproto.server.createAccount(e);
      return this.session = {
        accessJwt: r.data.accessJwt,
        refreshJwt: r.data.refreshJwt,
        handle: r.data.handle,
        did: r.data.did,
        email: e.email,
        emailConfirmed: !1,
        emailAuthFactor: !1,
        active: !0
      }, this._updateApiEndpoint(r.data.didDoc), r;
    } catch (r) {
      throw this.session = void 0, r;
    } finally {
      this.session ? this._persistSession?.("create", this.session) : this._persistSession?.("create-failed", void 0);
    }
  }
  /**
   * Start a new session with this agent.
   */
  async login(e) {
    try {
      const r = await this.api.com.atproto.server.createSession({
        identifier: e.identifier,
        password: e.password,
        authFactorToken: e.authFactorToken
      });
      return this.session = {
        accessJwt: r.data.accessJwt,
        refreshJwt: r.data.refreshJwt,
        handle: r.data.handle,
        did: r.data.did,
        email: r.data.email,
        emailConfirmed: r.data.emailConfirmed,
        emailAuthFactor: r.data.emailAuthFactor,
        active: r.data.active ?? !0,
        status: r.data.status
      }, this._updateApiEndpoint(r.data.didDoc), r;
    } catch (r) {
      throw this.session = void 0, r;
    } finally {
      this.session ? this._persistSession?.("create", this.session) : this._persistSession?.("create-failed", void 0);
    }
  }
  /**
   * Resume a pre-existing session with this agent.
   */
  async resumeSession(e) {
    try {
      this.session = e;
      const r = await this.api.com.atproto.server.getSession();
      if (r.data.did !== this.session.did)
        throw new kl.XRPCError(kl.ResponseType.InvalidRequest, "Invalid session", "InvalidDID");
      return this.session.email = r.data.email, this.session.handle = r.data.handle, this.session.emailConfirmed = r.data.emailConfirmed, this.session.emailAuthFactor = r.data.emailAuthFactor, this.session.active = r.data.active ?? !0, this.session.status = r.data.status, this._updateApiEndpoint(r.data.didDoc), this._persistSession?.("update", this.session), r;
    } catch (r) {
      throw this.session = void 0, r instanceof kl.XRPCError ? [1, 408, 425, 429, 500, 502, 503, 504, 522, 524].includes(r.status) ? this._persistSession?.("network-error", void 0) : this._persistSession?.("expired", void 0) : this._persistSession?.("network-error", void 0), r;
    }
  }
  /**
   * Internal helper to add authorization headers to requests.
   */
  _addHeaders(e) {
    !e.authorization && this.session?.accessJwt && (e = {
      ...e,
      authorization: `Bearer ${this.session.accessJwt}`
    }), this.proxyHeader && (e = {
      ...e,
      "atproto-proxy": this.proxyHeader
    });
    const r = "atproto-accept-labelers", n = Dr.appLabelers.map((u) => `${u};redact`).concat(this.labelersHeader.filter((u) => u.startsWith("did:")));
    return e[r] && n.push(
      ...e[r].split(",").map((u) => u.trim())
    ), e = {
      ...e,
      [r]: n.join(", ")
    }, e;
  }
  /**
   * Internal fetch handler which adds access-token management
   */
  async _fetch(e, r, n, u) {
    if (!Dr.fetch)
      throw new Error("AtpAgent fetch() method not configured");
    await this._refreshSessionPromise;
    let y = await Dr.fetch(e, r, this._addHeaders(n), u);
    return Rd(y, ["ExpiredToken"]) && this.session?.refreshJwt && (await this.refreshSession(), y = await Dr.fetch(e, r, this._addHeaders(n), u)), y;
  }
  /**
   * Internal helper to refresh sessions
   * - Wraps the actual implementation in a promise-guard to ensure only
   *   one refresh is attempted at a time.
   */
  async refreshSession() {
    if (this._refreshSessionPromise)
      return this._refreshSessionPromise;
    this._refreshSessionPromise = this._refreshSessionInner();
    try {
      await this._refreshSessionPromise;
    } finally {
      this._refreshSessionPromise = void 0;
    }
  }
  /**
   * Internal helper to refresh sessions (actual behavior)
   */
  async _refreshSessionInner() {
    if (!Dr.fetch)
      throw new Error("AtpAgent fetch() method not configured");
    if (!this.session?.refreshJwt)
      return;
    const e = new URL((this.pdsUrl || this.service).origin);
    e.pathname = `/xrpc/${iI}`;
    const r = await Dr.fetch(e.toString(), "POST", {
      authorization: `Bearer ${this.session.refreshJwt}`
    }, void 0);
    Rd(r, ["ExpiredToken", "InvalidToken"]) ? (this.session = void 0, this._persistSession?.("expired", void 0)) : aI(this._baseClient, r.body) && (this.session = {
      ...this.session || {},
      accessJwt: r.body.accessJwt,
      refreshJwt: r.body.refreshJwt,
      handle: r.body.handle,
      did: r.body.did
    }, this._updateApiEndpoint(r.body.didDoc), this._persistSession?.("update", this.session));
  }
  /**
   * Helper to update the pds endpoint dynamically.
   *
   * The session methods (create, resume, refresh) may respond with the user's
   * did document which contains the user's canonical PDS endpoint. That endpoint
   * may differ from the endpoint used to contact the server. We capture that
   * PDS endpoint and update the client to use that given endpoint for future
   * requests. (This helps ensure smooth migrations between PDSes, especially
   * when the PDSes are operated by a single org.)
   */
  _updateApiEndpoint(e) {
    if ((0, vd.isValidDidDoc)(e)) {
      const r = (0, vd.getPdsEndpoint)(e);
      this.pdsUrl = r ? new URL(r) : void 0;
    }
    this.api.xrpc.uri = this.pdsUrl || this.service;
  }
}
ka.AtpAgent = Dr;
Object.defineProperty(Dr, "fetch", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: kl.defaultFetchHandler
});
Object.defineProperty(Dr, "appLabelers", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: [rI.BSKY_LABELER_DID]
});
function nI(t) {
  return eI.errorResponseBody.safeParse(t).success;
}
function Rd(t, e) {
  return t.status !== 400 || !nI(t.body) ? !1 : typeof t.body.error == "string" && e.includes(t.body.error);
}
function aI(t, e) {
  try {
    return t.xrpc.lex.assertValidXrpcOutput("com.atproto.server.refreshSession", e), !0;
  } catch {
    return !1;
  }
}
var Da = {}, Ka = {};
Object.defineProperty(Ka, "__esModule", { value: !0 });
Ka.UnicodeString = void 0;
const sI = Pi, Ad = new TextEncoder(), oI = new TextDecoder();
class lI {
  constructor(e) {
    Object.defineProperty(this, "utf16", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "utf8", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_graphemeLen", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.utf16 = e, this.utf8 = Ad.encode(e);
  }
  get length() {
    return this.utf8.byteLength;
  }
  get graphemeLength() {
    return this._graphemeLen || (this._graphemeLen = (0, sI.graphemeLen)(this.utf16)), this._graphemeLen;
  }
  slice(e, r) {
    return oI.decode(this.utf8.slice(e, r));
  }
  utf16IndexToUtf8Index(e) {
    return Ad.encode(this.utf16.slice(0, e)).byteLength;
  }
  toString() {
    return this.utf16;
  }
}
Ka.UnicodeString = lI;
var ml = {};
Object.defineProperty(ml, "__esModule", { value: !0 });
ml.sanitizeRichText = void 0;
const uI = Ka, cI = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/, dI = `

`;
function fI(t, e) {
  return e.cleanNewlines && (t = pI(t, cI, dI)), t;
}
ml.sanitizeRichText = fI;
function pI(t, e, r) {
  t = t.clone();
  let n = t.unicodeText.utf16.match(e);
  for (; n && typeof n.index < "u"; ) {
    const u = t.unicodeText, y = t.unicodeText.utf16IndexToUtf8Index(n.index), b = y + new uI.UnicodeString(n[0]).length;
    if (t.delete(y, b), t.unicodeText.utf16 === u.utf16)
      break;
    t.insert(y, r), n = t.unicodeText.utf16.match(e);
  }
  return t;
}
var lu = {};
const hI = [
  "aaa",
  "aarp",
  "abb",
  "abbott",
  "abbvie",
  "abc",
  "able",
  "abogado",
  "abudhabi",
  "ac",
  "academy",
  "accenture",
  "accountant",
  "accountants",
  "aco",
  "actor",
  "ad",
  "ads",
  "adult",
  "ae",
  "aeg",
  "aero",
  "aetna",
  "af",
  "afl",
  "africa",
  "ag",
  "agakhan",
  "agency",
  "ai",
  "aig",
  "airbus",
  "airforce",
  "airtel",
  "akdn",
  "al",
  "alibaba",
  "alipay",
  "allfinanz",
  "allstate",
  "ally",
  "alsace",
  "alstom",
  "am",
  "amazon",
  "americanexpress",
  "americanfamily",
  "amex",
  "amfam",
  "amica",
  "amsterdam",
  "analytics",
  "android",
  "anquan",
  "anz",
  "ao",
  "aol",
  "apartments",
  "app",
  "apple",
  "aq",
  "aquarelle",
  "ar",
  "arab",
  "aramco",
  "archi",
  "army",
  "arpa",
  "art",
  "arte",
  "as",
  "asda",
  "asia",
  "associates",
  "at",
  "athleta",
  "attorney",
  "au",
  "auction",
  "audi",
  "audible",
  "audio",
  "auspost",
  "author",
  "auto",
  "autos",
  "aw",
  "aws",
  "ax",
  "axa",
  "az",
  "azure",
  "ba",
  "baby",
  "baidu",
  "banamex",
  "band",
  "bank",
  "bar",
  "barcelona",
  "barclaycard",
  "barclays",
  "barefoot",
  "bargains",
  "baseball",
  "basketball",
  "bauhaus",
  "bayern",
  "bb",
  "bbc",
  "bbt",
  "bbva",
  "bcg",
  "bcn",
  "bd",
  "be",
  "beats",
  "beauty",
  "beer",
  "bentley",
  "berlin",
  "best",
  "bestbuy",
  "bet",
  "bf",
  "bg",
  "bh",
  "bharti",
  "bi",
  "bible",
  "bid",
  "bike",
  "bing",
  "bingo",
  "bio",
  "biz",
  "bj",
  "black",
  "blackfriday",
  "blockbuster",
  "blog",
  "bloomberg",
  "blue",
  "bm",
  "bms",
  "bmw",
  "bn",
  "bnpparibas",
  "bo",
  "boats",
  "boehringer",
  "bofa",
  "bom",
  "bond",
  "boo",
  "book",
  "booking",
  "bosch",
  "bostik",
  "boston",
  "bot",
  "boutique",
  "box",
  "br",
  "bradesco",
  "bridgestone",
  "broadway",
  "broker",
  "brother",
  "brussels",
  "bs",
  "bt",
  "build",
  "builders",
  "business",
  "buy",
  "buzz",
  "bv",
  "bw",
  "by",
  "bz",
  "bzh",
  "ca",
  "cab",
  "cafe",
  "cal",
  "call",
  "calvinklein",
  "cam",
  "camera",
  "camp",
  "canon",
  "capetown",
  "capital",
  "capitalone",
  "car",
  "caravan",
  "cards",
  "care",
  "career",
  "careers",
  "cars",
  "casa",
  "case",
  "cash",
  "casino",
  "cat",
  "catering",
  "catholic",
  "cba",
  "cbn",
  "cbre",
  "cc",
  "cd",
  "center",
  "ceo",
  "cern",
  "cf",
  "cfa",
  "cfd",
  "cg",
  "ch",
  "chanel",
  "channel",
  "charity",
  "chase",
  "chat",
  "cheap",
  "chintai",
  "christmas",
  "chrome",
  "church",
  "ci",
  "cipriani",
  "circle",
  "cisco",
  "citadel",
  "citi",
  "citic",
  "city",
  "ck",
  "cl",
  "claims",
  "cleaning",
  "click",
  "clinic",
  "clinique",
  "clothing",
  "cloud",
  "club",
  "clubmed",
  "cm",
  "cn",
  "co",
  "coach",
  "codes",
  "coffee",
  "college",
  "cologne",
  "com",
  "commbank",
  "community",
  "company",
  "compare",
  "computer",
  "comsec",
  "condos",
  "construction",
  "consulting",
  "contact",
  "contractors",
  "cooking",
  "cool",
  "coop",
  "corsica",
  "country",
  "coupon",
  "coupons",
  "courses",
  "cpa",
  "cr",
  "credit",
  "creditcard",
  "creditunion",
  "cricket",
  "crown",
  "crs",
  "cruise",
  "cruises",
  "cu",
  "cuisinella",
  "cv",
  "cw",
  "cx",
  "cy",
  "cymru",
  "cyou",
  "cz",
  "dad",
  "dance",
  "data",
  "date",
  "dating",
  "datsun",
  "day",
  "dclk",
  "dds",
  "de",
  "deal",
  "dealer",
  "deals",
  "degree",
  "delivery",
  "dell",
  "deloitte",
  "delta",
  "democrat",
  "dental",
  "dentist",
  "desi",
  "design",
  "dev",
  "dhl",
  "diamonds",
  "diet",
  "digital",
  "direct",
  "directory",
  "discount",
  "discover",
  "dish",
  "diy",
  "dj",
  "dk",
  "dm",
  "dnp",
  "do",
  "docs",
  "doctor",
  "dog",
  "domains",
  "dot",
  "download",
  "drive",
  "dtv",
  "dubai",
  "dunlop",
  "dupont",
  "durban",
  "dvag",
  "dvr",
  "dz",
  "earth",
  "eat",
  "ec",
  "eco",
  "edeka",
  "edu",
  "education",
  "ee",
  "eg",
  "email",
  "emerck",
  "energy",
  "engineer",
  "engineering",
  "enterprises",
  "epson",
  "equipment",
  "er",
  "ericsson",
  "erni",
  "es",
  "esq",
  "estate",
  "et",
  "eu",
  "eurovision",
  "eus",
  "events",
  "exchange",
  "expert",
  "exposed",
  "express",
  "extraspace",
  "fage",
  "fail",
  "fairwinds",
  "faith",
  "family",
  "fan",
  "fans",
  "farm",
  "farmers",
  "fashion",
  "fast",
  "fedex",
  "feedback",
  "ferrari",
  "ferrero",
  "fi",
  "fidelity",
  "fido",
  "film",
  "final",
  "finance",
  "financial",
  "fire",
  "firestone",
  "firmdale",
  "fish",
  "fishing",
  "fit",
  "fitness",
  "fj",
  "fk",
  "flickr",
  "flights",
  "flir",
  "florist",
  "flowers",
  "fly",
  "fm",
  "fo",
  "foo",
  "food",
  "football",
  "ford",
  "forex",
  "forsale",
  "forum",
  "foundation",
  "fox",
  "fr",
  "free",
  "fresenius",
  "frl",
  "frogans",
  "frontier",
  "ftr",
  "fujitsu",
  "fun",
  "fund",
  "furniture",
  "futbol",
  "fyi",
  "ga",
  "gal",
  "gallery",
  "gallo",
  "gallup",
  "game",
  "games",
  "gap",
  "garden",
  "gay",
  "gb",
  "gbiz",
  "gd",
  "gdn",
  "ge",
  "gea",
  "gent",
  "genting",
  "george",
  "gf",
  "gg",
  "ggee",
  "gh",
  "gi",
  "gift",
  "gifts",
  "gives",
  "giving",
  "gl",
  "glass",
  "gle",
  "global",
  "globo",
  "gm",
  "gmail",
  "gmbh",
  "gmo",
  "gmx",
  "gn",
  "godaddy",
  "gold",
  "goldpoint",
  "golf",
  "goo",
  "goodyear",
  "goog",
  "google",
  "gop",
  "got",
  "gov",
  "gp",
  "gq",
  "gr",
  "grainger",
  "graphics",
  "gratis",
  "green",
  "gripe",
  "grocery",
  "group",
  "gs",
  "gt",
  "gu",
  "gucci",
  "guge",
  "guide",
  "guitars",
  "guru",
  "gw",
  "gy",
  "hair",
  "hamburg",
  "hangout",
  "haus",
  "hbo",
  "hdfc",
  "hdfcbank",
  "health",
  "healthcare",
  "help",
  "helsinki",
  "here",
  "hermes",
  "hiphop",
  "hisamitsu",
  "hitachi",
  "hiv",
  "hk",
  "hkt",
  "hm",
  "hn",
  "hockey",
  "holdings",
  "holiday",
  "homedepot",
  "homegoods",
  "homes",
  "homesense",
  "honda",
  "horse",
  "hospital",
  "host",
  "hosting",
  "hot",
  "hotels",
  "hotmail",
  "house",
  "how",
  "hr",
  "hsbc",
  "ht",
  "hu",
  "hughes",
  "hyatt",
  "hyundai",
  "ibm",
  "icbc",
  "ice",
  "icu",
  "id",
  "ie",
  "ieee",
  "ifm",
  "ikano",
  "il",
  "im",
  "imamat",
  "imdb",
  "immo",
  "immobilien",
  "in",
  "inc",
  "industries",
  "infiniti",
  "info",
  "ing",
  "ink",
  "institute",
  "insurance",
  "insure",
  "int",
  "international",
  "intuit",
  "investments",
  "io",
  "ipiranga",
  "iq",
  "ir",
  "irish",
  "is",
  "ismaili",
  "ist",
  "istanbul",
  "it",
  "itau",
  "itv",
  "jaguar",
  "java",
  "jcb",
  "je",
  "jeep",
  "jetzt",
  "jewelry",
  "jio",
  "jll",
  "jm",
  "jmp",
  "jnj",
  "jo",
  "jobs",
  "joburg",
  "jot",
  "joy",
  "jp",
  "jpmorgan",
  "jprs",
  "juegos",
  "juniper",
  "kaufen",
  "kddi",
  "ke",
  "kerryhotels",
  "kerrylogistics",
  "kerryproperties",
  "kfh",
  "kg",
  "kh",
  "ki",
  "kia",
  "kids",
  "kim",
  "kindle",
  "kitchen",
  "kiwi",
  "km",
  "kn",
  "koeln",
  "komatsu",
  "kosher",
  "kp",
  "kpmg",
  "kpn",
  "kr",
  "krd",
  "kred",
  "kuokgroup",
  "kw",
  "ky",
  "kyoto",
  "kz",
  "la",
  "lacaixa",
  "lamborghini",
  "lamer",
  "lancaster",
  "land",
  "landrover",
  "lanxess",
  "lasalle",
  "lat",
  "latino",
  "latrobe",
  "law",
  "lawyer",
  "lb",
  "lc",
  "lds",
  "lease",
  "leclerc",
  "lefrak",
  "legal",
  "lego",
  "lexus",
  "lgbt",
  "li",
  "lidl",
  "life",
  "lifeinsurance",
  "lifestyle",
  "lighting",
  "like",
  "lilly",
  "limited",
  "limo",
  "lincoln",
  "link",
  "lipsy",
  "live",
  "living",
  "lk",
  "llc",
  "llp",
  "loan",
  "loans",
  "locker",
  "locus",
  "lol",
  "london",
  "lotte",
  "lotto",
  "love",
  "lpl",
  "lplfinancial",
  "lr",
  "ls",
  "lt",
  "ltd",
  "ltda",
  "lu",
  "lundbeck",
  "luxe",
  "luxury",
  "lv",
  "ly",
  "ma",
  "madrid",
  "maif",
  "maison",
  "makeup",
  "man",
  "management",
  "mango",
  "map",
  "market",
  "marketing",
  "markets",
  "marriott",
  "marshalls",
  "mattel",
  "mba",
  "mc",
  "mckinsey",
  "md",
  "me",
  "med",
  "media",
  "meet",
  "melbourne",
  "meme",
  "memorial",
  "men",
  "menu",
  "merckmsd",
  "mg",
  "mh",
  "miami",
  "microsoft",
  "mil",
  "mini",
  "mint",
  "mit",
  "mitsubishi",
  "mk",
  "ml",
  "mlb",
  "mls",
  "mm",
  "mma",
  "mn",
  "mo",
  "mobi",
  "mobile",
  "moda",
  "moe",
  "moi",
  "mom",
  "monash",
  "money",
  "monster",
  "mormon",
  "mortgage",
  "moscow",
  "moto",
  "motorcycles",
  "mov",
  "movie",
  "mp",
  "mq",
  "mr",
  "ms",
  "msd",
  "mt",
  "mtn",
  "mtr",
  "mu",
  "museum",
  "music",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "nab",
  "nagoya",
  "name",
  "navy",
  "nba",
  "nc",
  "ne",
  "nec",
  "net",
  "netbank",
  "netflix",
  "network",
  "neustar",
  "new",
  "news",
  "next",
  "nextdirect",
  "nexus",
  "nf",
  "nfl",
  "ng",
  "ngo",
  "nhk",
  "ni",
  "nico",
  "nike",
  "nikon",
  "ninja",
  "nissan",
  "nissay",
  "nl",
  "no",
  "nokia",
  "norton",
  "now",
  "nowruz",
  "nowtv",
  "np",
  "nr",
  "nra",
  "nrw",
  "ntt",
  "nu",
  "nyc",
  "nz",
  "obi",
  "observer",
  "office",
  "okinawa",
  "olayan",
  "olayangroup",
  "ollo",
  "om",
  "omega",
  "one",
  "ong",
  "onl",
  "online",
  "ooo",
  "open",
  "oracle",
  "orange",
  "org",
  "organic",
  "origins",
  "osaka",
  "otsuka",
  "ott",
  "ovh",
  "pa",
  "page",
  "panasonic",
  "paris",
  "pars",
  "partners",
  "parts",
  "party",
  "pay",
  "pccw",
  "pe",
  "pet",
  "pf",
  "pfizer",
  "pg",
  "ph",
  "pharmacy",
  "phd",
  "philips",
  "phone",
  "photo",
  "photography",
  "photos",
  "physio",
  "pics",
  "pictet",
  "pictures",
  "pid",
  "pin",
  "ping",
  "pink",
  "pioneer",
  "pizza",
  "pk",
  "pl",
  "place",
  "play",
  "playstation",
  "plumbing",
  "plus",
  "pm",
  "pn",
  "pnc",
  "pohl",
  "poker",
  "politie",
  "porn",
  "post",
  "pr",
  "pramerica",
  "praxi",
  "press",
  "prime",
  "pro",
  "prod",
  "productions",
  "prof",
  "progressive",
  "promo",
  "properties",
  "property",
  "protection",
  "pru",
  "prudential",
  "ps",
  "pt",
  "pub",
  "pw",
  "pwc",
  "py",
  "qa",
  "qpon",
  "quebec",
  "quest",
  "racing",
  "radio",
  "re",
  "read",
  "realestate",
  "realtor",
  "realty",
  "recipes",
  "red",
  "redstone",
  "redumbrella",
  "rehab",
  "reise",
  "reisen",
  "reit",
  "reliance",
  "ren",
  "rent",
  "rentals",
  "repair",
  "report",
  "republican",
  "rest",
  "restaurant",
  "review",
  "reviews",
  "rexroth",
  "rich",
  "richardli",
  "ricoh",
  "ril",
  "rio",
  "rip",
  "ro",
  "rocks",
  "rodeo",
  "rogers",
  "room",
  "rs",
  "rsvp",
  "ru",
  "rugby",
  "ruhr",
  "run",
  "rw",
  "rwe",
  "ryukyu",
  "sa",
  "saarland",
  "safe",
  "safety",
  "sakura",
  "sale",
  "salon",
  "samsclub",
  "samsung",
  "sandvik",
  "sandvikcoromant",
  "sanofi",
  "sap",
  "sarl",
  "sas",
  "save",
  "saxo",
  "sb",
  "sbi",
  "sbs",
  "sc",
  "scb",
  "schaeffler",
  "schmidt",
  "scholarships",
  "school",
  "schule",
  "schwarz",
  "science",
  "scot",
  "sd",
  "se",
  "search",
  "seat",
  "secure",
  "security",
  "seek",
  "select",
  "sener",
  "services",
  "seven",
  "sew",
  "sex",
  "sexy",
  "sfr",
  "sg",
  "sh",
  "shangrila",
  "sharp",
  "shell",
  "shia",
  "shiksha",
  "shoes",
  "shop",
  "shopping",
  "shouji",
  "show",
  "si",
  "silk",
  "sina",
  "singles",
  "site",
  "sj",
  "sk",
  "ski",
  "skin",
  "sky",
  "skype",
  "sl",
  "sling",
  "sm",
  "smart",
  "smile",
  "sn",
  "sncf",
  "so",
  "soccer",
  "social",
  "softbank",
  "software",
  "sohu",
  "solar",
  "solutions",
  "song",
  "sony",
  "soy",
  "spa",
  "space",
  "sport",
  "spot",
  "sr",
  "srl",
  "ss",
  "st",
  "stada",
  "staples",
  "star",
  "statebank",
  "statefarm",
  "stc",
  "stcgroup",
  "stockholm",
  "storage",
  "store",
  "stream",
  "studio",
  "study",
  "style",
  "su",
  "sucks",
  "supplies",
  "supply",
  "support",
  "surf",
  "surgery",
  "suzuki",
  "sv",
  "swatch",
  "swiss",
  "sx",
  "sy",
  "sydney",
  "systems",
  "sz",
  "tab",
  "taipei",
  "talk",
  "taobao",
  "target",
  "tatamotors",
  "tatar",
  "tattoo",
  "tax",
  "taxi",
  "tc",
  "tci",
  "td",
  "tdk",
  "team",
  "tech",
  "technology",
  "tel",
  "temasek",
  "tennis",
  "teva",
  "tf",
  "tg",
  "th",
  "thd",
  "theater",
  "theatre",
  "tiaa",
  "tickets",
  "tienda",
  "tips",
  "tires",
  "tirol",
  "tj",
  "tjmaxx",
  "tjx",
  "tk",
  "tkmaxx",
  "tl",
  "tm",
  "tmall",
  "tn",
  "to",
  "today",
  "tokyo",
  "tools",
  "top",
  "toray",
  "toshiba",
  "total",
  "tours",
  "town",
  "toyota",
  "toys",
  "tr",
  "trade",
  "trading",
  "training",
  "travel",
  "travelers",
  "travelersinsurance",
  "trust",
  "trv",
  "tt",
  "tube",
  "tui",
  "tunes",
  "tushu",
  "tv",
  "tvs",
  "tw",
  "tz",
  "ua",
  "ubank",
  "ubs",
  "ug",
  "uk",
  "unicom",
  "university",
  "uno",
  "uol",
  "ups",
  "us",
  "uy",
  "uz",
  "va",
  "vacations",
  "vana",
  "vanguard",
  "vc",
  "ve",
  "vegas",
  "ventures",
  "verisign",
  "vermögensberater",
  "vermögensberatung",
  "versicherung",
  "vet",
  "vg",
  "vi",
  "viajes",
  "video",
  "vig",
  "viking",
  "villas",
  "vin",
  "vip",
  "virgin",
  "visa",
  "vision",
  "viva",
  "vivo",
  "vlaanderen",
  "vn",
  "vodka",
  "volvo",
  "vote",
  "voting",
  "voto",
  "voyage",
  "vu",
  "wales",
  "walmart",
  "walter",
  "wang",
  "wanggou",
  "watch",
  "watches",
  "weather",
  "weatherchannel",
  "webcam",
  "weber",
  "website",
  "wed",
  "wedding",
  "weibo",
  "weir",
  "wf",
  "whoswho",
  "wien",
  "wiki",
  "williamhill",
  "win",
  "windows",
  "wine",
  "winners",
  "wme",
  "wolterskluwer",
  "woodside",
  "work",
  "works",
  "world",
  "wow",
  "ws",
  "wtc",
  "wtf",
  "xbox",
  "xerox",
  "xihuan",
  "xin",
  "xxx",
  "xyz",
  "yachts",
  "yahoo",
  "yamaxun",
  "yandex",
  "ye",
  "yodobashi",
  "yoga",
  "yokohama",
  "you",
  "youtube",
  "yt",
  "yun",
  "za",
  "zappos",
  "zara",
  "zero",
  "zip",
  "zm",
  "zone",
  "zuerich",
  "zw",
  "ελ",
  "ευ",
  "бг",
  "бел",
  "дети",
  "ею",
  "католик",
  "ком",
  "мкд",
  "мон",
  "москва",
  "онлайн",
  "орг",
  "рус",
  "рф",
  "сайт",
  "срб",
  "укр",
  "қаз",
  "հայ",
  "ישראל",
  "קום",
  "ابوظبي",
  "ارامكو",
  "الاردن",
  "البحرين",
  "الجزائر",
  "السعودية",
  "العليان",
  "المغرب",
  "امارات",
  "ایران",
  "بارت",
  "بازار",
  "بيتك",
  "بھارت",
  "تونس",
  "سودان",
  "سورية",
  "شبكة",
  "عراق",
  "عرب",
  "عمان",
  "فلسطين",
  "قطر",
  "كاثوليك",
  "كوم",
  "مصر",
  "مليسيا",
  "موريتانيا",
  "موقع",
  "همراه",
  "پاکستان",
  "ڀارت",
  "कॉम",
  "नेट",
  "भारत",
  "भारतम्",
  "भारोत",
  "संगठन",
  "বাংলা",
  "ভারত",
  "ভাৰত",
  "ਭਾਰਤ",
  "ભારત",
  "ଭାରତ",
  "இந்தியா",
  "இலங்கை",
  "சிங்கப்பூர்",
  "భారత్",
  "ಭಾರತ",
  "ഭാരതം",
  "ලංකා",
  "คอม",
  "ไทย",
  "ລາວ",
  "გე",
  "みんな",
  "アマゾン",
  "クラウド",
  "グーグル",
  "コム",
  "ストア",
  "セール",
  "ファッション",
  "ポイント",
  "世界",
  "中信",
  "中国",
  "中國",
  "中文网",
  "亚马逊",
  "企业",
  "佛山",
  "信息",
  "健康",
  "八卦",
  "公司",
  "公益",
  "台湾",
  "台灣",
  "商城",
  "商店",
  "商标",
  "嘉里",
  "嘉里大酒店",
  "在线",
  "大拿",
  "天主教",
  "娱乐",
  "家電",
  "广东",
  "微博",
  "慈善",
  "我爱你",
  "手机",
  "招聘",
  "政务",
  "政府",
  "新加坡",
  "新闻",
  "时尚",
  "書籍",
  "机构",
  "淡马锡",
  "游戏",
  "澳門",
  "点看",
  "移动",
  "组织机构",
  "网址",
  "网店",
  "网站",
  "网络",
  "联通",
  "谷歌",
  "购物",
  "通販",
  "集团",
  "電訊盈科",
  "飞利浦",
  "食品",
  "餐厅",
  "香格里拉",
  "香港",
  "닷넷",
  "닷컴",
  "삼성",
  "한국"
];
var ai = {};
Object.defineProperty(ai, "__esModule", { value: !0 });
ai.TAG_REGEX = ai.TRAILING_PUNCTUATION_REGEX = ai.URL_REGEX = ai.MENTION_REGEX = void 0;
ai.MENTION_REGEX = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
ai.URL_REGEX = /(^|\s|\()((https?:\/\/[\S]+)|((?<domain>[a-z][a-z0-9]*(\.[a-z0-9]+)+)[\S]*))/gim;
ai.TRAILING_PUNCTUATION_REGEX = /\p{P}+$/gu;
ai.TAG_REGEX = // eslint-disable-next-line no-misleading-character-class
/(^|\s)[#＃]((?!\ufe0f)[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*[^\d\s\p{P}\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]+[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*)?/gu;
var mI = de && de.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(lu, "__esModule", { value: !0 });
lu.detectFacets = void 0;
const yI = mI(hI), Cl = ai;
function bI(t) {
  let e;
  const r = [];
  {
    const n = Cl.MENTION_REGEX;
    for (; e = n.exec(t.utf16); ) {
      if (!_d(e[3]) && !e[3].endsWith(".test"))
        continue;
      const u = t.utf16.indexOf(e[3], e.index) - 1;
      r.push({
        $type: "app.bsky.richtext.facet",
        index: {
          byteStart: t.utf16IndexToUtf8Index(u),
          byteEnd: t.utf16IndexToUtf8Index(u + e[3].length + 1)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#mention",
            did: e[3]
            // must be resolved afterwards
          }
        ]
      });
    }
  }
  {
    const n = Cl.URL_REGEX;
    for (; e = n.exec(t.utf16); ) {
      let u = e[2];
      if (!u.startsWith("http")) {
        const h = e.groups?.domain;
        if (!h || !_d(h))
          continue;
        u = `https://${u}`;
      }
      const y = t.utf16.indexOf(e[2], e.index), b = { start: y, end: y + e[2].length };
      /[.,;:!?]$/.test(u) && (u = u.slice(0, -1), b.end--), /[)]$/.test(u) && !u.includes("(") && (u = u.slice(0, -1), b.end--), r.push({
        index: {
          byteStart: t.utf16IndexToUtf8Index(b.start),
          byteEnd: t.utf16IndexToUtf8Index(b.end)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#link",
            uri: u
          }
        ]
      });
    }
  }
  {
    const n = Cl.TAG_REGEX;
    for (; e = n.exec(t.utf16); ) {
      const u = e[1];
      let y = e[2];
      if (!y || (y = y.trim().replace(Cl.TRAILING_PUNCTUATION_REGEX, ""), y.length === 0 || y.length > 64))
        continue;
      const b = e.index + u.length;
      r.push({
        index: {
          byteStart: t.utf16IndexToUtf8Index(b),
          byteEnd: t.utf16IndexToUtf8Index(b + 1 + y.length)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#tag",
            tag: y
          }
        ]
      });
    }
  }
  return r.length > 0 ? r : void 0;
}
lu.detectFacets = bI;
function _d(t) {
  return !!yI.default.find((e) => {
    const r = t.lastIndexOf(e);
    return r === -1 ? !1 : t.charAt(r - 1) === "." && r === t.length - e.length;
  });
}
Object.defineProperty(Da, "__esModule", { value: !0 });
Da.RichText = Da.RichTextSegment = void 0;
const Bn = E, Su = Ka, gI = ml, wd = lu;
class ua {
  constructor(e, r) {
    Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "facet", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  get link() {
    const e = this.facet?.features.find(Bn.AppBskyRichtextFacet.isLink);
    if (Bn.AppBskyRichtextFacet.isLink(e))
      return e;
  }
  isLink() {
    return !!this.link;
  }
  get mention() {
    const e = this.facet?.features.find(Bn.AppBskyRichtextFacet.isMention);
    if (Bn.AppBskyRichtextFacet.isMention(e))
      return e;
  }
  isMention() {
    return !!this.mention;
  }
  get tag() {
    const e = this.facet?.features.find(Bn.AppBskyRichtextFacet.isTag);
    if (Bn.AppBskyRichtextFacet.isTag(e))
      return e;
  }
  isTag() {
    return !!this.tag;
  }
}
Da.RichTextSegment = ua;
class pc {
  constructor(e, r) {
    Object.defineProperty(this, "unicodeText", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "facets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.unicodeText = new Su.UnicodeString(e.text), this.facets = e.facets, !this.facets?.length && e.entities?.length && (this.facets = xI(this.unicodeText, e.entities)), this.facets && this.facets.sort(Cu), r?.cleanNewlines && (0, gI.sanitizeRichText)(this, { cleanNewlines: !0 }).copyInto(this);
  }
  get text() {
    return this.unicodeText.toString();
  }
  get length() {
    return this.unicodeText.length;
  }
  get graphemeLength() {
    return this.unicodeText.graphemeLength;
  }
  clone() {
    return new pc({
      text: this.unicodeText.utf16,
      facets: Td(this.facets)
    });
  }
  copyInto(e) {
    e.unicodeText = this.unicodeText, e.facets = Td(this.facets);
  }
  *segments() {
    const e = this.facets || [];
    if (!e.length) {
      yield new ua(this.unicodeText.utf16);
      return;
    }
    let r = 0, n = 0;
    do {
      const u = e[n];
      if (r < u.index.byteStart)
        yield new ua(this.unicodeText.slice(r, u.index.byteStart));
      else if (r > u.index.byteStart) {
        n++;
        continue;
      }
      if (u.index.byteStart < u.index.byteEnd) {
        const y = this.unicodeText.slice(u.index.byteStart, u.index.byteEnd);
        y.trim() ? yield new ua(y, u) : yield new ua(y);
      }
      r = u.index.byteEnd, n++;
    } while (n < e.length);
    r < this.unicodeText.length && (yield new ua(this.unicodeText.slice(r, this.unicodeText.length)));
  }
  insert(e, r) {
    if (this.unicodeText = new Su.UnicodeString(this.unicodeText.slice(0, e) + r + this.unicodeText.slice(e)), !this.facets?.length)
      return this;
    const n = r.length;
    for (const u of this.facets)
      e <= u.index.byteStart ? (u.index.byteStart += n, u.index.byteEnd += n) : e >= u.index.byteStart && e < u.index.byteEnd && (u.index.byteEnd += n);
    return this;
  }
  delete(e, r) {
    if (this.unicodeText = new Su.UnicodeString(this.unicodeText.slice(0, e) + this.unicodeText.slice(r)), !this.facets?.length)
      return this;
    const n = r - e;
    for (const u of this.facets)
      e <= u.index.byteStart && r >= u.index.byteEnd ? (u.index.byteStart = 0, u.index.byteEnd = 0) : e > u.index.byteEnd || (e > u.index.byteStart && e <= u.index.byteEnd && r > u.index.byteEnd ? u.index.byteEnd = e : e >= u.index.byteStart && r <= u.index.byteEnd ? u.index.byteEnd -= n : e < u.index.byteStart && r >= u.index.byteStart && r <= u.index.byteEnd ? (u.index.byteStart = e, u.index.byteEnd -= n) : r < u.index.byteStart && (u.index.byteStart -= n, u.index.byteEnd -= n));
    return this.facets = this.facets.filter((u) => u.index.byteStart < u.index.byteEnd), this;
  }
  /**
   * Detects facets such as links and mentions
   * Note: Overwrites the existing facets with auto-detected facets
   */
  async detectFacets(e) {
    if (this.facets = (0, wd.detectFacets)(this.unicodeText), this.facets) {
      for (const r of this.facets)
        for (const n of r.features)
          if (Bn.AppBskyRichtextFacet.isMention(n)) {
            const u = await e.resolveHandle({ handle: n.did }).catch((y) => {
            }).then((y) => y?.data.did);
            n.did = u || "";
          }
      this.facets.sort(Cu);
    }
  }
  /**
   * Detects facets such as links and mentions but does not resolve them
   * Will produce invalid facets! For instance, mentions will not have their DIDs set.
   * Note: Overwrites the existing facets with auto-detected facets
   */
  detectFacetsWithoutResolution() {
    this.facets = (0, wd.detectFacets)(this.unicodeText), this.facets && this.facets.sort(Cu);
  }
}
Da.RichText = pc;
const Cu = (t, e) => t.index.byteStart - e.index.byteStart;
function xI(t, e) {
  const r = [];
  for (const n of e)
    n.type === "link" ? r.push({
      $type: "app.bsky.richtext.facet",
      index: {
        byteStart: t.utf16IndexToUtf8Index(n.index.start),
        byteEnd: t.utf16IndexToUtf8Index(n.index.end)
      },
      features: [{ $type: "app.bsky.richtext.facet#link", uri: n.value }]
    }) : n.type === "mention" && r.push({
      $type: "app.bsky.richtext.facet",
      index: {
        byteStart: t.utf16IndexToUtf8Index(n.index.start),
        byteEnd: t.utf16IndexToUtf8Index(n.index.end)
      },
      features: [
        { $type: "app.bsky.richtext.facet#mention", did: n.value }
      ]
    });
  return r;
}
function Td(t) {
  return typeof t > "u" ? t : JSON.parse(JSON.stringify(t));
}
var hc = {}, ki = {}, si = {}, Rr = {};
Object.defineProperty(Rr, "__esModule", { value: !0 });
Rr.NOOP_BEHAVIOR = Rr.HIDE_BEHAVIOR = Rr.MUTEWORD_BEHAVIOR = Rr.MUTE_BEHAVIOR = Rr.BLOCK_BEHAVIOR = Rr.CUSTOM_LABEL_VALUE_RE = void 0;
Rr.CUSTOM_LABEL_VALUE_RE = /^[a-z-]+$/;
Rr.BLOCK_BEHAVIOR = {
  profileList: "blur",
  profileView: "alert",
  avatar: "blur",
  banner: "blur",
  contentList: "blur",
  contentView: "blur"
};
Rr.MUTE_BEHAVIOR = {
  profileList: "inform",
  profileView: "alert",
  contentList: "blur",
  contentView: "inform"
};
Rr.MUTEWORD_BEHAVIOR = {
  contentList: "blur",
  contentView: "blur"
};
Rr.HIDE_BEHAVIOR = {
  contentList: "blur",
  contentView: "blur"
};
Rr.NOOP_BEHAVIOR = {};
var yl = {};
Object.defineProperty(yl, "__esModule", { value: !0 });
yl.ModerationUI = void 0;
class EI {
  constructor() {
    Object.defineProperty(this, "noOverride", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "filters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "blurs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "alerts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "informs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  get filter() {
    return this.filters.length !== 0;
  }
  get blur() {
    return this.blurs.length !== 0;
  }
  get alert() {
    return this.alerts.length !== 0;
  }
  get inform() {
    return this.informs.length !== 0;
  }
}
yl.ModerationUI = EI;
var _n = {};
Object.defineProperty(_n, "__esModule", { value: !0 });
_n.LABELS = _n.DEFAULT_LABEL_SETTINGS = void 0;
_n.DEFAULT_LABEL_SETTINGS = {
  porn: "hide",
  sexual: "warn",
  nudity: "ignore",
  "graphic-media": "warn"
};
_n.LABELS = {
  "!hide": {
    identifier: "!hide",
    configurable: !1,
    defaultSetting: "hide",
    flags: ["no-override", "no-self"],
    severity: "alert",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        displayName: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  "!warn": {
    identifier: "!warn",
    configurable: !1,
    defaultSetting: "warn",
    flags: ["no-self"],
    severity: "none",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  "!no-unauthenticated": {
    identifier: "!no-unauthenticated",
    configurable: !1,
    defaultSetting: "hide",
    flags: ["no-override", "unauthed"],
    severity: "none",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        displayName: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  porn: {
    identifier: "porn",
    configurable: !0,
    defaultSetting: "hide",
    flags: ["adult"],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  sexual: {
    identifier: "sexual",
    configurable: !0,
    defaultSetting: "warn",
    flags: ["adult"],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  nudity: {
    identifier: "nudity",
    configurable: !0,
    defaultSetting: "ignore",
    flags: [],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  "graphic-media": {
    identifier: "graphic-media",
    flags: ["adult"],
    configurable: !0,
    defaultSetting: "warn",
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  }
};
Object.defineProperty(si, "__esModule", { value: !0 });
si.ModerationDecision = void 0;
const Tr = Rr, vI = yl, Sd = _n;
var gn;
(function(t) {
  t[t.High = 0] = "High", t[t.Medium = 1] = "Medium", t[t.Low = 2] = "Low";
})(gn || (gn = {}));
class mc {
  constructor() {
    Object.defineProperty(this, "did", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "isMe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "causes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  static merge(...e) {
    const r = e.filter((u) => !!u), n = new mc();
    return r[0] && (n.did = r[0].did, n.isMe = r[0].isMe), n.causes = r.flatMap((u) => u.causes), n;
  }
  downgrade() {
    for (const e of this.causes)
      e.downgraded = !0;
    return this;
  }
  get blocked() {
    return !!this.blockCause;
  }
  get muted() {
    return !!this.muteCause;
  }
  get blockCause() {
    return this.causes.find((e) => e.type === "blocking" || e.type === "blocked-by" || e.type === "block-other");
  }
  get muteCause() {
    return this.causes.find((e) => e.type === "muted");
  }
  get labelCauses() {
    return this.causes.filter((e) => e.type === "label");
  }
  ui(e) {
    const r = new vI.ModerationUI();
    for (const n of this.causes)
      if (n.type === "blocking" || n.type === "blocked-by" || n.type === "block-other") {
        if (this.isMe)
          continue;
        (e === "profileList" || e === "contentList") && r.filters.push(n), n.downgraded || (Tr.BLOCK_BEHAVIOR[e] === "blur" ? (r.noOverride = !0, r.blurs.push(n)) : Tr.BLOCK_BEHAVIOR[e] === "alert" ? r.alerts.push(n) : Tr.BLOCK_BEHAVIOR[e] === "inform" && r.informs.push(n));
      } else if (n.type === "muted") {
        if (this.isMe)
          continue;
        (e === "profileList" || e === "contentList") && r.filters.push(n), n.downgraded || (Tr.MUTE_BEHAVIOR[e] === "blur" ? r.blurs.push(n) : Tr.MUTE_BEHAVIOR[e] === "alert" ? r.alerts.push(n) : Tr.MUTE_BEHAVIOR[e] === "inform" && r.informs.push(n));
      } else if (n.type === "mute-word") {
        if (this.isMe)
          continue;
        e === "contentList" && r.filters.push(n), n.downgraded || (Tr.MUTEWORD_BEHAVIOR[e] === "blur" ? r.blurs.push(n) : Tr.MUTEWORD_BEHAVIOR[e] === "alert" ? r.alerts.push(n) : Tr.MUTEWORD_BEHAVIOR[e] === "inform" && r.informs.push(n));
      } else n.type === "hidden" ? ((e === "profileList" || e === "contentList") && r.filters.push(n), n.downgraded || (Tr.HIDE_BEHAVIOR[e] === "blur" ? r.blurs.push(n) : Tr.HIDE_BEHAVIOR[e] === "alert" ? r.alerts.push(n) : Tr.HIDE_BEHAVIOR[e] === "inform" && r.informs.push(n))) : n.type === "label" && (e === "profileList" && n.target === "account" ? n.setting === "hide" && !this.isMe && r.filters.push(n) : e === "contentList" && (n.target === "account" || n.target === "content") && n.setting === "hide" && !this.isMe && r.filters.push(n), n.downgraded || (n.behavior[e] === "blur" ? (r.blurs.push(n), n.noOverride && !this.isMe && (r.noOverride = !0)) : n.behavior[e] === "alert" ? r.alerts.push(n) : n.behavior[e] === "inform" && r.informs.push(n)));
    return r.filters.sort(Cd), r.blurs.sort(Cd), r;
  }
  setDid(e) {
    this.did = e;
  }
  setIsMe(e) {
    this.isMe = e;
  }
  addHidden(e) {
    e && this.causes.push({
      type: "hidden",
      source: { type: "user" },
      priority: 6
    });
  }
  addMutedWord(e) {
    e && this.causes.push({
      type: "mute-word",
      source: { type: "user" },
      priority: 6
    });
  }
  addBlocking(e) {
    e && this.causes.push({
      type: "blocking",
      source: { type: "user" },
      priority: 3
    });
  }
  addBlockingByList(e) {
    e && this.causes.push({
      type: "blocking",
      source: { type: "list", list: e },
      priority: 3
    });
  }
  addBlockedBy(e) {
    e && this.causes.push({
      type: "blocked-by",
      source: { type: "user" },
      priority: 4
    });
  }
  addBlockOther(e) {
    e && this.causes.push({
      type: "block-other",
      source: { type: "user" },
      priority: 4
    });
  }
  addLabel(e, r, n) {
    const u = Tr.CUSTOM_LABEL_VALUE_RE.test(r.val) && n.labelDefs?.[r.src]?.find((_) => _.identifier === r.val) || Sd.LABELS[r.val];
    if (!u)
      return;
    const y = r.src === this.did, b = y ? void 0 : n.prefs.labelers.find((_) => _.did === r.src);
    if (!y && !b || y && u.flags.includes("no-self"))
      return;
    let h = u.defaultSetting || "ignore";
    if (u.configurable ? u.flags.includes("adult") && !n.prefs.adultContentEnabled ? h = "hide" : b?.labels[u.identifier] ? h = b?.labels[u.identifier] : n.prefs.labels[u.identifier] && (h = n.prefs.labels[u.identifier]) : h = u.defaultSetting || "hide", h === "ignore" || u.flags.includes("unauthed") && n.userDid)
      return;
    let d;
    const m = RI(u.behaviors[e]);
    u.flags.includes("no-override") || u.flags.includes("adult") && !n.prefs.adultContentEnabled ? d = 1 : h === "hide" ? d = 2 : m === gn.High ? d = 5 : m === gn.Medium ? d = 7 : d = 8;
    let p = !1;
    (u.flags.includes("no-override") || u.flags.includes("adult") && !n.prefs.adultContentEnabled) && (p = !0), this.causes.push({
      type: "label",
      source: y || !b ? { type: "user" } : { type: "labeler", did: b.did },
      label: r,
      labelDef: u,
      target: e,
      setting: h,
      behavior: u.behaviors[e] || Tr.NOOP_BEHAVIOR,
      noOverride: p,
      priority: d
    });
  }
  addMuted(e) {
    e && this.causes.push({
      type: "muted",
      source: { type: "user" },
      priority: 6
    });
  }
  addMutedByList(e) {
    e && this.causes.push({
      type: "muted",
      source: { type: "list", list: e },
      priority: 6
    });
  }
}
si.ModerationDecision = mc;
function RI(t) {
  return t ? t.profileView === "blur" || t.contentView === "blur" ? gn.High : t.contentList === "blur" || t.contentMedia === "blur" ? gn.Medium : gn.Low : gn.Low;
}
function Cd(t, e) {
  return t.priority - e.priority;
}
Object.defineProperty(ki, "__esModule", { value: !0 });
ki.filterAccountLabels = ki.decideAccount = void 0;
const AI = si;
function _I(t, e) {
  const r = new AI.ModerationDecision();
  r.setDid(t.did), r.setIsMe(t.did === e.userDid), t.viewer?.muted && (t.viewer?.mutedByList ? r.addMutedByList(t.viewer?.mutedByList) : r.addMuted(t.viewer?.muted)), t.viewer?.blocking && (t.viewer?.blockingByList ? r.addBlockingByList(t.viewer?.blockingByList) : r.addBlocking(t.viewer?.blocking)), r.addBlockedBy(t.viewer?.blockedBy);
  for (const n of N0(t.labels))
    r.addLabel("account", n, e);
  return r;
}
ki.decideAccount = _I;
function N0(t) {
  return t ? t.filter((e) => !e.uri.endsWith("/app.bsky.actor.profile/self") || e.val === "!no-unauthenticated") : [];
}
ki.filterAccountLabels = N0;
var Di = {};
Object.defineProperty(Di, "__esModule", { value: !0 });
Di.filterProfileLabels = Di.decideProfile = void 0;
const wI = si;
function TI(t, e) {
  const r = new wI.ModerationDecision();
  r.setDid(t.did), r.setIsMe(t.did === e.userDid);
  for (const n of V0(t.labels))
    r.addLabel("profile", n, e);
  return r;
}
Di.decideProfile = TI;
function V0(t) {
  return t ? t.filter((e) => e.uri.endsWith("/app.bsky.actor.profile/self")) : [];
}
Di.filterProfileLabels = V0;
var uu = {};
Object.defineProperty(uu, "__esModule", { value: !0 });
uu.decideNotification = void 0;
const Ld = si, SI = ki, CI = Di;
function LI(t, e) {
  const r = new Ld.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const n of t.labels)
      r.addLabel("content", n, e);
  return Ld.ModerationDecision.merge(r, (0, SI.decideAccount)(t.author, e), (0, CI.decideProfile)(t.author, e));
}
uu.decideNotification = LI;
var cu = {}, bl = {};
Object.defineProperty(bl, "__esModule", { value: !0 });
bl.hasMutedWord = void 0;
const kI = E, kd = {
  LEADING_TRAILING_PUNCTUATION: /(?:^\p{P}+|\p{P}+$)/gu,
  ESCAPE: /[[\]{}()*+?.\\^$|\s]/g,
  SEPARATORS: /[/\-–—()[\]_]+/g,
  WORD_BOUNDARY: /[\s\n\t\r\f\v]+?/g
}, DI = [
  "ja",
  // Japanese
  "zh",
  // Chinese
  "ko",
  // Korean
  "th",
  // Thai
  "vi"
  // Vietnamese
];
function PI({ mutedWords: t, text: e, facets: r, outlineTags: n, languages: u, actor: y }) {
  const b = DI.includes(u?.[0] || ""), h = [].concat(n || []).concat((r || []).flatMap((d) => d.features.filter(kI.AppBskyRichtextFacet.isTag).map((m) => m.tag))).map((d) => d.toLowerCase());
  for (const d of t) {
    const m = d.value.toLowerCase(), p = e.toLowerCase();
    if (d.expiresAt && d.expiresAt < (/* @__PURE__ */ new Date()).toISOString() || d.actorTarget === "exclude-following" && y?.viewer?.following)
      continue;
    if (h.includes(m))
      return !0;
    if (!d.targets.includes("content"))
      continue;
    if ((m.length === 1 || b) && p.includes(m))
      return !0;
    if (m.length > p.length)
      continue;
    if (m === p || /(?:\s|\p{P})+?/u.test(m) && p.includes(m))
      return !0;
    const _ = p.split(kd.WORD_BOUNDARY);
    for (const B of _) {
      if (B === m)
        return !0;
      const N = B.replace(kd.LEADING_TRAILING_PUNCTUATION, "");
      if (m === N)
        return !0;
      if (!(m.length > N.length) && /\p{P}+/u.test(N)) {
        const X = N.replace(/\p{P}+/gu, " ");
        if (X === m || X.replace(/\s/gu, "") === m)
          return !0;
        const re = N.split(/\p{P}+/u);
        for (const J of re)
          if (J === m)
            return !0;
      }
    }
  }
  return !1;
}
bl.hasMutedWord = PI;
Object.defineProperty(cu, "__esModule", { value: !0 });
cu.decidePost = void 0;
const Wa = si, gt = E, di = bl, j0 = ki, F0 = Di;
function BI(t, e) {
  const r = new Wa.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const u of t.labels)
      r.addLabel("content", u, e);
  r.addHidden(II(t, e.prefs.hiddenPosts)), r.isMe || r.addMutedWord(UI(t, e.prefs.mutedWords));
  let n;
  return t.embed && (gt.AppBskyEmbedRecord.isViewRecord(t.embed.record) ? n = Dd(t.embed.record, e) : gt.AppBskyEmbedRecordWithMedia.isView(t.embed) && gt.AppBskyEmbedRecord.isViewRecord(t.embed.record.record) ? n = Dd(t.embed.record.record, e) : gt.AppBskyEmbedRecord.isViewBlocked(t.embed.record) ? n = Pd(t.embed.record, e) : gt.AppBskyEmbedRecordWithMedia.isView(t.embed) && gt.AppBskyEmbedRecord.isViewBlocked(t.embed.record.record) && (n = Pd(t.embed.record.record, e))), Wa.ModerationDecision.merge(r, n?.downgrade(), (0, j0.decideAccount)(t.author, e), (0, F0.decideProfile)(t.author, e));
}
cu.decidePost = BI;
function Dd(t, e) {
  const r = new Wa.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const n of t.labels)
      r.addLabel("content", n, e);
  return Wa.ModerationDecision.merge(r, (0, j0.decideAccount)(t.author, e), (0, F0.decideProfile)(t.author, e));
}
function Pd(t, e) {
  const r = new Wa.ModerationDecision();
  return r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.author.viewer?.muted && (t.author.viewer?.mutedByList ? r.addMutedByList(t.author.viewer?.mutedByList) : r.addMuted(t.author.viewer?.muted)), t.author.viewer?.blocking && (t.author.viewer?.blockingByList ? r.addBlockingByList(t.author.viewer?.blockingByList) : r.addBlocking(t.author.viewer?.blocking)), r.addBlockedBy(t.author.viewer?.blockedBy), r;
}
function II(t, e) {
  return e?.length ? !!(e.includes(t.uri) || t.embed && (gt.AppBskyEmbedRecord.isViewRecord(t.embed.record) && e.includes(t.embed.record.uri) || gt.AppBskyEmbedRecordWithMedia.isView(t.embed) && gt.AppBskyEmbedRecord.isViewRecord(t.embed.record.record) && e.includes(t.embed.record.record.uri))) : !1;
}
function UI(t, e) {
  if (!e?.length)
    return !1;
  const r = t.author;
  if (gt.AppBskyFeedPost.isRecord(t.record)) {
    if ((0, di.hasMutedWord)({
      mutedWords: e,
      text: t.record.text,
      facets: t.record.facets,
      outlineTags: t.record.tags,
      languages: t.record.langs,
      actor: r
    }))
      return !0;
    if (t.record.embed && gt.AppBskyEmbedImages.isMain(t.record.embed)) {
      for (const n of t.record.embed.images)
        if ((0, di.hasMutedWord)({
          mutedWords: e,
          text: n.alt,
          languages: t.record.langs,
          actor: r
        }))
          return !0;
    }
  }
  if (t.embed) {
    if (gt.AppBskyEmbedRecord.isViewRecord(t.embed.record)) {
      if (gt.AppBskyFeedPost.isRecord(t.embed.record.value)) {
        const n = t.embed.record.value, u = t.embed.record.author;
        if ((0, di.hasMutedWord)({
          mutedWords: e,
          text: n.text,
          facets: n.facets,
          outlineTags: n.tags,
          languages: n.langs,
          actor: u
        }))
          return !0;
        if (gt.AppBskyEmbedImages.isMain(n.embed)) {
          for (const y of n.embed.images)
            if ((0, di.hasMutedWord)({
              mutedWords: e,
              text: y.alt,
              languages: n.langs,
              actor: u
            }))
              return !0;
        }
        if (gt.AppBskyEmbedExternal.isMain(n.embed)) {
          const { external: y } = n.embed;
          if ((0, di.hasMutedWord)({
            mutedWords: e,
            text: y.title + " " + y.description,
            languages: [],
            actor: u
          }))
            return !0;
        }
        if (gt.AppBskyEmbedRecordWithMedia.isMain(n.embed)) {
          if (gt.AppBskyEmbedExternal.isMain(n.embed.media)) {
            const { external: y } = n.embed.media;
            if ((0, di.hasMutedWord)({
              mutedWords: e,
              text: y.title + " " + y.description,
              languages: [],
              actor: u
            }))
              return !0;
          }
          if (gt.AppBskyEmbedImages.isMain(n.embed.media)) {
            for (const y of n.embed.media.images)
              if ((0, di.hasMutedWord)({
                mutedWords: e,
                text: y.alt,
                languages: gt.AppBskyFeedPost.isRecord(n.record) ? n.langs : [],
                actor: u
              }))
                return !0;
          }
        }
      }
    } else if (gt.AppBskyEmbedExternal.isView(t.embed)) {
      const { external: n } = t.embed;
      if ((0, di.hasMutedWord)({
        mutedWords: e,
        text: n.title + " " + n.description,
        languages: [],
        actor: r
      }))
        return !0;
    } else if (gt.AppBskyEmbedRecordWithMedia.isView(t.embed) && gt.AppBskyEmbedRecord.isViewRecord(t.embed.record.record)) {
      const n = t.embed.record.record.author;
      if (gt.AppBskyFeedPost.isRecord(t.embed.record.record.value)) {
        const u = t.embed.record.record.value;
        if ((0, di.hasMutedWord)({
          mutedWords: e,
          text: u.text,
          facets: u.facets,
          outlineTags: u.tags,
          languages: u.langs,
          actor: n
        }))
          return !0;
      }
      if (gt.AppBskyEmbedImages.isView(t.embed.media)) {
        for (const u of t.embed.media.images)
          if ((0, di.hasMutedWord)({
            mutedWords: e,
            text: u.alt,
            languages: gt.AppBskyFeedPost.isRecord(t.record) ? t.record.langs : [],
            actor: n
          }))
            return !0;
      }
    }
  }
  return !1;
}
var du = {};
Object.defineProperty(du, "__esModule", { value: !0 });
du.decideFeedGenerator = void 0;
const Bd = si, OI = ki, KI = Di;
function MI(t, e) {
  const r = new Bd.ModerationDecision();
  if (r.setDid(t.creator.did), r.setIsMe(t.creator.did === e.userDid), t.labels?.length)
    for (const n of t.labels)
      r.addLabel("content", n, e);
  return Bd.ModerationDecision.merge(r, (0, OI.decideAccount)(t.creator, e), (0, KI.decideProfile)(t.creator, e));
}
du.decideFeedGenerator = MI;
var fu = {};
Object.defineProperty(fu, "__esModule", { value: !0 });
fu.decideUserList = void 0;
const NI = ra, Id = si, VI = ki, jI = Di;
function FI(t, e) {
  const r = new Id.ModerationDecision(), n = $I(t.creator) ? t.creator : void 0;
  if (n) {
    if (r.setDid(n.did), r.setIsMe(n.did === e.userDid), t.labels?.length)
      for (const y of t.labels)
        r.addLabel("content", y, e);
    return Id.ModerationDecision.merge(r, (0, VI.decideAccount)(n, e), (0, jI.decideProfile)(n, e));
  }
  const u = new NI.AtUri(t.uri).hostname;
  if (r.setDid(u), r.setIsMe(u === e.userDid), t.labels?.length)
    for (const y of t.labels)
      r.addLabel("content", y, e);
  return r;
}
fu.decideUserList = FI;
function $I(t) {
  return t && typeof t == "object" && "did" in t;
}
var Ri = {};
Object.defineProperty(Ri, "__esModule", { value: !0 });
Ri.interpretLabelValueDefinitions = Ri.interpretLabelValueDefinition = Ri.isQuotedPostWithMedia = Ri.isQuotedPost = void 0;
const yc = E;
function GI(t) {
  return !!(t && yc.AppBskyEmbedRecord.isView(t));
}
Ri.isQuotedPost = GI;
function qI(t) {
  return !!(t && yc.AppBskyEmbedRecordWithMedia.isView(t));
}
Ri.isQuotedPostWithMedia = qI;
function $0(t, e) {
  const r = {
    account: {},
    profile: {},
    content: {}
  }, n = t.severity === "alert" ? "alert" : t.severity === "inform" ? "inform" : void 0;
  t.blurs === "content" ? (r.account.profileList = n, r.account.profileView = n, r.account.contentList = "blur", r.account.contentView = t.adultOnly ? "blur" : n, r.profile.profileList = n, r.profile.profileView = n, r.content.contentList = "blur", r.content.contentView = t.adultOnly ? "blur" : n) : t.blurs === "media" ? (r.account.profileList = n, r.account.profileView = n, r.account.avatar = "blur", r.account.banner = "blur", r.profile.profileList = n, r.profile.profileView = n, r.profile.avatar = "blur", r.profile.banner = "blur", r.content.contentMedia = "blur") : t.blurs === "none" && (r.account.profileList = n, r.account.profileView = n, r.account.contentList = n, r.account.contentView = n, r.profile.profileList = n, r.profile.profileView = n, r.content.contentList = n, r.content.contentView = n);
  let u = "warn";
  (t.defaultSetting === "hide" || t.defaultSetting === "ignore") && (u = t.defaultSetting);
  const y = ["no-self"];
  return t.adultOnly && y.push("adult"), {
    ...t,
    definedBy: e,
    configurable: !0,
    defaultSetting: u,
    flags: y,
    behaviors: r
  };
}
Ri.interpretLabelValueDefinition = $0;
function XI(t) {
  return (t.policies?.labelValueDefinitions || []).filter((e) => yc.ComAtprotoLabelDefs.validateLabelValueDefinition(e).success).map((e) => $0(e, t.creator.did));
}
Ri.interpretLabelValueDefinitions = XI;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.moderateUserList = t.moderateFeedGenerator = t.moderateNotification = t.moderatePost = t.moderateProfile = t.interpretLabelValueDefinitions = t.interpretLabelValueDefinition = t.hasMutedWord = t.ModerationDecision = t.ModerationUI = void 0;
  const e = ki, r = Di, n = uu, u = cu, y = du, b = fu, h = si;
  var d = yl;
  Object.defineProperty(t, "ModerationUI", { enumerable: !0, get: function() {
    return d.ModerationUI;
  } });
  var m = si;
  Object.defineProperty(t, "ModerationDecision", { enumerable: !0, get: function() {
    return m.ModerationDecision;
  } });
  var p = bl;
  Object.defineProperty(t, "hasMutedWord", { enumerable: !0, get: function() {
    return p.hasMutedWord;
  } });
  var _ = Ri;
  Object.defineProperty(t, "interpretLabelValueDefinition", { enumerable: !0, get: function() {
    return _.interpretLabelValueDefinition;
  } }), Object.defineProperty(t, "interpretLabelValueDefinitions", { enumerable: !0, get: function() {
    return _.interpretLabelValueDefinitions;
  } });
  function B(J, F) {
    return h.ModerationDecision.merge((0, e.decideAccount)(J, F), (0, r.decideProfile)(J, F));
  }
  t.moderateProfile = B;
  function N(J, F) {
    return (0, u.decidePost)(J, F);
  }
  t.moderatePost = N;
  function X(J, F) {
    return (0, n.decideNotification)(J, F);
  }
  t.moderateNotification = X;
  function te(J, F) {
    return (0, y.decideFeedGenerator)(J, F);
  }
  t.moderateFeedGenerator = te;
  function re(J, F) {
    return (0, b.decideUserList)(J, F);
  }
  t.moderateUserList = re;
})(hc);
var pu = {};
Object.defineProperty(pu, "__esModule", { value: !0 });
pu.mock = void 0;
const Ga = "bafyreiclp443lavogvhj3d2ob2cxbfuscni2k5jk7bebjzg7khl3esabwq";
pu.mock = {
  post({ text: t, facets: e, reply: r, embed: n }) {
    return {
      $type: "app.bsky.feed.post",
      text: t,
      facets: e,
      reply: r,
      embed: n,
      langs: ["en"],
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  },
  postView({ record: t, author: e, embed: r, replyCount: n, repostCount: u, likeCount: y, viewer: b, labels: h }) {
    return {
      $type: "app.bsky.feed.defs#postView",
      uri: `at://${e.did}/app.bsky.feed.post/fake`,
      cid: Ga,
      author: e,
      record: t,
      embed: r,
      replyCount: n,
      repostCount: u,
      likeCount: y,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      viewer: b,
      labels: h
    };
  },
  embedRecordView({ record: t, author: e, labels: r }) {
    return {
      $type: "app.bsky.embed.record#view",
      record: {
        $type: "app.bsky.embed.record#viewRecord",
        uri: `at://${e.did}/app.bsky.feed.post/fake`,
        cid: Ga,
        author: e,
        value: t,
        labels: r,
        indexedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
  },
  profileViewBasic({ handle: t, displayName: e, description: r, viewer: n, labels: u }) {
    return {
      did: `did:web:${t}`,
      handle: t,
      displayName: e,
      description: r,
      // technically not in ProfileViewBasic but useful in some cases
      viewer: n,
      labels: u
    };
  },
  actorViewerState({ muted: t, mutedByList: e, blockedBy: r, blocking: n, blockingByList: u, following: y, followedBy: b }) {
    return {
      muted: t,
      mutedByList: e,
      blockedBy: r,
      blocking: n,
      blockingByList: u,
      following: y,
      followedBy: b
    };
  },
  listViewBasic({ name: t }) {
    return {
      uri: "at://did:plc:fake/app.bsky.graph.list/fake",
      cid: Ga,
      name: t,
      purpose: "app.bsky.graph.defs#modlist",
      indexedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  },
  replyNotification({ author: t, record: e, labels: r }) {
    return {
      uri: `at://${t.did}/app.bsky.feed.post/fake`,
      cid: Ga,
      author: t,
      reason: "reply",
      reasonSubject: `at://${t.did}/app.bsky.feed.post/fake-parent`,
      record: e,
      isRead: !1,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      labels: r
    };
  },
  followNotification({ author: t, subjectDid: e, labels: r }) {
    return {
      uri: `at://${t.did}/app.bsky.graph.follow/fake`,
      cid: Ga,
      author: t,
      reason: "follow",
      record: {
        $type: "app.bsky.graph.follow",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        subject: e
      },
      isRead: !1,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      labels: r
    };
  },
  label({ val: t, uri: e, src: r }) {
    return {
      src: r || "did:plc:fake-labeler",
      uri: e,
      val: t,
      cts: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};
var hu = {}, bc = {}, fi = de && de.__classPrivateFieldGet || function(t, e, r, n) {
  if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}, Lu = de && de.__classPrivateFieldSet || function(t, e, r, n, u) {
  if (n === "m") throw new TypeError("Private method is not writable");
  if (n === "a" && !u) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !u : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? u.call(t, r) : u ? u.value = r : e.set(t, r), r;
}, ji, hn;
Object.defineProperty(bc, "__esModule", { value: !0 });
class zI {
  constructor() {
    ji.set(this, !1), hn.set(this, /* @__PURE__ */ new Set());
  }
  /**
   * Whether the lock is currently acquired or not. Accessing this property does not affect the
   * status of the lock.
   */
  get acquired() {
    return fi(this, ji, "f");
  }
  /**
   * Acquires the lock, waiting if necessary for it to become free if it is already locked. The
   * returned promise is fulfilled once the lock is acquired.
   *
   * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before
   * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid
   * timeout values depends on how `setTimeout` handles those values.
   *
   * After acquiring the lock, you **must** call `release` when you are done with it.
   */
  acquireAsync({ timeout: e } = {}) {
    if (!fi(this, ji, "f"))
      return Lu(this, ji, !0, "f"), Promise.resolve();
    if (e == null)
      return new Promise((u) => {
        fi(this, hn, "f").add(u);
      });
    let r, n;
    return Promise.race([
      new Promise((u) => {
        r = () => {
          clearTimeout(n), u();
        }, fi(this, hn, "f").add(r);
      }),
      new Promise((u, y) => {
        n = setTimeout(() => {
          fi(this, hn, "f").delete(r), y(new Error("Timed out waiting for lock"));
        }, e);
      })
    ]);
  }
  /**
   * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns
   * `true` if the lock was free and is now acquired, and `false` otherwise.
   *
   * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs
   * synchronously without waiting for the JavaScript task queue.
   */
  tryAcquire() {
    return fi(this, ji, "f") ? !1 : (Lu(this, ji, !0, "f"), !0);
  }
  /**
   * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer
   * must release the lock exactly once.
   */
  release() {
    if (!fi(this, ji, "f"))
      throw new Error("Cannot release an unacquired lock");
    if (fi(this, hn, "f").size > 0) {
      const [e] = fi(this, hn, "f");
      fi(this, hn, "f").delete(e), e();
    } else
      Lu(this, ji, !1, "f");
  }
}
bc.default = zI;
ji = /* @__PURE__ */ new WeakMap(), hn = /* @__PURE__ */ new WeakMap();
var HI = de && de.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(hu, "__esModule", { value: !0 });
hu.BskyAgent = void 0;
const la = ra, mn = Pi, ZI = HI(bc), WI = ka, he = E, YI = _n, yn = ti, JI = hc, Ud = {
  hideReplies: !1,
  hideRepliesByUnfollowed: !0,
  hideRepliesByLikeCount: 0,
  hideReposts: !1,
  hideQuotePosts: !1
}, QI = {
  sort: "oldest",
  prioritizeFollowedUsers: !0
};
class ca extends WI.AtpAgent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_prefsLock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ZI.default()
    }), Object.defineProperty(this, "getTimeline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getTimeline(e, r)
    }), Object.defineProperty(this, "getAuthorFeed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getAuthorFeed(e, r)
    }), Object.defineProperty(this, "getActorLikes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getActorLikes(e, r)
    }), Object.defineProperty(this, "getPostThread", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getPostThread(e, r)
    }), Object.defineProperty(this, "getPost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e) => this.api.app.bsky.feed.post.get(e)
    }), Object.defineProperty(this, "getPosts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getPosts(e, r)
    }), Object.defineProperty(this, "getLikes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getLikes(e, r)
    }), Object.defineProperty(this, "getRepostedBy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getRepostedBy(e, r)
    }), Object.defineProperty(this, "getFollows", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.graph.getFollows(e, r)
    }), Object.defineProperty(this, "getFollowers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.graph.getFollowers(e, r)
    }), Object.defineProperty(this, "getProfile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getProfile(e, r)
    }), Object.defineProperty(this, "getProfiles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getProfiles(e, r)
    }), Object.defineProperty(this, "getSuggestions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getSuggestions(e, r)
    }), Object.defineProperty(this, "searchActors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.searchActors(e, r)
    }), Object.defineProperty(this, "searchActorsTypeahead", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.searchActorsTypeahead(e, r)
    }), Object.defineProperty(this, "listNotifications", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.notification.listNotifications(e, r)
    }), Object.defineProperty(this, "countUnreadNotifications", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.notification.getUnreadCount(e, r)
    }), Object.defineProperty(this, "getLabelers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.labeler.getServices(e, r)
    });
  }
  clone() {
    const e = new ca({
      service: this.service
    });
    return this.copyInto(e), e;
  }
  get app() {
    return this.api.app;
  }
  async getLabelDefinitions(e) {
    let r = ca.appLabelers;
    rU(e) ? r = r.concat(e.moderationPrefs.labelers.map((y) => y.did)) : G0(e) ? r = r.concat(e.labelers.map((y) => y.did)) : r = r.concat(e);
    const n = await this.getLabelers({
      dids: r,
      detailed: !0
    }), u = {};
    if (n.data)
      for (const y of n.data.views)
        u[y.creator.did] = (0, JI.interpretLabelValueDefinitions)(y);
    return u;
  }
  async post(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return e.createdAt = e.createdAt || (/* @__PURE__ */ new Date()).toISOString(), this.api.app.bsky.feed.post.create({ repo: this.session.did }, e);
  }
  async deletePost(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new la.AtUri(e);
    return await this.api.app.bsky.feed.post.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async like(e, r) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
      subject: { uri: e, cid: r },
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteLike(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new la.AtUri(e);
    return await this.api.app.bsky.feed.like.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async repost(e, r) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
      subject: { uri: e, cid: r },
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteRepost(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new la.AtUri(e);
    return await this.api.app.bsky.feed.repost.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async follow(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
      subject: e,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteFollow(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new la.AtUri(e);
    return await this.api.app.bsky.graph.follow.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async upsertProfile(e) {
    if (!this.session)
      throw new Error("Not logged in");
    let r = 5;
    for (; r >= 0; ) {
      const n = await this.com.atproto.repo.getRecord({
        repo: this.session.did,
        collection: "app.bsky.actor.profile",
        rkey: "self"
      }).catch((b) => {
      }), u = await e(n?.data.value);
      u && (u.$type = "app.bsky.actor.profile");
      const y = he.AppBskyActorProfile.validateRecord(u);
      if (!y.success)
        throw y.error;
      try {
        await this.com.atproto.repo.putRecord({
          repo: this.session.did,
          collection: "app.bsky.actor.profile",
          rkey: "self",
          record: u,
          swapRecord: n?.data.cid || null
        });
      } catch (b) {
        if (r > 0 && b instanceof he.ComAtprotoRepoPutRecord.InvalidSwapError) {
          r--;
          continue;
        } else
          throw b;
      }
      break;
    }
  }
  async mute(e) {
    return this.api.app.bsky.graph.muteActor({ actor: e });
  }
  async unmute(e) {
    return this.api.app.bsky.graph.unmuteActor({ actor: e });
  }
  async muteModList(e) {
    return this.api.app.bsky.graph.muteActorList({
      list: e
    });
  }
  async unmuteModList(e) {
    return this.api.app.bsky.graph.unmuteActorList({
      list: e
    });
  }
  async blockModList(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
      subject: e,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async unblockModList(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = await this.api.app.bsky.graph.getList({
      list: e,
      limit: 1
    });
    if (!r.data.list.viewer?.blocked)
      return;
    const { rkey: n } = new la.AtUri(r.data.list.viewer.blocked);
    return await this.api.app.bsky.graph.listblock.delete({
      repo: this.session.did,
      rkey: n
    });
  }
  async updateSeenNotifications(e) {
    return e = e || (/* @__PURE__ */ new Date()).toISOString(), this.api.app.bsky.notification.updateSeen({
      seenAt: e
    });
  }
  async getPreferences() {
    const e = {
      feeds: {
        saved: void 0,
        pinned: void 0
      },
      // @ts-ignore populating below
      savedFeeds: void 0,
      feedViewPrefs: {
        home: {
          ...Ud
        }
      },
      threadViewPrefs: { ...QI },
      moderationPrefs: {
        adultContentEnabled: !1,
        labels: { ...YI.DEFAULT_LABEL_SETTINGS },
        labelers: ca.appLabelers.map((u) => ({ did: u, labels: {} })),
        mutedWords: [],
        hiddenPosts: []
      },
      birthDate: void 0,
      interests: {
        tags: []
      },
      bskyAppState: {
        queuedNudges: [],
        activeProgressGuide: void 0
      }
    }, r = await this.app.bsky.actor.getPreferences({}), n = [];
    for (const u of r.data.preferences)
      if (he.AppBskyActorDefs.isAdultContentPref(u) && he.AppBskyActorDefs.validateAdultContentPref(u).success)
        e.moderationPrefs.adultContentEnabled = u.enabled;
      else if (he.AppBskyActorDefs.isContentLabelPref(u) && he.AppBskyActorDefs.validateContentLabelPref(u).success) {
        const y = eU(u);
        n.push(y);
      } else if (he.AppBskyActorDefs.isLabelersPref(u) && he.AppBskyActorDefs.validateLabelersPref(u).success)
        e.moderationPrefs.labelers = ca.appLabelers.map((y) => ({ did: y, labels: {} })).concat(u.labelers.map((y) => ({
          ...y,
          labels: {}
        })));
      else if (he.AppBskyActorDefs.isSavedFeedsPrefV2(u) && he.AppBskyActorDefs.validateSavedFeedsPrefV2(u).success)
        e.savedFeeds = u.items;
      else if (he.AppBskyActorDefs.isSavedFeedsPref(u) && he.AppBskyActorDefs.validateSavedFeedsPref(u).success)
        e.feeds.saved = u.saved, e.feeds.pinned = u.pinned;
      else if (he.AppBskyActorDefs.isPersonalDetailsPref(u) && he.AppBskyActorDefs.validatePersonalDetailsPref(u).success)
        u.birthDate && (e.birthDate = new Date(u.birthDate));
      else if (he.AppBskyActorDefs.isFeedViewPref(u) && he.AppBskyActorDefs.validateFeedViewPref(u).success) {
        const { $type: y, feed: b, ...h } = u;
        e.feedViewPrefs[u.feed] = { ...Ud, ...h };
      } else if (he.AppBskyActorDefs.isThreadViewPref(u) && he.AppBskyActorDefs.validateThreadViewPref(u).success) {
        const { $type: y, ...b } = u;
        e.threadViewPrefs = { ...e.threadViewPrefs, ...b };
      } else if (he.AppBskyActorDefs.isInterestsPref(u) && he.AppBskyActorDefs.validateInterestsPref(u).success) {
        const { $type: y, ...b } = u;
        e.interests = { ...e.interests, ...b };
      } else if (he.AppBskyActorDefs.isMutedWordsPref(u) && he.AppBskyActorDefs.validateMutedWordsPref(u).success) {
        const { $type: y, ...b } = u;
        e.moderationPrefs.mutedWords = b.items, e.moderationPrefs.mutedWords.length && (e.moderationPrefs.mutedWords = e.moderationPrefs.mutedWords.map((h) => (h.actorTarget = h.actorTarget || "all", h)));
      } else if (he.AppBskyActorDefs.isHiddenPostsPref(u) && he.AppBskyActorDefs.validateHiddenPostsPref(u).success) {
        const { $type: y, ...b } = u;
        e.moderationPrefs.hiddenPosts = b.items;
      } else if (he.AppBskyActorDefs.isBskyAppStatePref(u) && he.AppBskyActorDefs.validateBskyAppStatePref(u).success) {
        const { $type: y, ...b } = u;
        e.bskyAppState.queuedNudges = b.queuedNudges || [], e.bskyAppState.activeProgressGuide = b.activeProgressGuide;
      }
    if (e.savedFeeds === void 0) {
      const { saved: u, pinned: y } = e.feeds;
      if (u && y) {
        const b = /* @__PURE__ */ new Map();
        b.set("timeline", {
          id: mn.TID.nextStr(),
          type: "timeline",
          value: "following",
          pinned: !0
        });
        for (const h of y) {
          const d = (0, yn.getSavedFeedType)(h);
          d !== "unknown" && b.set(h, {
            id: mn.TID.nextStr(),
            type: d,
            value: h,
            pinned: !0
          });
        }
        for (const h of u)
          if (!b.has(h)) {
            const d = (0, yn.getSavedFeedType)(h);
            if (d === "unknown")
              continue;
            b.set(h, {
              id: mn.TID.nextStr(),
              type: d,
              value: h,
              pinned: !1
            });
          }
        e.savedFeeds = Array.from(b.values());
      } else
        e.savedFeeds = [
          {
            id: mn.TID.nextStr(),
            type: "timeline",
            value: "following",
            pinned: !0
          }
        ];
      await this.overwriteSavedFeeds(e.savedFeeds);
    }
    for (const u of n)
      if (u.labelerDid) {
        const y = e.moderationPrefs.labelers.find((b) => b.did === u.labelerDid);
        if (!y)
          continue;
        y.labels[u.label] = u.visibility;
      } else
        e.moderationPrefs.labels[u.label] = u.visibility;
    return e.moderationPrefs.labels = tU(e.moderationPrefs.labels), this.configureLabelersHeader(ku(r.data.preferences)), e;
  }
  async overwriteSavedFeeds(e) {
    e.forEach(yn.validateSavedFeed);
    const r = /* @__PURE__ */ new Map();
    return e.forEach((n) => {
      r.has(n.id) && r.delete(n.id), r.set(n.id, n);
    }), Ll(this, () => Array.from(r.values()));
  }
  async updateSavedFeeds(e) {
    return e.map(yn.validateSavedFeed), Ll(this, (r) => r.map((n) => {
      const u = e.find((y) => n.id === y.id);
      return u ? {
        ...n,
        // only update pinned
        pinned: u.pinned
      } : n;
    }));
  }
  async addSavedFeeds(e) {
    const r = e.map((n) => ({
      ...n,
      id: mn.TID.nextStr()
    }));
    return r.forEach(yn.validateSavedFeed), Ll(this, (n) => [
      ...n,
      ...r
    ]);
  }
  async removeSavedFeeds(e) {
    return Ll(this, (r) => [
      ...r.filter((n) => !e.find((u) => n.id === u))
    ]);
  }
  /**
   * @deprecated use `overwriteSavedFeeds`
   */
  async setSavedFeeds(e, r) {
    return qa(this, () => ({
      saved: e,
      pinned: r
    }));
  }
  /**
   * @deprecated use `addSavedFeeds`
   */
  async addSavedFeed(e) {
    return qa(this, (r, n) => ({
      saved: [...r.filter((u) => u !== e), e],
      pinned: n
    }));
  }
  /**
   * @deprecated use `removeSavedFeeds`
   */
  async removeSavedFeed(e) {
    return qa(this, (r, n) => ({
      saved: r.filter((u) => u !== e),
      pinned: n.filter((u) => u !== e)
    }));
  }
  /**
   * @deprecated use `addSavedFeeds` or `updateSavedFeeds`
   */
  async addPinnedFeed(e) {
    return qa(this, (r, n) => ({
      saved: [...r.filter((u) => u !== e), e],
      pinned: [...n.filter((u) => u !== e), e]
    }));
  }
  /**
   * @deprecated use `updateSavedFeeds` or `removeSavedFeeds`
   */
  async removePinnedFeed(e) {
    return qa(this, (r, n) => ({
      saved: r,
      pinned: n.filter((u) => u !== e)
    }));
  }
  async setAdultContentEnabled(e) {
    await ar(this, (r) => {
      let n = r.findLast((u) => he.AppBskyActorDefs.isAdultContentPref(u) && he.AppBskyActorDefs.validateAdultContentPref(u).success);
      return n ? n.enabled = e : n = {
        $type: "app.bsky.actor.defs#adultContentPref",
        enabled: e
      }, r.filter((u) => !he.AppBskyActorDefs.isAdultContentPref(u)).concat([n]);
    });
  }
  async setContentLabelPref(e, r, n) {
    n && (0, la.ensureValidDid)(n), await ar(this, (u) => {
      let y = u.findLast((h) => he.AppBskyActorDefs.isContentLabelPref(h) && he.AppBskyActorDefs.validateContentLabelPref(h).success && h.label === e && h.labelerDid === n), b;
      if (y ? y.visibility = r : y = {
        $type: "app.bsky.actor.defs#contentLabelPref",
        label: e,
        labelerDid: n,
        visibility: r
      }, he.AppBskyActorDefs.isContentLabelPref(y) && !y.labelerDid) {
        const h = {
          "graphic-media": "gore",
          porn: "nsfw",
          sexual: "suggestive"
        }[y.label];
        h && (b = u.findLast((d) => he.AppBskyActorDefs.isContentLabelPref(d) && he.AppBskyActorDefs.validateContentLabelPref(d).success && d.label === h && d.labelerDid === void 0), b ? b.visibility = r : b = {
          $type: "app.bsky.actor.defs#contentLabelPref",
          label: h,
          labelerDid: void 0,
          visibility: r
        });
      }
      return u.filter((h) => !he.AppBskyActorDefs.isContentLabelPref(h) || !(h.label === e && h.labelerDid === n)).concat([y]).filter((h) => b ? !he.AppBskyActorDefs.isContentLabelPref(h) || !(h.label === b.label && h.labelerDid === void 0) : !0).concat(b ? [b] : []);
    });
  }
  async addLabeler(e) {
    const r = await ar(this, (n) => {
      let u = n.findLast((y) => he.AppBskyActorDefs.isLabelersPref(y) && he.AppBskyActorDefs.validateLabelersPref(y).success);
      if (u || (u = {
        $type: "app.bsky.actor.defs#labelersPref",
        labelers: []
      }), he.AppBskyActorDefs.isLabelersPref(u)) {
        let y = u.labelers.find((b) => b.did === e);
        y || (y = {
          did: e
        }, u.labelers.push(y));
      }
      return n.filter((y) => !he.AppBskyActorDefs.isLabelersPref(y)).concat([u]);
    });
    this.configureLabelersHeader(ku(r));
  }
  async removeLabeler(e) {
    const r = await ar(this, (n) => {
      let u = n.findLast((y) => he.AppBskyActorDefs.isLabelersPref(y) && he.AppBskyActorDefs.validateLabelersPref(y).success);
      return u || (u = {
        $type: "app.bsky.actor.defs#labelersPref",
        labelers: []
      }), he.AppBskyActorDefs.isLabelersPref(u) && (u.labelers = u.labelers.filter((y) => y.did !== e)), n.filter((y) => !he.AppBskyActorDefs.isLabelersPref(y)).concat([u]);
    });
    this.configureLabelersHeader(ku(r));
  }
  async setPersonalDetails({ birthDate: e }) {
    e = e instanceof Date ? e.toISOString() : e, await ar(this, (r) => {
      let n = r.findLast((u) => he.AppBskyActorDefs.isPersonalDetailsPref(u) && he.AppBskyActorDefs.validatePersonalDetailsPref(u).success);
      return n ? n.birthDate = e : n = {
        $type: "app.bsky.actor.defs#personalDetailsPref",
        birthDate: e
      }, r.filter((u) => !he.AppBskyActorDefs.isPersonalDetailsPref(u)).concat([n]);
    });
  }
  async setFeedViewPrefs(e, r) {
    await ar(this, (n) => {
      const u = n.findLast((y) => he.AppBskyActorDefs.isFeedViewPref(y) && he.AppBskyActorDefs.validateFeedViewPref(y).success && y.feed === e);
      return u && (r = { ...u, ...r }), n.filter((y) => !he.AppBskyActorDefs.isFeedViewPref(r) || y.feed !== e).concat([{ ...r, $type: "app.bsky.actor.defs#feedViewPref", feed: e }]);
    });
  }
  async setThreadViewPrefs(e) {
    await ar(this, (r) => {
      const n = r.findLast((u) => he.AppBskyActorDefs.isThreadViewPref(u) && he.AppBskyActorDefs.validateThreadViewPref(u).success);
      return n && (e = { ...n, ...e }), r.filter((u) => !he.AppBskyActorDefs.isThreadViewPref(u)).concat([{ ...e, $type: "app.bsky.actor.defs#threadViewPref" }]);
    });
  }
  async setInterestsPref(e) {
    await ar(this, (r) => {
      const n = r.findLast((u) => he.AppBskyActorDefs.isInterestsPref(u) && he.AppBskyActorDefs.validateInterestsPref(u).success);
      return n && (e = { ...n, ...e }), r.filter((u) => !he.AppBskyActorDefs.isInterestsPref(u)).concat([{ ...e, $type: "app.bsky.actor.defs#interestsPref" }]);
    });
  }
  /**
   * Add a muted word to user preferences.
   */
  async addMutedWord(e) {
    const r = (0, yn.sanitizeMutedWordValue)(e.value);
    r && await ar(this, (n) => {
      let u = n.findLast((b) => he.AppBskyActorDefs.isMutedWordsPref(b) && he.AppBskyActorDefs.validateMutedWordsPref(b).success);
      const y = {
        id: mn.TID.nextStr(),
        value: r,
        targets: e.targets || [],
        actorTarget: e.actorTarget || "all",
        expiresAt: e.expiresAt || void 0
      };
      return u && he.AppBskyActorDefs.isMutedWordsPref(u) ? (u.items.push(y), u.items = Du(u.items)) : u = {
        items: [y]
      }, n.filter((b) => !he.AppBskyActorDefs.isMutedWordsPref(b)).concat([
        { ...u, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ]);
    });
  }
  /**
   * Convenience method to add muted words to user preferences
   */
  async addMutedWords(e) {
    await Promise.all(e.map((r) => this.addMutedWord(r)));
  }
  /**
   * @deprecated use `addMutedWords` or `addMutedWord` instead
   */
  async upsertMutedWords(e) {
    await this.addMutedWords(e);
  }
  /**
   * Update a muted word in user preferences.
   */
  async updateMutedWord(e) {
    await ar(this, (r) => {
      const n = r.findLast((u) => he.AppBskyActorDefs.isMutedWordsPref(u) && he.AppBskyActorDefs.validateMutedWordsPref(u).success);
      return n && he.AppBskyActorDefs.isMutedWordsPref(n) ? (n.items = n.items.map((u) => {
        if (Kd(u, e)) {
          const b = {
            ...u,
            ...e
          };
          return {
            id: u.id || mn.TID.nextStr(),
            value: (0, yn.sanitizeMutedWordValue)(b.value) || u.value,
            targets: b.targets || [],
            actorTarget: b.actorTarget || "all",
            expiresAt: b.expiresAt || void 0
          };
        } else
          return u;
      }), n.items = Du(n.items), r.filter((u) => !he.AppBskyActorDefs.isMutedWordsPref(u)).concat([
        { ...n, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ])) : r;
    });
  }
  /**
   * Remove a muted word from user preferences.
   */
  async removeMutedWord(e) {
    await ar(this, (r) => {
      const n = r.findLast((u) => he.AppBskyActorDefs.isMutedWordsPref(u) && he.AppBskyActorDefs.validateMutedWordsPref(u).success);
      if (n && he.AppBskyActorDefs.isMutedWordsPref(n)) {
        for (let u = 0; u < n.items.length; u++)
          if (Kd(n.items[u], e)) {
            n.items.splice(u, 1);
            break;
          }
        return n.items = Du(n.items), r.filter((u) => !he.AppBskyActorDefs.isMutedWordsPref(u)).concat([
          { ...n, $type: "app.bsky.actor.defs#mutedWordsPref" }
        ]);
      }
      return r;
    });
  }
  /**
   * Convenience method to remove muted words from user preferences
   */
  async removeMutedWords(e) {
    await Promise.all(e.map((r) => this.removeMutedWord(r)));
  }
  async hidePost(e) {
    await Od(this, e, "hide");
  }
  async unhidePost(e) {
    await Od(this, e, "unhide");
  }
  async bskyAppQueueNudges(e) {
    await ar(this, (r) => {
      let n = r.findLast((u) => he.AppBskyActorDefs.isBskyAppStatePref(u) && he.AppBskyActorDefs.validateBskyAppStatePref(u).success);
      return n = n || {}, e = Array.isArray(e) ? e : [e], n.queuedNudges = (n.queuedNudges || []).concat(e), r.filter((u) => !he.AppBskyActorDefs.isBskyAppStatePref(u)).concat([
        {
          ...n,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
  async bskyAppDismissNudges(e) {
    await ar(this, (r) => {
      let n = r.findLast((u) => he.AppBskyActorDefs.isBskyAppStatePref(u) && he.AppBskyActorDefs.validateBskyAppStatePref(u).success);
      return n = n || {}, e = Array.isArray(e) ? e : [e], n.queuedNudges = (n.queuedNudges || []).filter((u) => !e.includes(u)), r.filter((u) => !he.AppBskyActorDefs.isBskyAppStatePref(u)).concat([
        {
          ...n,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
  async bskyAppSetActiveProgressGuide(e) {
    if (e && !he.AppBskyActorDefs.validateBskyAppProgressGuide(e).success)
      throw new Error("Invalid progress guide");
    await ar(this, (r) => {
      let n = r.findLast((u) => he.AppBskyActorDefs.isBskyAppStatePref(u) && he.AppBskyActorDefs.validateBskyAppStatePref(u).success);
      return n = n || {}, n.activeProgressGuide = e, r.filter((u) => !he.AppBskyActorDefs.isBskyAppStatePref(u)).concat([
        {
          ...n,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
}
hu.BskyAgent = ca;
async function ar(t, e) {
  try {
    await t._prefsLock.acquireAsync();
    const r = await t.app.bsky.actor.getPreferences({}), n = e(r.data.preferences);
    return n === !1 ? r.data.preferences : (await t.app.bsky.actor.putPreferences({
      preferences: n
    }), n);
  } finally {
    t._prefsLock.release();
  }
}
async function qa(t, e) {
  let r;
  return await ar(t, (n) => {
    let u = n.findLast((y) => he.AppBskyActorDefs.isSavedFeedsPref(y) && he.AppBskyActorDefs.validateSavedFeedsPref(y).success);
    return u ? (r = e(u.saved, u.pinned), u.saved = r.saved, u.pinned = r.pinned) : (r = e([], []), u = {
      $type: "app.bsky.actor.defs#savedFeedsPref",
      saved: r.saved,
      pinned: r.pinned
    }), n.filter((y) => !he.AppBskyActorDefs.isSavedFeedsPref(y)).concat([u]);
  }), r;
}
async function Ll(t, e) {
  let r = [];
  return await ar(t, (n) => {
    let u = n.findLast((m) => he.AppBskyActorDefs.isSavedFeedsPrefV2(m) && he.AppBskyActorDefs.validateSavedFeedsPrefV2(m).success), y = n.findLast((m) => he.AppBskyActorDefs.isSavedFeedsPref(m) && he.AppBskyActorDefs.validateSavedFeedsPref(m).success);
    u ? (r = e(u.items), u = {
      ...u,
      items: r
    }) : (r = e([]), u = {
      $type: "app.bsky.actor.defs#savedFeedsPrefV2",
      items: r
    });
    const b = u.items.filter((m) => m.pinned), h = u.items.filter((m) => !m.pinned);
    u.items = b.concat(h);
    let d = n.filter((m) => !he.AppBskyActorDefs.isSavedFeedsPrefV2(m)).concat(u);
    if (y) {
      const { saved: m, pinned: p } = y, _ = (0, yn.savedFeedsToUriArrays)(
        // v1 only supports feeds and lists
        u.items.filter((B) => ["feed", "list"].includes(B.type))
      );
      y = {
        ...y,
        saved: Array.from(/* @__PURE__ */ new Set([...m, ..._.saved])),
        pinned: Array.from(/* @__PURE__ */ new Set([...p, ..._.pinned]))
      }, d = d.filter((B) => !he.AppBskyActorDefs.isSavedFeedsPref(B)).concat(y);
    }
    return d;
  }), r;
}
function eU(t) {
  let e = t.visibility;
  return e === "show" && (e = "ignore"), { ...t, visibility: e };
}
function tU(t) {
  const e = { ...t }, r = {
    gore: "graphic-media",
    nsfw: "porn",
    suggestive: "sexual"
  };
  for (const n in e) {
    const u = r[n];
    u && (e[u] = e[n]);
  }
  return e;
}
function ku(t) {
  const e = t.findLast((n) => he.AppBskyActorDefs.isLabelersPref(n) && he.AppBskyActorDefs.validateLabelersPref(n).success);
  let r = [];
  return e && (r = e.labelers.map((n) => n.did)), r;
}
async function Od(t, e, r) {
  await ar(t, (n) => {
    let u = n.findLast((y) => he.AppBskyActorDefs.isHiddenPostsPref(y) && he.AppBskyActorDefs.validateHiddenPostsPref(y).success);
    return u && he.AppBskyActorDefs.isHiddenPostsPref(u) ? u.items = r === "hide" ? Array.from(/* @__PURE__ */ new Set([...u.items, e])) : u.items.filter((y) => y !== e) : r === "hide" && (u = {
      $type: "app.bsky.actor.defs#hiddenPostsPref",
      items: [e]
    }), n.filter((y) => !he.AppBskyActorDefs.isInterestsPref(y)).concat([{ ...u, $type: "app.bsky.actor.defs#hiddenPostsPref" }]);
  });
}
function rU(t) {
  return t && typeof t == "object" && "moderationPrefs" in t && G0(t.moderationPrefs);
}
function G0(t) {
  return t && typeof t == "object" && "labelers" in t;
}
function Du(t) {
  return t.map((e) => ({
    ...e,
    id: e.id || mn.TID.nextStr()
  }));
}
function Kd(t, e) {
  const r = t.id, n = r && r === e.id, u = !r && t.value === e.value;
  return n || u;
}
(function(t) {
  var e = de && de.__createBinding || (Object.create ? function(m, p, _, B) {
    B === void 0 && (B = _);
    var N = Object.getOwnPropertyDescriptor(p, _);
    (!N || ("get" in N ? !p.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
      return p[_];
    } }), Object.defineProperty(m, B, N);
  } : function(m, p, _, B) {
    B === void 0 && (B = _), m[B] = p[_];
  }), r = de && de.__exportStar || function(m, p) {
    for (var _ in m) _ !== "default" && !Object.prototype.hasOwnProperty.call(p, _) && e(p, m, _);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.BskyAgent = t.DEFAULT_LABEL_SETTINGS = t.LABELS = t.parseLanguage = t.jsonStringToLex = t.jsonToLex = t.stringifyLex = t.lexToJson = t.BlobRef = t.AtUri = void 0;
  var n = ra;
  Object.defineProperty(t, "AtUri", { enumerable: !0, get: function() {
    return n.AtUri;
  } });
  var u = es;
  Object.defineProperty(t, "BlobRef", { enumerable: !0, get: function() {
    return u.BlobRef;
  } }), Object.defineProperty(t, "lexToJson", { enumerable: !0, get: function() {
    return u.lexToJson;
  } }), Object.defineProperty(t, "stringifyLex", { enumerable: !0, get: function() {
    return u.stringifyLex;
  } }), Object.defineProperty(t, "jsonToLex", { enumerable: !0, get: function() {
    return u.jsonToLex;
  } }), Object.defineProperty(t, "jsonStringToLex", { enumerable: !0, get: function() {
    return u.jsonStringToLex;
  } });
  var y = Pi;
  Object.defineProperty(t, "parseLanguage", { enumerable: !0, get: function() {
    return y.parseLanguage;
  } }), r(Vf, t), r(ns, t), r(ti, t), r(E, t), r(ka, t), r(Da, t), r(ml, t), r(Ka, t), r(ai, t), r(hc, t), r(Rr, t), r(pu, t);
  var b = _n;
  Object.defineProperty(t, "LABELS", { enumerable: !0, get: function() {
    return b.LABELS;
  } }), Object.defineProperty(t, "DEFAULT_LABEL_SETTINGS", { enumerable: !0, get: function() {
    return b.DEFAULT_LABEL_SETTINGS;
  } });
  var h = hu;
  Object.defineProperty(t, "BskyAgent", { enumerable: !0, get: function() {
    return h.BskyAgent;
  } });
  var d = ka;
  Object.defineProperty(t, "default", { enumerable: !0, get: function() {
    return d.AtpAgent;
  } });
})(Xu);
const Pu = new Xu.BskyAgent({
  service: "https://api.bsky.app"
});
var q0 = { exports: {} };
(function(t, e) {
  (function(n, u) {
    t.exports = u();
  })(de, function() {
    return (
      /******/
      function(r) {
        var n = {};
        function u(y) {
          if (n[y])
            return n[y].exports;
          var b = n[y] = {
            /******/
            i: y,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return r[y].call(b.exports, b, b.exports, u), b.l = !0, b.exports;
        }
        return u.m = r, u.c = n, u.d = function(y, b, h) {
          u.o(y, b) || Object.defineProperty(y, b, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: h
            /******/
          });
        }, u.n = function(y) {
          var b = y && y.__esModule ? (
            /******/
            function() {
              return y.default;
            }
          ) : (
            /******/
            function() {
              return y;
            }
          );
          return u.d(b, "a", b), b;
        }, u.o = function(y, b) {
          return Object.prototype.hasOwnProperty.call(y, b);
        }, u.p = "/dist/", u(u.s = 8);
      }([
        /* 0 */
        /***/
        function(r, n, u) {
          u.d(n, "a", function() {
            return B;
          }), u.d(n, "b", function() {
            return N;
          });
          var y = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(X) {
            return typeof X;
          } : function(X) {
            return X && typeof Symbol == "function" && X.constructor === Symbol && X !== Symbol.prototype ? "symbol" : typeof X;
          };
          function b() {
          }
          var h = {
            trace: b,
            debug: b,
            log: b,
            warn: b,
            info: b,
            error: b
          }, d = h;
          function m(X, te) {
            return te = "[" + X + "] > " + te, te;
          }
          function p(X) {
            var te = self.console[X];
            return te ? function() {
              for (var re = arguments.length, J = Array(re), F = 0; F < re; F++)
                J[F] = arguments[F];
              J[0] && (J[0] = m(X, J[0])), te.apply(self.console, J);
            } : b;
          }
          function _(X) {
            for (var te = arguments.length, re = Array(te > 1 ? te - 1 : 0), J = 1; J < te; J++)
              re[J - 1] = arguments[J];
            re.forEach(function(F) {
              d[F] = X[F] ? X[F].bind(X) : p(F);
            });
          }
          var B = function(te) {
            if (te === !0 || (typeof te > "u" ? "undefined" : y(te)) === "object") {
              _(
                te,
                // Remove out from list here to hard-disable a log-level
                //'trace',
                "debug",
                "log",
                "info",
                "warn",
                "error"
              );
              try {
                d.log();
              } catch {
                d = h;
              }
            } else
              d = h;
          }, N = d;
        },
        /* 1 */
        /***/
        function(r, n, u) {
          n.a = {
            // fired before MediaSource is attaching to media element - data: { media }
            MEDIA_ATTACHING: "hlsMediaAttaching",
            // fired when MediaSource has been succesfully attached to media element - data: { }
            MEDIA_ATTACHED: "hlsMediaAttached",
            // fired before detaching MediaSource from media element - data: { }
            MEDIA_DETACHING: "hlsMediaDetaching",
            // fired when MediaSource has been detached from media element - data: { }
            MEDIA_DETACHED: "hlsMediaDetached",
            // fired when we buffer is going to be reset - data: { }
            BUFFER_RESET: "hlsBufferReset",
            // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
            BUFFER_CODECS: "hlsBufferCodecs",
            // fired when sourcebuffers have been created - data: { tracks : tracks }
            BUFFER_CREATED: "hlsBufferCreated",
            // fired when we append a segment to the buffer - data: { segment: segment object }
            BUFFER_APPENDING: "hlsBufferAppending",
            // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
            BUFFER_APPENDED: "hlsBufferAppended",
            // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
            BUFFER_EOS: "hlsBufferEos",
            // fired when the media buffer should be flushed - data { startOffset, endOffset }
            BUFFER_FLUSHING: "hlsBufferFlushing",
            // fired when the media buffer has been flushed - data: { }
            BUFFER_FLUSHED: "hlsBufferFlushed",
            // fired to signal that a manifest loading starts - data: { url : manifestURL}
            MANIFEST_LOADING: "hlsManifestLoading",
            // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
            MANIFEST_LOADED: "hlsManifestLoaded",
            // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
            MANIFEST_PARSED: "hlsManifestParsed",
            // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING
            LEVEL_SWITCH: "hlsLevelSwitch",
            // fired when a level switch is requested - data: { level : id of new level }
            LEVEL_SWITCHING: "hlsLevelSwitching",
            // fired when a level switch is effective - data: { level : id of new level }
            LEVEL_SWITCHED: "hlsLevelSwitched",
            // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
            LEVEL_LOADING: "hlsLevelLoading",
            // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
            LEVEL_LOADED: "hlsLevelLoaded",
            // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
            LEVEL_UPDATED: "hlsLevelUpdated",
            // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
            LEVEL_PTS_UPDATED: "hlsLevelPtsUpdated",
            // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
            AUDIO_TRACKS_UPDATED: "hlsAudioTracksUpdated",
            // fired when an audio track switch occurs - data: { id : audio track id } // deprecated in favor AUDIO_TRACK_SWITCHING
            AUDIO_TRACK_SWITCH: "hlsAudioTrackSwitch",
            // fired when an audio track switching is requested - data: { id : audio track id }
            AUDIO_TRACK_SWITCHING: "hlsAudioTrackSwitching",
            // fired when an audio track switch actually occurs - data: { id : audio track id }
            AUDIO_TRACK_SWITCHED: "hlsAudioTrackSwitched",
            // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
            AUDIO_TRACK_LOADING: "hlsAudioTrackLoading",
            // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
            AUDIO_TRACK_LOADED: "hlsAudioTrackLoaded",
            // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
            SUBTITLE_TRACKS_UPDATED: "hlsSubtitleTracksUpdated",
            // fired when an subtitle track switch occurs - data: { id : subtitle track id }
            SUBTITLE_TRACK_SWITCH: "hlsSubtitleTrackSwitch",
            // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
            SUBTITLE_TRACK_LOADING: "hlsSubtitleTrackLoading",
            // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
            SUBTITLE_TRACK_LOADED: "hlsSubtitleTrackLoaded",
            // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
            SUBTITLE_FRAG_PROCESSED: "hlsSubtitleFragProcessed",
            // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
            INIT_PTS_FOUND: "hlsInitPtsFound",
            // fired when a fragment loading starts - data: { frag : fragment object }
            FRAG_LOADING: "hlsFragLoading",
            // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
            FRAG_LOAD_PROGRESS: "hlsFragLoadProgress",
            // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
            FRAG_LOAD_EMERGENCY_ABORTED: "hlsFragLoadEmergencyAborted",
            // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
            FRAG_LOADED: "hlsFragLoaded",
            // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
            FRAG_DECRYPTED: "hlsFragDecrypted",
            // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
            FRAG_PARSING_INIT_SEGMENT: "hlsFragParsingInitSegment",
            // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
            FRAG_PARSING_USERDATA: "hlsFragParsingUserdata",
            // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
            FRAG_PARSING_METADATA: "hlsFragParsingMetadata",
            // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
            FRAG_PARSING_DATA: "hlsFragParsingData",
            // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
            FRAG_PARSED: "hlsFragParsed",
            // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
            FRAG_BUFFERED: "hlsFragBuffered",
            // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
            FRAG_CHANGED: "hlsFragChanged",
            // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
            FPS_DROP: "hlsFpsDrop",
            //triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
            FPS_DROP_LEVEL_CAPPING: "hlsFpsDropLevelCapping",
            // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
            ERROR: "hlsError",
            // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
            DESTROYING: "hlsDestroying",
            // fired when a decrypt key loading starts - data: { frag : fragment object }
            KEY_LOADING: "hlsKeyLoading",
            // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
            KEY_LOADED: "hlsKeyLoaded",
            // fired upon stream controller state transitions - data: { previousState, nextState }
            STREAM_STATE_TRANSITION: "hlsStreamStateTransition"
          };
        },
        /* 2 */
        /***/
        function(r, n, u) {
          u.d(n, "b", function() {
            return y;
          }), u.d(n, "a", function() {
            return b;
          });
          var y = {
            // Identifier for a network error (loading error / timeout ...)
            NETWORK_ERROR: "networkError",
            // Identifier for a media Error (video/parsing/mediasource error)
            MEDIA_ERROR: "mediaError",
            // Identifier for a mux Error (demuxing/remuxing)
            MUX_ERROR: "muxError",
            // Identifier for all other errors
            OTHER_ERROR: "otherError"
          }, b = {
            // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            MANIFEST_LOAD_ERROR: "manifestLoadError",
            // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            MANIFEST_LOAD_TIMEOUT: "manifestLoadTimeOut",
            // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
            MANIFEST_PARSING_ERROR: "manifestParsingError",
            // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
            MANIFEST_INCOMPATIBLE_CODECS_ERROR: "manifestIncompatibleCodecsError",
            // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            LEVEL_LOAD_ERROR: "levelLoadError",
            // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            LEVEL_LOAD_TIMEOUT: "levelLoadTimeOut",
            // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
            LEVEL_SWITCH_ERROR: "levelSwitchError",
            // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            AUDIO_TRACK_LOAD_ERROR: "audioTrackLoadError",
            // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            AUDIO_TRACK_LOAD_TIMEOUT: "audioTrackLoadTimeOut",
            // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
            FRAG_LOAD_ERROR: "fragLoadError",
            // Identifier for fragment loop loading error - data: { frag : fragment object}
            FRAG_LOOP_LOADING_ERROR: "fragLoopLoadingError",
            // Identifier for fragment load timeout error - data: { frag : fragment object}
            FRAG_LOAD_TIMEOUT: "fragLoadTimeOut",
            // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
            FRAG_DECRYPT_ERROR: "fragDecryptError",
            // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
            // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
            FRAG_PARSING_ERROR: "fragParsingError",
            // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
            REMUX_ALLOC_ERROR: "remuxAllocError",
            // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
            KEY_LOAD_ERROR: "keyLoadError",
            // Identifier for decrypt key load timeout error - data: { frag : fragment object}
            KEY_LOAD_TIMEOUT: "keyLoadTimeOut",
            // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
            BUFFER_ADD_CODEC_ERROR: "bufferAddCodecError",
            // Identifier for a buffer append error - data: append error description
            BUFFER_APPEND_ERROR: "bufferAppendError",
            // Identifier for a buffer appending error event - data: appending error description
            BUFFER_APPENDING_ERROR: "bufferAppendingError",
            // Identifier for a buffer stalled error event
            BUFFER_STALLED_ERROR: "bufferStalledError",
            // Identifier for a buffer full event
            BUFFER_FULL_ERROR: "bufferFullError",
            // Identifier for a buffer seek over hole event
            BUFFER_SEEK_OVER_HOLE: "bufferSeekOverHole",
            // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
            BUFFER_NUDGE_ON_STALL: "bufferNudgeOnStall",
            // Identifier for an internal exception happening inside hls.js while handling an event
            INTERNAL_EXCEPTION: "internalException"
          };
        },
        /* 3 */
        /***/
        function(r, n, u) {
          u.d(n, "b", function() {
            return h;
          });
          function y(d, m) {
            if (!(d instanceof m))
              throw new TypeError("Cannot call a class as a function");
          }
          var b = function() {
            function d() {
              y(this, d);
            }
            return d.isHeader = function(p, _) {
              return _ + 10 <= p.length && p[_] === 73 && p[_ + 1] === 68 && p[_ + 2] === 51 && p[_ + 3] < 255 && p[_ + 4] < 255 && p[_ + 6] < 128 && p[_ + 7] < 128 && p[_ + 8] < 128 && p[_ + 9] < 128;
            }, d.isFooter = function(p, _) {
              return _ + 10 <= p.length && p[_] === 51 && p[_ + 1] === 68 && p[_ + 2] === 73 && p[_ + 3] < 255 && p[_ + 4] < 255 && p[_ + 6] < 128 && p[_ + 7] < 128 && p[_ + 8] < 128 && p[_ + 9] < 128;
            }, d.getID3Data = function(p, _) {
              for (var B = _, N = 0; d.isHeader(p, _); ) {
                N += 10;
                var X = d._readSize(p, _ + 6);
                N += X, d.isFooter(p, _ + 10) && (N += 10), _ += N;
              }
              if (N > 0)
                return p.subarray(B, B + N);
            }, d._readSize = function(p, _) {
              var B = 0;
              return B = (p[_] & 127) << 21, B |= (p[_ + 1] & 127) << 14, B |= (p[_ + 2] & 127) << 7, B |= p[_ + 3] & 127, B;
            }, d.getTimeStamp = function(p) {
              for (var _ = d.getID3Frames(p), B = 0; B < _.length; B++) {
                var N = _[B];
                if (d.isTimeStampFrame(N))
                  return d._readTimeStamp(N);
              }
            }, d.isTimeStampFrame = function(p) {
              return p && p.key === "PRIV" && p.info === "com.apple.streaming.transportStreamTimestamp";
            }, d._getFrameData = function(p) {
              var _ = String.fromCharCode(p[0], p[1], p[2], p[3]), B = d._readSize(p, 4), N = 10;
              return { type: _, size: B, data: p.subarray(N, N + B) };
            }, d.getID3Frames = function(p) {
              for (var _ = 0, B = []; d.isHeader(p, _); ) {
                var N = d._readSize(p, _ + 6);
                _ += 10;
                for (var X = _ + N; _ + 8 < X; ) {
                  var te = d._getFrameData(p.subarray(_)), re = d._decodeFrame(te);
                  re && B.push(re), _ += te.size + 10;
                }
                d.isFooter(p, _) && (_ += 10);
              }
              return B;
            }, d._decodeFrame = function(p) {
              if (p.type === "PRIV")
                return d._decodePrivFrame(p);
              if (p.type[0] === "T")
                return d._decodeTextFrame(p);
              if (p.type[0] === "W")
                return d._decodeURLFrame(p);
            }, d._readTimeStamp = function(p) {
              if (p.data.byteLength === 8) {
                var _ = new Uint8Array(p.data), B = _[3] & 1, N = (_[4] << 23) + (_[5] << 15) + (_[6] << 7) + _[7];
                return N /= 45, B && (N += 4772185884e-2), Math.round(N);
              }
            }, d._decodePrivFrame = function(p) {
              if (!(p.size < 2)) {
                var _ = d._utf8ArrayToStr(p.data, !0), B = new Uint8Array(p.data.subarray(_.length + 1));
                return { key: p.type, info: _, data: B.buffer };
              }
            }, d._decodeTextFrame = function(p) {
              if (!(p.size < 2))
                if (p.type === "TXXX") {
                  var _ = 1, B = d._utf8ArrayToStr(p.data.subarray(_));
                  _ += B.length + 1;
                  var N = d._utf8ArrayToStr(p.data.subarray(_));
                  return { key: p.type, info: B, data: N };
                } else {
                  var X = d._utf8ArrayToStr(p.data.subarray(1));
                  return { key: p.type, data: X };
                }
            }, d._decodeURLFrame = function(p) {
              if (p.type === "WXXX") {
                if (p.size < 2)
                  return;
                var _ = 1, B = d._utf8ArrayToStr(p.data.subarray(_));
                _ += B.length + 1;
                var N = d._utf8ArrayToStr(p.data.subarray(_));
                return { key: p.type, info: B, data: N };
              } else {
                var X = d._utf8ArrayToStr(p.data);
                return { key: p.type, data: X };
              }
            }, d._utf8ArrayToStr = function(p) {
              for (var _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, B = p.length, N = void 0, X = void 0, te = void 0, re = "", J = 0; J < B; ) {
                if (N = p[J++], N === 0 && _)
                  return re;
                if (N === 0 || N === 3)
                  continue;
                switch (N >> 4) {
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                    re += String.fromCharCode(N);
                    break;
                  case 12:
                  case 13:
                    X = p[J++], re += String.fromCharCode((N & 31) << 6 | X & 63);
                    break;
                  case 14:
                    X = p[J++], te = p[J++], re += String.fromCharCode((N & 15) << 12 | (X & 63) << 6 | (te & 63) << 0);
                    break;
                }
              }
              return re;
            }, d;
          }(), h = b._utf8ArrayToStr;
          n.a = b;
        },
        /* 4 */
        /***/
        function(r, n, u) {
          function y(F, z) {
            if (!(F instanceof z))
              throw new TypeError("Cannot call a class as a function");
          }
          var b = function() {
            function F(z, ee) {
              y(this, F), this.subtle = z, this.aesIV = ee;
            }
            return F.prototype.decrypt = function(ee, ye) {
              return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, ye, ee);
            }, F;
          }(), h = b;
          function d(F, z) {
            if (!(F instanceof z))
              throw new TypeError("Cannot call a class as a function");
          }
          var m = function() {
            function F(z, ee) {
              d(this, F), this.subtle = z, this.key = ee;
            }
            return F.prototype.expandKey = function() {
              return this.subtle.importKey("raw", this.key, { name: "AES-CBC" }, !1, ["encrypt", "decrypt"]);
            }, F;
          }(), p = m;
          function _(F, z) {
            if (!(F instanceof z))
              throw new TypeError("Cannot call a class as a function");
          }
          var B = function() {
            function F() {
              _(this, F), this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable();
            }
            return F.prototype.uint8ArrayToUint32Array_ = function(ee) {
              for (var ye = new DataView(ee), xe = new Uint32Array(4), Ee = 0; Ee < 4; Ee++)
                xe[Ee] = ye.getUint32(Ee * 4);
              return xe;
            }, F.prototype.initTable = function() {
              var ee = this.sBox, ye = this.invSBox, xe = this.subMix, Ee = xe[0], Ae = xe[1], De = xe[2], Ue = xe[3], Ve = this.invSubMix, tt = Ve[0], dt = Ve[1], ft = Ve[2], $t = Ve[3], ze = new Uint32Array(256), Tt = 0, pt = 0, st = 0;
              for (st = 0; st < 256; st++)
                st < 128 ? ze[st] = st << 1 : ze[st] = st << 1 ^ 283;
              for (st = 0; st < 256; st++) {
                var rt = pt ^ pt << 1 ^ pt << 2 ^ pt << 3 ^ pt << 4;
                rt = rt >>> 8 ^ rt & 255 ^ 99, ee[Tt] = rt, ye[rt] = Tt;
                var ht = ze[Tt], Fe = ze[ht], tr = ze[Fe], it = ze[rt] * 257 ^ rt * 16843008;
                Ee[Tt] = it << 24 | it >>> 8, Ae[Tt] = it << 16 | it >>> 16, De[Tt] = it << 8 | it >>> 24, Ue[Tt] = it, it = tr * 16843009 ^ Fe * 65537 ^ ht * 257 ^ Tt * 16843008, tt[rt] = it << 24 | it >>> 8, dt[rt] = it << 16 | it >>> 16, ft[rt] = it << 8 | it >>> 24, $t[rt] = it, Tt ? (Tt = ht ^ ze[ze[ze[tr ^ ht]]], pt ^= ze[ze[pt]]) : Tt = pt = 1;
              }
            }, F.prototype.expandKey = function(ee) {
              for (var ye = this.uint8ArrayToUint32Array_(ee), xe = !0, Ee = 0; Ee < ye.length && xe; )
                xe = ye[Ee] === this.key[Ee], Ee++;
              if (!xe) {
                this.key = ye;
                var Ae = this.keySize = ye.length;
                if (Ae !== 4 && Ae !== 6 && Ae !== 8)
                  throw new Error("Invalid aes key size=" + Ae);
                var De = this.ksRows = (Ae + 6 + 1) * 4, Ue = void 0, Ve = void 0, tt = this.keySchedule = new Uint32Array(De), dt = this.invKeySchedule = new Uint32Array(De), ft = this.sBox, $t = this.rcon, ze = this.invSubMix, Tt = ze[0], pt = ze[1], st = ze[2], rt = ze[3], ht = void 0, Fe = void 0;
                for (Ue = 0; Ue < De; Ue++) {
                  if (Ue < Ae) {
                    ht = tt[Ue] = ye[Ue];
                    continue;
                  }
                  Fe = ht, Ue % Ae === 0 ? (Fe = Fe << 8 | Fe >>> 24, Fe = ft[Fe >>> 24] << 24 | ft[Fe >>> 16 & 255] << 16 | ft[Fe >>> 8 & 255] << 8 | ft[Fe & 255], Fe ^= $t[Ue / Ae | 0] << 24) : Ae > 6 && Ue % Ae === 4 && (Fe = ft[Fe >>> 24] << 24 | ft[Fe >>> 16 & 255] << 16 | ft[Fe >>> 8 & 255] << 8 | ft[Fe & 255]), tt[Ue] = ht = (tt[Ue - Ae] ^ Fe) >>> 0;
                }
                for (Ve = 0; Ve < De; Ve++)
                  Ue = De - Ve, Ve & 3 ? Fe = tt[Ue] : Fe = tt[Ue - 4], Ve < 4 || Ue <= 4 ? dt[Ve] = Fe : dt[Ve] = Tt[ft[Fe >>> 24]] ^ pt[ft[Fe >>> 16 & 255]] ^ st[ft[Fe >>> 8 & 255]] ^ rt[ft[Fe & 255]], dt[Ve] = dt[Ve] >>> 0;
              }
            }, F.prototype.networkToHostOrderSwap = function(ee) {
              return ee << 24 | (ee & 65280) << 8 | (ee & 16711680) >> 8 | ee >>> 24;
            }, F.prototype.decrypt = function(ee, ye, xe) {
              for (var Ee = this.keySize + 6, Ae = this.invKeySchedule, De = this.invSBox, Ue = this.invSubMix, Ve = Ue[0], tt = Ue[1], dt = Ue[2], ft = Ue[3], $t = this.uint8ArrayToUint32Array_(xe), ze = $t[0], Tt = $t[1], pt = $t[2], st = $t[3], rt = new Int32Array(ee), ht = new Int32Array(rt.length), Fe = void 0, tr = void 0, it = void 0, yr = void 0, St = void 0, xt = void 0, Ct = void 0, mt = void 0, Ut = void 0, Ze = void 0, Gt = void 0, Ye = void 0, Et, Xr, Ot = this.networkToHostOrderSwap; ye < rt.length; ) {
                for (Ut = Ot(rt[ye]), Ze = Ot(rt[ye + 1]), Gt = Ot(rt[ye + 2]), Ye = Ot(rt[ye + 3]), St = Ut ^ Ae[0], xt = Ye ^ Ae[1], Ct = Gt ^ Ae[2], mt = Ze ^ Ae[3], Et = 4, Xr = 1; Xr < Ee; Xr++)
                  Fe = Ve[St >>> 24] ^ tt[xt >> 16 & 255] ^ dt[Ct >> 8 & 255] ^ ft[mt & 255] ^ Ae[Et], tr = Ve[xt >>> 24] ^ tt[Ct >> 16 & 255] ^ dt[mt >> 8 & 255] ^ ft[St & 255] ^ Ae[Et + 1], it = Ve[Ct >>> 24] ^ tt[mt >> 16 & 255] ^ dt[St >> 8 & 255] ^ ft[xt & 255] ^ Ae[Et + 2], yr = Ve[mt >>> 24] ^ tt[St >> 16 & 255] ^ dt[xt >> 8 & 255] ^ ft[Ct & 255] ^ Ae[Et + 3], St = Fe, xt = tr, Ct = it, mt = yr, Et = Et + 4;
                Fe = De[St >>> 24] << 24 ^ De[xt >> 16 & 255] << 16 ^ De[Ct >> 8 & 255] << 8 ^ De[mt & 255] ^ Ae[Et], tr = De[xt >>> 24] << 24 ^ De[Ct >> 16 & 255] << 16 ^ De[mt >> 8 & 255] << 8 ^ De[St & 255] ^ Ae[Et + 1], it = De[Ct >>> 24] << 24 ^ De[mt >> 16 & 255] << 16 ^ De[St >> 8 & 255] << 8 ^ De[xt & 255] ^ Ae[Et + 2], yr = De[mt >>> 24] << 24 ^ De[St >> 16 & 255] << 16 ^ De[xt >> 8 & 255] << 8 ^ De[Ct & 255] ^ Ae[Et + 3], Et = Et + 3, ht[ye] = Ot(Fe ^ ze), ht[ye + 1] = Ot(yr ^ Tt), ht[ye + 2] = Ot(it ^ pt), ht[ye + 3] = Ot(tr ^ st), ze = Ut, Tt = Ze, pt = Gt, st = Ye, ye = ye + 4;
              }
              return ht.buffer;
            }, F.prototype.destroy = function() {
              this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0;
            }, F;
          }(), N = B, X = u(2), te = u(0);
          function re(F, z) {
            if (!(F instanceof z))
              throw new TypeError("Cannot call a class as a function");
          }
          var J = function() {
            function F(z, ee) {
              re(this, F), this.observer = z, this.config = ee, this.logEnabled = !0;
              try {
                var ye = crypto || self.crypto;
                this.subtle = ye.subtle || ye.webkitSubtle;
              } catch {
              }
              this.disableWebCrypto = !this.subtle;
            }
            return F.prototype.isSync = function() {
              return this.disableWebCrypto && this.config.enableSoftwareAES;
            }, F.prototype.decrypt = function(ee, ye, xe, Ee) {
              var Ae = this;
              if (this.disableWebCrypto && this.config.enableSoftwareAES) {
                this.logEnabled && (te.b.log("JS AES decrypt"), this.logEnabled = !1);
                var De = this.decryptor;
                De || (this.decryptor = De = new N()), De.expandKey(ye), Ee(De.decrypt(ee, 0, xe));
              } else {
                this.logEnabled && (te.b.log("WebCrypto AES decrypt"), this.logEnabled = !1);
                var Ue = this.subtle;
                this.key !== ye && (this.key = ye, this.fastAesKey = new p(Ue, ye)), this.fastAesKey.expandKey().then(function(Ve) {
                  var tt = new h(Ue, xe);
                  tt.decrypt(ee, Ve).catch(function(dt) {
                    Ae.onWebCryptoError(dt, ee, ye, xe, Ee);
                  }).then(function(dt) {
                    Ee(dt);
                  });
                }).catch(function(Ve) {
                  Ae.onWebCryptoError(Ve, ee, ye, xe, Ee);
                });
              }
            }, F.prototype.onWebCryptoError = function(ee, ye, xe, Ee, Ae) {
              this.config.enableSoftwareAES ? (te.b.log("WebCrypto Error, disable WebCrypto API"), this.disableWebCrypto = !0, this.logEnabled = !0, this.decrypt(ye, xe, Ee, Ae)) : (te.b.error("decrypting error : " + ee.message), this.observer.trigger(Event.ERROR, { type: X.b.MEDIA_ERROR, details: X.a.FRAG_DECRYPT_ERROR, fatal: !0, reason: ee.message }));
            }, F.prototype.destroy = function() {
              var ee = this.decryptor;
              ee && (ee.destroy(), this.decryptor = void 0);
            }, F;
          }();
          n.a = J;
        },
        /* 5 */
        /***/
        function(r, n) {
          function u() {
            this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
          }
          r.exports = u, u.EventEmitter = u, u.prototype._events = void 0, u.prototype._maxListeners = void 0, u.defaultMaxListeners = 10, u.prototype.setMaxListeners = function(m) {
            if (!b(m) || m < 0 || isNaN(m))
              throw TypeError("n must be a positive number");
            return this._maxListeners = m, this;
          }, u.prototype.emit = function(m) {
            var p, _, B, N, X, te;
            if (this._events || (this._events = {}), m === "error" && (!this._events.error || h(this._events.error) && !this._events.error.length)) {
              if (p = arguments[1], p instanceof Error)
                throw p;
              var re = new Error('Uncaught, unspecified "error" event. (' + p + ")");
              throw re.context = p, re;
            }
            if (_ = this._events[m], d(_))
              return !1;
            if (y(_))
              switch (arguments.length) {
                case 1:
                  _.call(this);
                  break;
                case 2:
                  _.call(this, arguments[1]);
                  break;
                case 3:
                  _.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  N = Array.prototype.slice.call(arguments, 1), _.apply(this, N);
              }
            else if (h(_))
              for (N = Array.prototype.slice.call(arguments, 1), te = _.slice(), B = te.length, X = 0; X < B; X++)
                te[X].apply(this, N);
            return !0;
          }, u.prototype.addListener = function(m, p) {
            var _;
            if (!y(p))
              throw TypeError("listener must be a function");
            return this._events || (this._events = {}), this._events.newListener && this.emit(
              "newListener",
              m,
              y(p.listener) ? p.listener : p
            ), this._events[m] ? h(this._events[m]) ? this._events[m].push(p) : this._events[m] = [this._events[m], p] : this._events[m] = p, h(this._events[m]) && !this._events[m].warned && (d(this._maxListeners) ? _ = u.defaultMaxListeners : _ = this._maxListeners, _ && _ > 0 && this._events[m].length > _ && (this._events[m].warned = !0, console.error(
              "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
              this._events[m].length
            ), typeof console.trace == "function" && console.trace())), this;
          }, u.prototype.on = u.prototype.addListener, u.prototype.once = function(m, p) {
            if (!y(p))
              throw TypeError("listener must be a function");
            var _ = !1;
            function B() {
              this.removeListener(m, B), _ || (_ = !0, p.apply(this, arguments));
            }
            return B.listener = p, this.on(m, B), this;
          }, u.prototype.removeListener = function(m, p) {
            var _, B, N, X;
            if (!y(p))
              throw TypeError("listener must be a function");
            if (!this._events || !this._events[m])
              return this;
            if (_ = this._events[m], N = _.length, B = -1, _ === p || y(_.listener) && _.listener === p)
              delete this._events[m], this._events.removeListener && this.emit("removeListener", m, p);
            else if (h(_)) {
              for (X = N; X-- > 0; )
                if (_[X] === p || _[X].listener && _[X].listener === p) {
                  B = X;
                  break;
                }
              if (B < 0)
                return this;
              _.length === 1 ? (_.length = 0, delete this._events[m]) : _.splice(B, 1), this._events.removeListener && this.emit("removeListener", m, p);
            }
            return this;
          }, u.prototype.removeAllListeners = function(m) {
            var p, _;
            if (!this._events)
              return this;
            if (!this._events.removeListener)
              return arguments.length === 0 ? this._events = {} : this._events[m] && delete this._events[m], this;
            if (arguments.length === 0) {
              for (p in this._events)
                p !== "removeListener" && this.removeAllListeners(p);
              return this.removeAllListeners("removeListener"), this._events = {}, this;
            }
            if (_ = this._events[m], y(_))
              this.removeListener(m, _);
            else if (_)
              for (; _.length; )
                this.removeListener(m, _[_.length - 1]);
            return delete this._events[m], this;
          }, u.prototype.listeners = function(m) {
            var p;
            return !this._events || !this._events[m] ? p = [] : y(this._events[m]) ? p = [this._events[m]] : p = this._events[m].slice(), p;
          }, u.prototype.listenerCount = function(m) {
            if (this._events) {
              var p = this._events[m];
              if (y(p))
                return 1;
              if (p)
                return p.length;
            }
            return 0;
          }, u.listenerCount = function(m, p) {
            return m.listenerCount(p);
          };
          function y(m) {
            return typeof m == "function";
          }
          function b(m) {
            return typeof m == "number";
          }
          function h(m) {
            return typeof m == "object" && m !== null;
          }
          function d(m) {
            return m === void 0;
          }
        },
        /* 6 */
        /***/
        function(r, n, u) {
          (function(y) {
            var b = /^((?:[^\/;?#]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/, h = /^([^\/;?#]*)(.*)$/, d = /(?:\/|^)\.(?=\/)/g, m = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g, p = {
              // jshint ignore:line
              // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
              // E.g
              // With opts.alwaysNormalize = false (default, spec compliant)
              // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
              // With opts.alwaysNormalize = true (default, not spec compliant)
              // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
              buildAbsoluteURL: function(_, B, N) {
                if (N = N || {}, _ = _.trim(), B = B.trim(), !B) {
                  if (!N.alwaysNormalize)
                    return _;
                  var X = this.parseURL(_);
                  if (!re)
                    throw new Error("Error trying to parse base URL.");
                  return X.path = p.normalizePath(X.path), p.buildURLFromParts(X);
                }
                var te = this.parseURL(B);
                if (!te)
                  throw new Error("Error trying to parse relative URL.");
                if (te.scheme)
                  return N.alwaysNormalize ? (te.path = p.normalizePath(te.path), p.buildURLFromParts(te)) : B;
                var re = this.parseURL(_);
                if (!re)
                  throw new Error("Error trying to parse base URL.");
                if (!re.netLoc && re.path && re.path[0] !== "/") {
                  var J = h.exec(re.path);
                  re.netLoc = J[1], re.path = J[2];
                }
                re.netLoc && !re.path && (re.path = "/");
                var F = {
                  // 2c) Otherwise, the embedded URL inherits the scheme of
                  // the base URL.
                  scheme: re.scheme,
                  netLoc: te.netLoc,
                  path: null,
                  params: te.params,
                  query: te.query,
                  fragment: te.fragment
                };
                if (!te.netLoc && (F.netLoc = re.netLoc, te.path[0] !== "/"))
                  if (!te.path)
                    F.path = re.path, te.params || (F.params = re.params, te.query || (F.query = re.query));
                  else {
                    var z = re.path, ee = z.substring(0, z.lastIndexOf("/") + 1) + te.path;
                    F.path = p.normalizePath(ee);
                  }
                return F.path === null && (F.path = N.alwaysNormalize ? p.normalizePath(te.path) : te.path), p.buildURLFromParts(F);
              },
              parseURL: function(_) {
                var B = b.exec(_);
                return B ? {
                  scheme: B[1] || "",
                  netLoc: B[2] || "",
                  path: B[3] || "",
                  params: B[4] || "",
                  query: B[5] || "",
                  fragment: B[6] || ""
                } : null;
              },
              normalizePath: function(_) {
                for (_ = _.split("").reverse().join("").replace(d, ""); _.length !== (_ = _.replace(m, "")).length; )
                  ;
                return _.split("").reverse().join("");
              },
              buildURLFromParts: function(_) {
                return _.scheme + _.netLoc + _.path + _.params + _.query + _.fragment;
              }
            };
            r.exports = p;
          })();
        },
        /* 7 */
        /***/
        function(r, n, u) {
          var y = u(1), b = u(2), h = u(4), d = u(0);
          function m(A, j, g, T) {
            var D, P, U, q, G, W = navigator.userAgent.toLowerCase(), ie = T, Y = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
            if (D = ((j[g + 2] & 192) >>> 6) + 1, P = (j[g + 2] & 60) >>> 2, P > Y.length - 1) {
              A.trigger(Event.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.FRAG_PARSING_ERROR, fatal: !0, reason: "invalid ADTS sampling index:" + P });
              return;
            }
            return q = (j[g + 2] & 1) << 2, q |= (j[g + 3] & 192) >>> 6, d.b.log("manifest codec:" + T + ",ADTS data:type:" + D + ",sampleingIndex:" + P + "[" + Y[P] + "Hz],channelConfig:" + q), /firefox/i.test(W) ? P >= 6 ? (D = 5, G = new Array(4), U = P - 3) : (D = 2, G = new Array(2), U = P) : W.indexOf("android") !== -1 ? (D = 2, G = new Array(2), U = P) : (D = 5, G = new Array(4), T && (T.indexOf("mp4a.40.29") !== -1 || T.indexOf("mp4a.40.5") !== -1) || !T && P >= 6 ? U = P - 3 : ((T && T.indexOf("mp4a.40.2") !== -1 && (P >= 6 && q === 1 || /vivaldi/i.test(W)) || !T && q === 1) && (D = 2, G = new Array(2)), U = P)), G[0] = D << 3, G[0] |= (P & 14) >> 1, G[1] |= (P & 1) << 7, G[1] |= q << 3, D === 5 && (G[1] |= (U & 14) >> 1, G[2] = (U & 1) << 7, G[2] |= 8, G[3] = 0), { config: G, samplerate: Y[P], channelCount: q, codec: "mp4a.40." + D, manifestCodec: ie };
          }
          function p(A, j) {
            return A[j] === 255 && (A[j + 1] & 246) === 240;
          }
          function _(A, j) {
            return A[j + 1] & 1 ? 7 : 9;
          }
          function B(A, j) {
            return (A[j + 3] & 3) << 11 | A[j + 4] << 3 | (A[j + 5] & 224) >>> 5;
          }
          function N(A, j) {
            return !!(j + 1 < A.length && p(A, j));
          }
          function X(A, j) {
            if (j + 1 < A.length && p(A, j)) {
              var g = _(A, j), T = g;
              j + 5 < A.length && (T = B(A, j));
              var D = j + T;
              if (D === A.length || D + 1 < A.length && p(A, D))
                return !0;
            }
            return !1;
          }
          function te(A, j, g, T, D) {
            if (!A.samplerate) {
              var P = m(j, g, T, D);
              A.config = P.config, A.samplerate = P.samplerate, A.channelCount = P.channelCount, A.codec = P.codec, A.manifestCodec = P.manifestCodec, d.b.log("parsed codec:" + A.codec + ",rate:" + P.samplerate + ",nb channel:" + P.channelCount);
            }
          }
          function re(A) {
            return 1024 * 9e4 / A;
          }
          function J(A, j, g, T, D) {
            var P, U, q, G = A.length;
            if (P = _(A, j), U = B(A, j), U -= P, U > 0 && j + P + U <= G)
              return q = g + T * D, { headerLength: P, frameLength: U, stamp: q };
          }
          function F(A, j, g, T, D) {
            var P = re(A.samplerate), U = J(j, g, T, D, P);
            if (U) {
              var q = U.stamp, G = U.headerLength, W = U.frameLength, ie = {
                unit: j.subarray(g + G, g + G + W),
                pts: q,
                dts: q
              };
              return A.samples.push(ie), A.len += W, { sample: ie, length: W + G };
            }
          }
          var z = u(3);
          function ee(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var ye = function() {
            function A(j, g, T) {
              ee(this, A), this.observer = j, this.config = T, this.remuxer = g;
            }
            return A.prototype.resetInitSegment = function(g, T, D, P) {
              this._audioTrack = { container: "audio/adts", type: "audio", id: 0, sequenceNumber: 0, isAAC: !0, samples: [], len: 0, manifestCodec: T, duration: P, inputTimeScale: 9e4 };
            }, A.prototype.resetTimeStamp = function() {
            }, A.probe = function(g) {
              if (!g)
                return !1;
              for (var T = z.a.getID3Data(g, 0) || [], D = T.length, P = g.length; D < P; D++)
                if (X(g, D))
                  return d.b.log("ADTS sync word found !"), !0;
              return !1;
            }, A.prototype.append = function(g, T, D, P) {
              for (var U = this._audioTrack, q = z.a.getID3Data(g, 0) || [], G = z.a.getTimeStamp(q), W = G ? 90 * G : T * 9e4, ie = 0, Y = W, ue = g.length, ae = q.length, me = [{ pts: Y, dts: Y, data: q }]; ae < ue - 1; )
                if (N(g, ae) && ae + 5 < ue) {
                  te(U, this.observer, g, ae, U.manifestCodec);
                  var fe = F(U, g, ae, W, ie);
                  if (fe)
                    ae += fe.length, Y = fe.sample.pts, ie++;
                  else {
                    d.b.log("Unable to parse AAC frame");
                    break;
                  }
                } else z.a.isHeader(g, ae) ? (q = z.a.getID3Data(g, ae), me.push({ pts: Y, dts: Y, data: q }), ae += q.length) : ae++;
              this.remuxer.remux(U, { samples: [] }, { samples: me, inputTimeScale: 9e4 }, { samples: [] }, T, D, P);
            }, A.prototype.destroy = function() {
            }, A;
          }(), xe = ye;
          function Ee(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ae = Math.pow(2, 32) - 1, De = function() {
            function A(j, g) {
              Ee(this, A), this.observer = j, this.remuxer = g;
            }
            return A.prototype.resetTimeStamp = function(g) {
              this.initPTS = g;
            }, A.prototype.resetInitSegment = function(g, T, D, P) {
              if (g && g.byteLength) {
                var U = this.initData = A.parseInitSegment(g);
                T == null && (T = "mp4a.40.5"), D == null && (D = "avc1.42e01e");
                var q = {};
                U.audio && U.video ? q.audiovideo = { container: "video/mp4", codec: T + "," + D, initSegment: P ? g : null } : (U.audio && (q.audio = { container: "audio/mp4", codec: T, initSegment: P ? g : null }), U.video && (q.video = { container: "video/mp4", codec: D, initSegment: P ? g : null })), this.observer.trigger(y.a.FRAG_PARSING_INIT_SEGMENT, { tracks: q });
              } else
                T && (this.audioCodec = T), D && (this.videoCodec = D);
            }, A.probe = function(g) {
              return A.findBox({ data: g, start: 0, end: Math.min(g.length, 16384) }, ["moof"]).length > 0;
            }, A.bin2str = function(g) {
              return String.fromCharCode.apply(null, g);
            }, A.readUint32 = function(g, T) {
              g.data && (T += g.start, g = g.data);
              var D = g[T] << 24 | g[T + 1] << 16 | g[T + 2] << 8 | g[T + 3];
              return D < 0 ? 4294967296 + D : D;
            }, A.writeUint32 = function(g, T, D) {
              g.data && (T += g.start, g = g.data), g[T] = D >> 24, g[T + 1] = D >> 16 & 255, g[T + 2] = D >> 8 & 255, g[T + 3] = D & 255;
            }, A.findBox = function(g, T) {
              var D = [], P, U, q, G, W, ie, Y;
              if (g.data ? (ie = g.start, G = g.end, g = g.data) : (ie = 0, G = g.byteLength), !T.length)
                return null;
              for (P = ie; P < G; )
                U = A.readUint32(g, P), q = A.bin2str(g.subarray(P + 4, P + 8)), Y = U > 1 ? P + U : G, q === T[0] && (T.length === 1 ? D.push({ data: g, start: P + 8, end: Y }) : (W = A.findBox({ data: g, start: P + 8, end: Y }, T.slice(1)), W.length && (D = D.concat(W)))), P = Y;
              return D;
            }, A.parseInitSegment = function(g) {
              var T = [], D = A.findBox(g, ["moov", "trak"]);
              return D.forEach(function(P) {
                var U = A.findBox(P, ["tkhd"])[0];
                if (U) {
                  var q = U.data[U.start], G = q === 0 ? 12 : 20, W = A.readUint32(U, G), ie = A.findBox(P, ["mdia", "mdhd"])[0];
                  if (ie) {
                    q = ie.data[ie.start], G = q === 0 ? 12 : 20;
                    var Y = A.readUint32(ie, G), ue = A.findBox(P, ["mdia", "hdlr"])[0];
                    if (ue) {
                      var ae = A.bin2str(ue.data.subarray(ue.start + 8, ue.start + 12)), me = { soun: "audio", vide: "video" }[ae];
                      if (me) {
                        var fe = A.findBox(P, ["mdia", "minf", "stbl", "stsd"]);
                        if (fe.length) {
                          fe = fe[0];
                          var Q = A.bin2str(fe.data.subarray(fe.start + 12, fe.start + 16));
                          d.b.log("MP4Demuxer:" + me + ":" + Q + " found");
                        }
                        T[W] = { timescale: Y, type: me }, T[me] = { timescale: Y, id: W };
                      }
                    }
                  }
                }
              }), T;
            }, A.getStartDTS = function(g, T) {
              var D, P, U;
              return D = A.findBox(T, ["moof", "traf"]), P = [].concat.apply([], D.map(function(q) {
                return A.findBox(q, ["tfhd"]).map(function(G) {
                  var W, ie, Y;
                  return W = A.readUint32(G, 4), ie = g[W].timescale || 9e4, Y = A.findBox(q, ["tfdt"]).map(function(ue) {
                    var ae, me;
                    return ae = ue.data[ue.start], me = A.readUint32(ue, 4), ae === 1 && (me *= Math.pow(2, 32), me += A.readUint32(ue, 8)), me;
                  })[0], Y / ie;
                });
              })), U = Math.min.apply(null, P), isFinite(U) ? U : 0;
            }, A.offsetStartDTS = function(g, T, D) {
              A.findBox(T, ["moof", "traf"]).map(function(P) {
                return A.findBox(P, ["tfhd"]).map(function(U) {
                  var q = A.readUint32(U, 4), G = g[q].timescale || 9e4;
                  A.findBox(P, ["tfdt"]).map(function(W) {
                    var ie = W.data[W.start], Y = A.readUint32(W, 4);
                    if (ie === 0)
                      A.writeUint32(W, 4, Y - D * G);
                    else {
                      Y *= Math.pow(2, 32), Y += A.readUint32(W, 8), Y -= D * G, Y = Math.max(Y, 0);
                      var ue = Math.floor(Y / (Ae + 1)), ae = Math.floor(Y % (Ae + 1));
                      A.writeUint32(W, 4, ue), A.writeUint32(W, 8, ae);
                    }
                  });
                });
              });
            }, A.prototype.append = function(g, T, D, P) {
              var U = this.initData;
              U || (this.resetInitSegment(g, this.audioCodec, this.videoCodec), U = this.initData);
              var q = void 0, G = this.initPTS;
              if (G === void 0) {
                var W = A.getStartDTS(U, g);
                this.initPTS = G = W - T, this.observer.trigger(y.a.INIT_PTS_FOUND, { initPTS: G });
              }
              A.offsetStartDTS(U, g, G), q = A.getStartDTS(U, g), this.remuxer.remux(U.audio, U.video, null, null, q, D, P, g);
            }, A.prototype.destroy = function() {
            }, A;
          }(), Ue = De, Ve = {
            BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
            SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
            SamplesCoefficients: [
              // MPEG 2.5
              [
                0,
                // Reserved
                72,
                // Layer3
                144,
                // Layer2
                12
                // Layer1
              ],
              // Reserved
              [
                0,
                // Reserved
                0,
                // Layer3
                0,
                // Layer2
                0
                // Layer1
              ],
              // MPEG 2
              [
                0,
                // Reserved
                72,
                // Layer3
                144,
                // Layer2
                12
                // Layer1
              ],
              // MPEG 1
              [
                0,
                // Reserved
                144,
                // Layer3
                144,
                // Layer2
                12
                // Layer1
              ]
            ],
            BytesInSlot: [
              0,
              // Reserved
              1,
              // Layer3
              1,
              // Layer2
              4
              // Layer1
            ],
            appendFrame: function(j, g, T, D, P) {
              if (!(T + 24 > g.length)) {
                var U = this.parseHeader(g, T);
                if (U && T + U.frameLength <= g.length) {
                  var q = U.samplesPerFrame * 9e4 / U.sampleRate, G = D + P * q, W = { unit: g.subarray(T, T + U.frameLength), pts: G, dts: G };
                  return j.config = [], j.channelCount = U.channelCount, j.samplerate = U.sampleRate, j.samples.push(W), j.len += U.frameLength, { sample: W, length: U.frameLength };
                }
              }
            },
            parseHeader: function(j, g) {
              var T = j[g + 1] >> 3 & 3, D = j[g + 1] >> 1 & 3, P = j[g + 2] >> 4 & 15, U = j[g + 2] >> 2 & 3, q = j[g + 2] >> 1 & 1;
              if (T !== 1 && P !== 0 && P !== 15 && U !== 3) {
                var G = T === 3 ? 3 - D : D === 3 ? 3 : 4, W = Ve.BitratesMap[G * 14 + P - 1] * 1e3, ie = T === 3 ? 0 : T === 2 ? 1 : 2, Y = Ve.SamplingRateMap[ie * 3 + U], ue = j[g + 3] >> 6 === 3 ? 1 : 2, ae = Ve.SamplesCoefficients[T][D], me = Ve.BytesInSlot[D], fe = ae * 8 * me, Q = parseInt(ae * W / Y + q, 10) * me;
                return { sampleRate: Y, channelCount: ue, frameLength: Q, samplesPerFrame: fe };
              }
            },
            isHeaderPattern: function(j, g) {
              return j[g] === 255 && (j[g + 1] & 224) === 224 && (j[g + 1] & 6) !== 0;
            },
            isHeader: function(j, g) {
              return !!(g + 1 < j.length && this.isHeaderPattern(j, g));
            },
            probe: function(j, g) {
              if (g + 1 < j.length && this.isHeaderPattern(j, g)) {
                var T = 4, D = this.parseHeader(j, g), P = T;
                D && D.frameLength && (P = D.frameLength);
                var U = g + P;
                if (U === j.length || U + 1 < j.length && this.isHeaderPattern(j, U))
                  return !0;
              }
              return !1;
            }
          }, tt = Ve;
          function dt(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var ft = function() {
            function A(j) {
              dt(this, A), this.data = j, this.bytesAvailable = j.byteLength, this.word = 0, this.bitsAvailable = 0;
            }
            return A.prototype.loadWord = function() {
              var g = this.data, T = this.bytesAvailable, D = g.byteLength - T, P = new Uint8Array(4), U = Math.min(4, T);
              if (U === 0)
                throw new Error("no bytes available");
              P.set(g.subarray(D, D + U)), this.word = new DataView(P.buffer).getUint32(0), this.bitsAvailable = U * 8, this.bytesAvailable -= U;
            }, A.prototype.skipBits = function(g) {
              var T;
              this.bitsAvailable > g ? (this.word <<= g, this.bitsAvailable -= g) : (g -= this.bitsAvailable, T = g >> 3, g -= T >> 3, this.bytesAvailable -= T, this.loadWord(), this.word <<= g, this.bitsAvailable -= g);
            }, A.prototype.readBits = function(g) {
              var T = Math.min(this.bitsAvailable, g), D = this.word >>> 32 - T;
              return g > 32 && d.b.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= T, this.bitsAvailable > 0 ? this.word <<= T : this.bytesAvailable > 0 && this.loadWord(), T = g - T, T > 0 && this.bitsAvailable ? D << T | this.readBits(T) : D;
            }, A.prototype.skipLZ = function() {
              var g;
              for (g = 0; g < this.bitsAvailable; ++g)
                if (this.word & 2147483648 >>> g)
                  return this.word <<= g, this.bitsAvailable -= g, g;
              return this.loadWord(), g + this.skipLZ();
            }, A.prototype.skipUEG = function() {
              this.skipBits(1 + this.skipLZ());
            }, A.prototype.skipEG = function() {
              this.skipBits(1 + this.skipLZ());
            }, A.prototype.readUEG = function() {
              var g = this.skipLZ();
              return this.readBits(g + 1) - 1;
            }, A.prototype.readEG = function() {
              var g = this.readUEG();
              return 1 & g ? 1 + g >>> 1 : -1 * (g >>> 1);
            }, A.prototype.readBoolean = function() {
              return this.readBits(1) === 1;
            }, A.prototype.readUByte = function() {
              return this.readBits(8);
            }, A.prototype.readUShort = function() {
              return this.readBits(16);
            }, A.prototype.readUInt = function() {
              return this.readBits(32);
            }, A.prototype.skipScalingList = function(g) {
              var T = 8, D = 8, P, U;
              for (P = 0; P < g; P++)
                D !== 0 && (U = this.readEG(), D = (T + U + 256) % 256), T = D === 0 ? T : D;
            }, A.prototype.readSPS = function() {
              var g = 0, T = 0, D = 0, P = 0, U, q, G, W, ie, Y, ue, ae = this.readUByte.bind(this), me = this.readBits.bind(this), fe = this.readUEG.bind(this), Q = this.readBoolean.bind(this), oe = this.skipBits.bind(this), Ke = this.skipEG.bind(this), nt = this.skipUEG.bind(this), ot = this.skipScalingList.bind(this);
              if (ae(), U = ae(), me(5), oe(3), ae(), nt(), U === 100 || U === 110 || U === 122 || U === 244 || U === 44 || U === 83 || U === 86 || U === 118 || U === 128) {
                var qe = fe();
                if (qe === 3 && oe(1), nt(), nt(), oe(1), Q())
                  for (Y = qe !== 3 ? 8 : 12, ue = 0; ue < Y; ue++)
                    Q() && (ue < 6 ? ot(16) : ot(64));
              }
              nt();
              var Je = fe();
              if (Je === 0)
                fe();
              else if (Je === 1)
                for (oe(1), Ke(), Ke(), q = fe(), ue = 0; ue < q; ue++)
                  Ke();
              nt(), oe(1), G = fe(), W = fe(), ie = me(1), ie === 0 && oe(1), oe(1), Q() && (g = fe(), T = fe(), D = fe(), P = fe());
              var Le = [1, 1];
              if (Q() && Q()) {
                var ct = ae();
                switch (ct) {
                  case 1:
                    Le = [1, 1];
                    break;
                  case 2:
                    Le = [12, 11];
                    break;
                  case 3:
                    Le = [10, 11];
                    break;
                  case 4:
                    Le = [16, 11];
                    break;
                  case 5:
                    Le = [40, 33];
                    break;
                  case 6:
                    Le = [24, 11];
                    break;
                  case 7:
                    Le = [20, 11];
                    break;
                  case 8:
                    Le = [32, 11];
                    break;
                  case 9:
                    Le = [80, 33];
                    break;
                  case 10:
                    Le = [18, 11];
                    break;
                  case 11:
                    Le = [15, 11];
                    break;
                  case 12:
                    Le = [64, 33];
                    break;
                  case 13:
                    Le = [160, 99];
                    break;
                  case 14:
                    Le = [4, 3];
                    break;
                  case 15:
                    Le = [3, 2];
                    break;
                  case 16:
                    Le = [2, 1];
                    break;
                  case 255: {
                    Le = [ae() << 8 | ae(), ae() << 8 | ae()];
                    break;
                  }
                }
              }
              return {
                width: Math.ceil((G + 1) * 16 - g * 2 - T * 2),
                height: (2 - ie) * (W + 1) * 16 - (ie ? 2 : 4) * (D + P),
                pixelRatio: Le
              };
            }, A.prototype.readSliceType = function() {
              return this.readUByte(), this.readUEG(), this.readUEG();
            }, A;
          }(), $t = ft;
          function ze(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var Tt = function() {
            function A(j, g, T, D) {
              ze(this, A), this.decryptdata = T, this.discardEPB = D, this.decrypter = new h.a(j, g);
            }
            return A.prototype.decryptBuffer = function(g, T) {
              this.decrypter.decrypt(g, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, T);
            }, A.prototype.decryptAacSample = function(g, T, D, P) {
              var U = g[T].unit, q = U.subarray(16, U.length - U.length % 16), G = q.buffer.slice(q.byteOffset, q.byteOffset + q.length), W = this;
              this.decryptBuffer(G, function(ie) {
                ie = new Uint8Array(ie), U.set(ie, 16), P || W.decryptAacSamples(g, T + 1, D);
              });
            }, A.prototype.decryptAacSamples = function(g, T, D) {
              for (; ; T++) {
                if (T >= g.length) {
                  D();
                  return;
                }
                if (!(g[T].unit.length < 32)) {
                  var P = this.decrypter.isSync();
                  if (this.decryptAacSample(g, T, D, P), !P)
                    return;
                }
              }
            }, A.prototype.getAvcEncryptedData = function(g) {
              for (var T = Math.floor((g.length - 48) / 160) * 16 + 16, D = new Int8Array(T), P = 0, U = 32; U <= g.length - 16; U += 160, P += 16)
                D.set(g.subarray(U, U + 16), P);
              return D;
            }, A.prototype.getAvcDecryptedUnit = function(g, T) {
              T = new Uint8Array(T);
              for (var D = 0, P = 32; P <= g.length - 16; P += 160, D += 16)
                g.set(T.subarray(D, D + 16), P);
              return g;
            }, A.prototype.decryptAvcSample = function(g, T, D, P, U, q) {
              var G = this.discardEPB(U.data), W = this.getAvcEncryptedData(G), ie = this;
              this.decryptBuffer(W.buffer, function(Y) {
                U.data = ie.getAvcDecryptedUnit(G, Y), q || ie.decryptAvcSamples(g, T, D + 1, P);
              });
            }, A.prototype.decryptAvcSamples = function(g, T, D, P) {
              for (; ; T++, D = 0) {
                if (T >= g.length) {
                  P();
                  return;
                }
                for (var U = g[T].units; !(D >= U.length); D++) {
                  var q = U[D];
                  if (!(q.length <= 48 || q.type !== 1 && q.type !== 5)) {
                    var G = this.decrypter.isSync();
                    if (this.decryptAvcSample(g, T, D, P, q, G), !G)
                      return;
                  }
                }
              }
            }, A;
          }(), pt = Tt;
          function st(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var rt = {
            video: 0,
            audio: 1,
            id3: 2,
            text: 3
          }, ht = function() {
            function A(j, g, T, D) {
              st(this, A), this.observer = j, this.config = T, this.typeSupported = D, this.remuxer = g, this.sampleAes = null;
            }
            return A.prototype.setDecryptData = function(g) {
              g != null && g.key != null && g.method === "SAMPLE-AES" ? this.sampleAes = new pt(this.observer, this.config, g, this.discardEPB) : this.sampleAes = null;
            }, A.probe = function(g) {
              var T = A._syncOffset(g);
              return T < 0 ? !1 : (T && d.b.warn("MPEG2-TS detected but first sync word found @ offset " + T + ", junk ahead ?"), !0);
            }, A._syncOffset = function(g) {
              for (var T = Math.min(1e3, g.length - 564), D = 0; D < T; ) {
                if (g[D] === 71 && g[D + 188] === 71 && g[D + 2 * 188] === 71)
                  return D;
                D++;
              }
              return -1;
            }, A.createTrack = function(g, T) {
              return {
                container: g === "video" || g === "audio" ? "video/mp2t" : void 0,
                type: g,
                id: rt[g],
                pid: -1,
                inputTimeScale: 9e4,
                sequenceNumber: 0,
                samples: [],
                len: 0,
                dropped: g === "video" ? 0 : void 0,
                isAAC: g === "audio" ? !0 : void 0,
                duration: g === "audio" ? T : void 0
              };
            }, A.prototype.resetInitSegment = function(g, T, D, P) {
              this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = A.createTrack("video", P), this._audioTrack = A.createTrack("audio", P), this._id3Track = A.createTrack("id3", P), this._txtTrack = A.createTrack("text", P), this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = T, this.videoCodec = D, this._duration = P;
            }, A.prototype.resetTimeStamp = function() {
            }, A.prototype.append = function(g, T, D, P) {
              var U, q = g.length, G, W, ie, Y, ue, ae = !1;
              this.contiguous = D;
              var me = this.pmtParsed, fe = this._avcTrack, Q = this._audioTrack, oe = this._id3Track, Ke = fe.pid, nt = Q.pid, ot = oe.pid, qe = this._pmtId, Je = fe.pesData, Le = Q.pesData, ct = oe.pesData, Lt = this._parsePAT, ut = this._parsePMT, At = this._parsePES, Kt = this._parseAVCPES.bind(this), rr = this._parseAACPES.bind(this), Mt = this._parseMPEGPES.bind(this), br = this._parseID3PES.bind(this), qt = A._syncOffset(g);
              for (q -= (q + qt) % 188, U = qt; U < q; U += 188)
                if (g[U] === 71) {
                  if (G = !!(g[U + 1] & 64), W = ((g[U + 1] & 31) << 8) + g[U + 2], ie = (g[U + 3] & 48) >> 4, ie > 1) {
                    if (Y = U + 5 + g[U + 4], Y === U + 188)
                      continue;
                  } else
                    Y = U + 4;
                  switch (W) {
                    case Ke:
                      G && (Je && (ue = At(Je)) && Kt(ue, !1), Je = { data: [], size: 0 }), Je && (Je.data.push(g.subarray(Y, U + 188)), Je.size += U + 188 - Y);
                      break;
                    case nt:
                      G && (Le && (ue = At(Le)) && (Q.isAAC ? rr(ue) : Mt(ue)), Le = { data: [], size: 0 }), Le && (Le.data.push(g.subarray(Y, U + 188)), Le.size += U + 188 - Y);
                      break;
                    case ot:
                      G && (ct && (ue = At(ct)) && br(ue), ct = { data: [], size: 0 }), ct && (ct.data.push(g.subarray(Y, U + 188)), ct.size += U + 188 - Y);
                      break;
                    case 0:
                      G && (Y += g[Y] + 1), qe = this._pmtId = Lt(g, Y);
                      break;
                    case qe:
                      G && (Y += g[Y] + 1);
                      var ir = ut(g, Y, this.typeSupported.mpeg === !0 || this.typeSupported.mp3 === !0, this.sampleAes != null);
                      Ke = ir.avc, Ke > 0 && (fe.pid = Ke), nt = ir.audio, nt > 0 && (Q.pid = nt, Q.isAAC = ir.isAAC), ot = ir.id3, ot > 0 && (oe.pid = ot), ae && !me && (d.b.log("reparse from beginning"), ae = !1, U = qt - 188), me = this.pmtParsed = !0;
                      break;
                    case 17:
                    case 8191:
                      break;
                    default:
                      ae = !0;
                      break;
                  }
                } else
                  this.observer.trigger(y.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.FRAG_PARSING_ERROR, fatal: !1, reason: "TS packet did not start with 0x47" });
              Je && (ue = At(Je)) ? (Kt(ue, !0), fe.pesData = null) : fe.pesData = Je, Le && (ue = At(Le)) ? (Q.isAAC ? rr(ue) : Mt(ue), Q.pesData = null) : (Le && Le.size && d.b.log("last AAC PES packet truncated,might overlap between fragments"), Q.pesData = Le), ct && (ue = At(ct)) ? (br(ue), oe.pesData = null) : oe.pesData = ct, this.sampleAes == null ? this.remuxer.remux(Q, fe, oe, this._txtTrack, T, D, P) : this.decryptAndRemux(Q, fe, oe, this._txtTrack, T, D, P);
            }, A.prototype.decryptAndRemux = function(g, T, D, P, U, q, G) {
              if (g.samples && g.isAAC) {
                var W = this;
                this.sampleAes.decryptAacSamples(g.samples, 0, function() {
                  W.decryptAndRemuxAvc(g, T, D, P, U, q, G);
                });
              } else
                this.decryptAndRemuxAvc(g, T, D, P, U, q, G);
            }, A.prototype.decryptAndRemuxAvc = function(g, T, D, P, U, q, G) {
              if (T.samples) {
                var W = this;
                this.sampleAes.decryptAvcSamples(T.samples, 0, 0, function() {
                  W.remuxer.remux(g, T, D, P, U, q, G);
                });
              } else
                this.remuxer.remux(g, T, D, P, U, q, G);
            }, A.prototype.destroy = function() {
              this._initPTS = this._initDTS = void 0, this._duration = 0;
            }, A.prototype._parsePAT = function(g, T) {
              return (g[T + 10] & 31) << 8 | g[T + 11];
            }, A.prototype._parsePMT = function(g, T, D, P) {
              var U, q, G, W, ie = { audio: -1, avc: -1, id3: -1, isAAC: !0 };
              for (U = (g[T + 1] & 15) << 8 | g[T + 2], q = T + 3 + U - 4, G = (g[T + 10] & 15) << 8 | g[T + 11], T += 12 + G; T < q; ) {
                switch (W = (g[T + 1] & 31) << 8 | g[T + 2], g[T]) {
                  case 207:
                    if (!P) {
                      d.b.log("unkown stream type:" + g[T]);
                      break;
                    }
                  case 15:
                    ie.audio === -1 && (ie.audio = W);
                    break;
                  case 21:
                    ie.id3 === -1 && (ie.id3 = W);
                    break;
                  case 219:
                    if (!P) {
                      d.b.log("unkown stream type:" + g[T]);
                      break;
                    }
                  case 27:
                    ie.avc === -1 && (ie.avc = W);
                    break;
                  case 3:
                  case 4:
                    D ? ie.audio === -1 && (ie.audio = W, ie.isAAC = !1) : d.b.log("MPEG audio found, not supported in this browser for now");
                    break;
                  case 36:
                    d.b.warn("HEVC stream type found, not supported for now");
                    break;
                  default:
                    d.b.log("unkown stream type:" + g[T]);
                    break;
                }
                T += ((g[T + 3] & 15) << 8 | g[T + 4]) + 5;
              }
              return ie;
            }, A.prototype._parsePES = function(g) {
              var T = 0, D, P, U, q, G, W, ie, Y, ue, ae = g.data;
              if (!g || g.size === 0)
                return null;
              for (; ae[0].length < 19 && ae.length > 1; ) {
                var me = new Uint8Array(ae[0].length + ae[1].length);
                me.set(ae[0]), me.set(ae[1], ae[0].length), ae[0] = me, ae.splice(1, 1);
              }
              if (D = ae[0], U = (D[0] << 16) + (D[1] << 8) + D[2], U === 1) {
                if (q = (D[4] << 8) + D[5], q && q > g.size - 6)
                  return null;
                P = D[7], P & 192 && (ie = (D[9] & 14) * 536870912 + // 1 << 29
                (D[10] & 255) * 4194304 + // 1 << 22
                (D[11] & 254) * 16384 + // 1 << 14
                (D[12] & 255) * 128 + // 1 << 7
                (D[13] & 254) / 2, ie > 4294967295 && (ie -= 8589934592), P & 64 ? (Y = (D[14] & 14) * 536870912 + // 1 << 29
                (D[15] & 255) * 4194304 + // 1 << 22
                (D[16] & 254) * 16384 + // 1 << 14
                (D[17] & 255) * 128 + // 1 << 7
                (D[18] & 254) / 2, Y > 4294967295 && (Y -= 8589934592), ie - Y > 60 * 9e4 && (d.b.warn(Math.round((ie - Y) / 9e4) + "s delta between PTS and DTS, align them"), ie = Y)) : Y = ie), G = D[8], ue = G + 9, g.size -= ue, W = new Uint8Array(g.size);
                for (var fe = 0, Q = ae.length; fe < Q; fe++) {
                  D = ae[fe];
                  var oe = D.byteLength;
                  if (ue)
                    if (ue > oe) {
                      ue -= oe;
                      continue;
                    } else
                      D = D.subarray(ue), oe -= ue, ue = 0;
                  W.set(D, T), T += oe;
                }
                return q && (q -= G + 3), { data: W, pts: ie, dts: Y, len: q };
              } else
                return null;
            }, A.prototype.pushAccesUnit = function(g, T) {
              if (g.units.length && g.frame) {
                var D = T.samples, P = D.length;
                !this.config.forceKeyFrameOnDiscontinuity || g.key === !0 || T.sps && (P || this.contiguous) ? (g.id = P, D.push(g)) : T.dropped++;
              }
              g.debug.length && d.b.log(g.pts + "/" + g.dts + ":" + g.debug);
            }, A.prototype._parseAVCPES = function(g, T) {
              var D = this, P = this._avcTrack, U = this._parseAVCNALu(g.data), q, G = this.avcSample, W, ie = !1, Y, ue = this.pushAccesUnit.bind(this), ae = function(fe, Q, oe, Ke) {
                return { key: fe, pts: Q, dts: oe, units: [], debug: Ke };
              };
              g.data = null, G && U.length && !P.audFound && (ue(G, P), G = this.avcSample = ae(!1, g.pts, g.dts, "")), U.forEach(function(me) {
                switch (me.type) {
                  case 1:
                    W = !0, G || (G = D.avcSample = ae(!0, g.pts, g.dts, "")), G.frame = !0;
                    var fe = me.data;
                    if (ie && fe.length > 4) {
                      var Q = new $t(fe).readSliceType();
                      (Q === 2 || Q === 4 || Q === 7 || Q === 9) && (G.key = !0);
                    }
                    break;
                  case 5:
                    W = !0, G || (G = D.avcSample = ae(!0, g.pts, g.dts, "")), G.key = !0, G.frame = !0;
                    break;
                  case 6:
                    W = !0, q = new $t(D.discardEPB(me.data)), q.readUByte();
                    for (var oe = 0, Ke = 0, nt = !1, ot = 0; !nt && q.bytesAvailable > 1; ) {
                      oe = 0;
                      do
                        ot = q.readUByte(), oe += ot;
                      while (ot === 255);
                      Ke = 0;
                      do
                        ot = q.readUByte(), Ke += ot;
                      while (ot === 255);
                      if (oe === 4 && q.bytesAvailable !== 0) {
                        nt = !0;
                        var qe = q.readUByte();
                        if (qe === 181) {
                          var Je = q.readUShort();
                          if (Je === 49) {
                            var Le = q.readUInt();
                            if (Le === 1195456820) {
                              var ct = q.readUByte();
                              if (ct === 3) {
                                var Lt = q.readUByte(), ut = q.readUByte(), At = 31 & Lt, Kt = [Lt, ut];
                                for (Y = 0; Y < At; Y++)
                                  Kt.push(q.readUByte()), Kt.push(q.readUByte()), Kt.push(q.readUByte());
                                D._insertSampleInOrder(D._txtTrack.samples, { type: 3, pts: g.pts, bytes: Kt });
                              }
                            }
                          }
                        }
                      } else if (Ke < q.bytesAvailable)
                        for (Y = 0; Y < Ke; Y++)
                          q.readUByte();
                    }
                    break;
                  case 7:
                    if (W = !0, ie = !0, !P.sps) {
                      q = new $t(me.data);
                      var rr = q.readSPS();
                      P.width = rr.width, P.height = rr.height, P.pixelRatio = rr.pixelRatio, P.sps = [me.data], P.duration = D._duration;
                      var Mt = me.data.subarray(1, 4), br = "avc1.";
                      for (Y = 0; Y < 3; Y++) {
                        var qt = Mt[Y].toString(16);
                        qt.length < 2 && (qt = "0" + qt), br += qt;
                      }
                      P.codec = br;
                    }
                    break;
                  case 8:
                    W = !0, P.pps || (P.pps = [me.data]);
                    break;
                  case 9:
                    W = !1, P.audFound = !0, G && ue(G, P), G = D.avcSample = ae(!1, g.pts, g.dts, "");
                    break;
                  case 12:
                    W = !1;
                    break;
                  default:
                    W = !1, G && (G.debug += "unknown NAL " + me.type + " ");
                    break;
                }
                if (G && W) {
                  var ir = G.units;
                  ir.push(me);
                }
              }), T && G && (ue(G, P), this.avcSample = null);
            }, A.prototype._insertSampleInOrder = function(g, T) {
              var D = g.length;
              if (D > 0) {
                if (T.pts >= g[D - 1].pts)
                  g.push(T);
                else
                  for (var P = D - 1; P >= 0; P--)
                    if (T.pts < g[P].pts) {
                      g.splice(P, 0, T);
                      break;
                    }
              } else
                g.push(T);
            }, A.prototype._getLastNalUnit = function() {
              var g = this.avcSample, T = void 0;
              if (!g || g.units.length === 0) {
                var D = this._avcTrack, P = D.samples;
                g = P[P.length - 1];
              }
              if (g) {
                var U = g.units;
                T = U[U.length - 1];
              }
              return T;
            }, A.prototype._parseAVCNALu = function(g) {
              var T = 0, D = g.byteLength, P, U, q = this._avcTrack, G = q.naluState || 0, W = G, ie = [], Y, ue, ae = -1, me;
              for (G === -1 && (ae = 0, me = g[0] & 31, G = 0, T = 1); T < D; ) {
                if (P = g[T++], !G) {
                  G = P ? 0 : 1;
                  continue;
                }
                if (G === 1) {
                  G = P ? 0 : 2;
                  continue;
                }
                if (!P)
                  G = 3;
                else if (P === 1) {
                  if (ae >= 0)
                    Y = { data: g.subarray(ae, T - G - 1), type: me }, ie.push(Y);
                  else {
                    var fe = this._getLastNalUnit();
                    if (fe && (W && T <= 4 - W && fe.state && (fe.data = fe.data.subarray(0, fe.data.byteLength - W)), U = T - G - 1, U > 0)) {
                      var Q = new Uint8Array(fe.data.byteLength + U);
                      Q.set(fe.data, 0), Q.set(g.subarray(0, U), fe.data.byteLength), fe.data = Q;
                    }
                  }
                  T < D ? (ue = g[T] & 31, ae = T, me = ue, G = 0) : G = -1;
                } else
                  G = 0;
              }
              if (ae >= 0 && G >= 0 && (Y = { data: g.subarray(ae, D), type: me, state: G }, ie.push(Y)), ie.length === 0) {
                var oe = this._getLastNalUnit();
                if (oe) {
                  var Ke = new Uint8Array(oe.data.byteLength + g.byteLength);
                  Ke.set(oe.data, 0), Ke.set(g, oe.data.byteLength), oe.data = Ke;
                }
              }
              return q.naluState = G, ie;
            }, A.prototype.discardEPB = function(g) {
              for (var T = g.byteLength, D = [], P = 1, U, q; P < T - 2; )
                g[P] === 0 && g[P + 1] === 0 && g[P + 2] === 3 ? (D.push(P + 2), P += 2) : P++;
              if (D.length === 0)
                return g;
              U = T - D.length, q = new Uint8Array(U);
              var G = 0;
              for (P = 0; P < U; G++, P++)
                G === D[0] && (G++, D.shift()), q[P] = g[G];
              return q;
            }, A.prototype._parseAACPES = function(g) {
              var T = this._audioTrack, D = g.data, P = g.pts, U = 0, q = this.aacOverFlow, G = this.aacLastPTS, W, ie, Y, ue, ae;
              if (q) {
                var me = new Uint8Array(q.byteLength + D.byteLength);
                me.set(q, 0), me.set(D, q.byteLength), D = me;
              }
              for (Y = U, ae = D.length; Y < ae - 1 && !N(D, Y); Y++)
                ;
              if (Y) {
                var fe, Q;
                if (Y < ae - 1 ? (fe = "AAC PES did not start with ADTS header,offset:" + Y, Q = !1) : (fe = "no ADTS header found in AAC PES", Q = !0), d.b.warn("parsing error:" + fe), this.observer.trigger(y.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.FRAG_PARSING_ERROR, fatal: Q, reason: fe }), Q)
                  return;
              }
              if (te(T, this.observer, D, Y, this.audioCodec), ie = 0, W = re(T.samplerate), q && G) {
                var oe = G + W;
                Math.abs(oe - P) > 1 && (d.b.log("AAC: align PTS for overlapping frames by " + Math.round((oe - P) / 90)), P = oe);
              }
              for (; Y < ae; )
                if (N(D, Y) && Y + 5 < ae) {
                  var Ke = F(T, D, Y, P, ie);
                  if (Ke)
                    Y += Ke.length, ue = Ke.sample.pts, ie++;
                  else
                    break;
                } else
                  Y++;
              Y < ae ? q = D.subarray(Y, ae) : q = null, this.aacOverFlow = q, this.aacLastPTS = ue;
            }, A.prototype._parseMPEGPES = function(g) {
              for (var T = g.data, D = T.length, P = 0, U = 0, q = g.pts; U < D; )
                if (tt.isHeader(T, U)) {
                  var G = tt.appendFrame(this._audioTrack, T, U, q, P);
                  if (G)
                    U += G.length, P++;
                  else
                    break;
                } else
                  U++;
            }, A.prototype._parseID3PES = function(g) {
              this._id3Track.samples.push(g);
            }, A;
          }(), Fe = ht;
          function tr(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var it = function() {
            function A(j, g, T) {
              tr(this, A), this.observer = j, this.config = T, this.remuxer = g;
            }
            return A.prototype.resetInitSegment = function(g, T, D, P) {
              this._audioTrack = { container: "audio/mpeg", type: "audio", id: -1, sequenceNumber: 0, isAAC: !1, samples: [], len: 0, manifestCodec: T, duration: P, inputTimeScale: 9e4 };
            }, A.prototype.resetTimeStamp = function() {
            }, A.probe = function(g) {
              var T, D, P = z.a.getID3Data(g, 0);
              if (P && z.a.getTimeStamp(P) !== void 0) {
                for (T = P.length, D = Math.min(g.length - 1, T + 100); T < D; T++)
                  if (tt.probe(g, T))
                    return d.b.log("MPEG Audio sync word found !"), !0;
              }
              return !1;
            }, A.prototype.append = function(g, T, D, P) {
              for (var U = z.a.getID3Data(g, 0), q = z.a.getTimeStamp(U), G = q ? 90 * q : T * 9e4, W = U.length, ie = g.length, Y = 0, ue = 0, ae = this._audioTrack, me = [{ pts: G, dts: G, data: U }]; W < ie; )
                if (tt.isHeader(g, W)) {
                  var fe = tt.appendFrame(ae, g, W, G, Y);
                  if (fe)
                    W += fe.length, ue = fe.sample.pts, Y++;
                  else
                    break;
                } else z.a.isHeader(g, W) ? (U = z.a.getID3Data(g, W), me.push({ pts: ue, dts: ue, data: U }), W += U.length) : W++;
              this.remuxer.remux(ae, { samples: [] }, { samples: me, inputTimeScale: 9e4 }, { samples: [] }, T, D, P);
            }, A.prototype.destroy = function() {
            }, A;
          }(), yr = it;
          function St(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var xt = function() {
            function A() {
              St(this, A);
            }
            return A.getSilentFrame = function(g, T) {
              switch (g) {
                case "mp4a.40.2":
                  if (T === 1)
                    return new Uint8Array([0, 200, 0, 128, 35, 128]);
                  if (T === 2)
                    return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                  if (T === 3)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                  if (T === 4)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                  if (T === 5)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                  if (T === 6)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                  break;
                default:
                  if (T === 1)
                    return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  if (T === 2)
                    return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  if (T === 3)
                    return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  break;
              }
              return null;
            }, A;
          }(), Ct = xt;
          function mt(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ut = Math.pow(2, 32) - 1, Ze = function() {
            function A() {
              mt(this, A);
            }
            return A.init = function() {
              A.types = {
                avc1: [],
                // codingname
                avcC: [],
                btrt: [],
                dinf: [],
                dref: [],
                esds: [],
                ftyp: [],
                hdlr: [],
                mdat: [],
                mdhd: [],
                mdia: [],
                mfhd: [],
                minf: [],
                moof: [],
                moov: [],
                mp4a: [],
                ".mp3": [],
                mvex: [],
                mvhd: [],
                pasp: [],
                sdtp: [],
                stbl: [],
                stco: [],
                stsc: [],
                stsd: [],
                stsz: [],
                stts: [],
                tfdt: [],
                tfhd: [],
                traf: [],
                trak: [],
                trun: [],
                trex: [],
                tkhd: [],
                vmhd: [],
                smhd: []
              };
              var g;
              for (g in A.types)
                A.types.hasOwnProperty(g) && (A.types[g] = [g.charCodeAt(0), g.charCodeAt(1), g.charCodeAt(2), g.charCodeAt(3)]);
              var T = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // pre_defined
                118,
                105,
                100,
                101,
                // handler_type: 'vide'
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                86,
                105,
                100,
                101,
                111,
                72,
                97,
                110,
                100,
                108,
                101,
                114,
                0
                // name: 'VideoHandler'
              ]), D = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // pre_defined
                115,
                111,
                117,
                110,
                // handler_type: 'soun'
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                83,
                111,
                117,
                110,
                100,
                72,
                97,
                110,
                100,
                108,
                101,
                114,
                0
                // name: 'SoundHandler'
              ]);
              A.HDLR_TYPES = {
                video: T,
                audio: D
              };
              var P = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                1,
                // entry_count
                0,
                0,
                0,
                12,
                // entry_size
                117,
                114,
                108,
                32,
                // 'url' type
                0,
                // version 0
                0,
                0,
                1
                // entry_flags
              ]), U = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0
                // entry_count
              ]);
              A.STTS = A.STSC = A.STCO = U, A.STSZ = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // sample_size
                0,
                0,
                0,
                0
              ]), A.VMHD = new Uint8Array([
                0,
                // version
                0,
                0,
                1,
                // flags
                0,
                0,
                // graphicsmode
                0,
                0,
                0,
                0,
                0,
                0
                // opcolor
              ]), A.SMHD = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                // balance
                0,
                0
                // reserved
              ]), A.STSD = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                1
              ]);
              var q = new Uint8Array([105, 115, 111, 109]), G = new Uint8Array([97, 118, 99, 49]), W = new Uint8Array([0, 0, 0, 1]);
              A.FTYP = A.box(A.types.ftyp, q, W, q, G), A.DINF = A.box(A.types.dinf, A.box(A.types.dref, P));
            }, A.box = function(g) {
              for (var T = Array.prototype.slice.call(arguments, 1), D = 8, P = T.length, U = P, q; P--; )
                D += T[P].byteLength;
              for (q = new Uint8Array(D), q[0] = D >> 24 & 255, q[1] = D >> 16 & 255, q[2] = D >> 8 & 255, q[3] = D & 255, q.set(g, 4), P = 0, D = 8; P < U; P++)
                q.set(T[P], D), D += T[P].byteLength;
              return q;
            }, A.hdlr = function(g) {
              return A.box(A.types.hdlr, A.HDLR_TYPES[g]);
            }, A.mdat = function(g) {
              return A.box(A.types.mdat, g);
            }, A.mdhd = function(g, T) {
              T *= g;
              var D = Math.floor(T / (Ut + 1)), P = Math.floor(T % (Ut + 1));
              return A.box(A.types.mdhd, new Uint8Array([
                1,
                // version 1
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                g >> 24 & 255,
                g >> 16 & 255,
                g >> 8 & 255,
                g & 255,
                // timescale
                D >> 24,
                D >> 16 & 255,
                D >> 8 & 255,
                D & 255,
                P >> 24,
                P >> 16 & 255,
                P >> 8 & 255,
                P & 255,
                85,
                196,
                // 'und' language (undetermined)
                0,
                0
              ]));
            }, A.mdia = function(g) {
              return A.box(A.types.mdia, A.mdhd(g.timescale, g.duration), A.hdlr(g.type), A.minf(g));
            }, A.mfhd = function(g) {
              return A.box(
                A.types.mfhd,
                new Uint8Array([
                  0,
                  0,
                  0,
                  0,
                  // flags
                  g >> 24,
                  g >> 16 & 255,
                  g >> 8 & 255,
                  g & 255
                ])
                // sequence_number
              );
            }, A.minf = function(g) {
              return g.type === "audio" ? A.box(A.types.minf, A.box(A.types.smhd, A.SMHD), A.DINF, A.stbl(g)) : A.box(A.types.minf, A.box(A.types.vmhd, A.VMHD), A.DINF, A.stbl(g));
            }, A.moof = function(g, T, D) {
              return A.box(A.types.moof, A.mfhd(g), A.traf(D, T));
            }, A.moov = function(g) {
              for (var T = g.length, D = []; T--; )
                D[T] = A.trak(g[T]);
              return A.box.apply(null, [A.types.moov, A.mvhd(g[0].timescale, g[0].duration)].concat(D).concat(A.mvex(g)));
            }, A.mvex = function(g) {
              for (var T = g.length, D = []; T--; )
                D[T] = A.trex(g[T]);
              return A.box.apply(null, [A.types.mvex].concat(D));
            }, A.mvhd = function(g, T) {
              T *= g;
              var D = Math.floor(T / (Ut + 1)), P = Math.floor(T % (Ut + 1)), U = new Uint8Array([
                1,
                // version 1
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                g >> 24 & 255,
                g >> 16 & 255,
                g >> 8 & 255,
                g & 255,
                // timescale
                D >> 24,
                D >> 16 & 255,
                D >> 8 & 255,
                D & 255,
                P >> 24,
                P >> 16 & 255,
                P >> 8 & 255,
                P & 255,
                0,
                1,
                0,
                0,
                // 1.0 rate
                1,
                0,
                // 1.0 volume
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                64,
                0,
                0,
                0,
                // transformation: unity matrix
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // pre_defined
                255,
                255,
                255,
                255
                // next_track_ID
              ]);
              return A.box(A.types.mvhd, U);
            }, A.sdtp = function(g) {
              var T = g.samples || [], D = new Uint8Array(4 + T.length), P, U;
              for (U = 0; U < T.length; U++)
                P = T[U].flags, D[U + 4] = P.dependsOn << 4 | P.isDependedOn << 2 | P.hasRedundancy;
              return A.box(A.types.sdtp, D);
            }, A.stbl = function(g) {
              return A.box(A.types.stbl, A.stsd(g), A.box(A.types.stts, A.STTS), A.box(A.types.stsc, A.STSC), A.box(A.types.stsz, A.STSZ), A.box(A.types.stco, A.STCO));
            }, A.avc1 = function(g) {
              var T = [], D = [], P, U, q;
              for (P = 0; P < g.sps.length; P++)
                U = g.sps[P], q = U.byteLength, T.push(q >>> 8 & 255), T.push(q & 255), T = T.concat(Array.prototype.slice.call(U));
              for (P = 0; P < g.pps.length; P++)
                U = g.pps[P], q = U.byteLength, D.push(q >>> 8 & 255), D.push(q & 255), D = D.concat(Array.prototype.slice.call(U));
              var G = A.box(A.types.avcC, new Uint8Array([
                1,
                // version
                T[3],
                // profile
                T[4],
                // profile compat
                T[5],
                // level
                255,
                // lengthSizeMinusOne, hard-coded to 4 bytes
                224 | g.sps.length
                // 3bit reserved (111) + numOfSequenceParameterSets
              ].concat(T).concat([
                g.pps.length
                // numOfPictureParameterSets
              ]).concat(D))), W = g.width, ie = g.height, Y = g.pixelRatio[0], ue = g.pixelRatio[1];
              return A.box(
                A.types.avc1,
                new Uint8Array([
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  1,
                  // data_reference_index
                  0,
                  0,
                  // pre_defined
                  0,
                  0,
                  // reserved
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  // pre_defined
                  W >> 8 & 255,
                  W & 255,
                  // width
                  ie >> 8 & 255,
                  ie & 255,
                  // height
                  0,
                  72,
                  0,
                  0,
                  // horizresolution
                  0,
                  72,
                  0,
                  0,
                  // vertresolution
                  0,
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  1,
                  // frame_count
                  18,
                  100,
                  97,
                  105,
                  108,
                  //dailymotion/hls.js
                  121,
                  109,
                  111,
                  116,
                  105,
                  111,
                  110,
                  47,
                  104,
                  108,
                  115,
                  46,
                  106,
                  115,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  // compressorname
                  0,
                  24,
                  // depth = 24
                  17,
                  17
                ]),
                // pre_defined = -1
                G,
                A.box(A.types.btrt, new Uint8Array([
                  0,
                  28,
                  156,
                  128,
                  // bufferSizeDB
                  0,
                  45,
                  198,
                  192,
                  // maxBitrate
                  0,
                  45,
                  198,
                  192
                ])),
                // avgBitrate
                A.box(A.types.pasp, new Uint8Array([
                  Y >> 24,
                  // hSpacing
                  Y >> 16 & 255,
                  Y >> 8 & 255,
                  Y & 255,
                  ue >> 24,
                  // vSpacing
                  ue >> 16 & 255,
                  ue >> 8 & 255,
                  ue & 255
                ]))
              );
            }, A.esds = function(g) {
              var T = g.config.length;
              return new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                3,
                // descriptor_type
                23 + T,
                // length
                0,
                1,
                //es_id
                0,
                // stream_priority
                4,
                // descriptor_type
                15 + T,
                // length
                64,
                //codec : mpeg4_audio
                21,
                // stream_type
                0,
                0,
                0,
                // buffer_size
                0,
                0,
                0,
                0,
                // maxBitrate
                0,
                0,
                0,
                0,
                // avgBitrate
                5
                // descriptor_type
              ].concat([T]).concat(g.config).concat([6, 1, 2]));
            }, A.mp4a = function(g) {
              var T = g.samplerate;
              return A.box(A.types.mp4a, new Uint8Array([
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                // reserved
                0,
                1,
                // data_reference_index
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                g.channelCount,
                // channelcount
                0,
                16,
                // sampleSize:16bits
                0,
                0,
                0,
                0,
                // reserved2
                T >> 8 & 255,
                T & 255,
                //
                0,
                0
              ]), A.box(A.types.esds, A.esds(g)));
            }, A.mp3 = function(g) {
              var T = g.samplerate;
              return A.box(A.types[".mp3"], new Uint8Array([
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                // reserved
                0,
                1,
                // data_reference_index
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                g.channelCount,
                // channelcount
                0,
                16,
                // sampleSize:16bits
                0,
                0,
                0,
                0,
                // reserved2
                T >> 8 & 255,
                T & 255,
                //
                0,
                0
              ]));
            }, A.stsd = function(g) {
              return g.type === "audio" ? !g.isAAC && g.codec === "mp3" ? A.box(A.types.stsd, A.STSD, A.mp3(g)) : A.box(A.types.stsd, A.STSD, A.mp4a(g)) : A.box(A.types.stsd, A.STSD, A.avc1(g));
            }, A.tkhd = function(g) {
              var T = g.id, D = g.duration * g.timescale, P = g.width, U = g.height, q = Math.floor(D / (Ut + 1)), G = Math.floor(D % (Ut + 1));
              return A.box(A.types.tkhd, new Uint8Array([
                1,
                // version 1
                0,
                0,
                7,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                T >> 24 & 255,
                T >> 16 & 255,
                T >> 8 & 255,
                T & 255,
                // track_ID
                0,
                0,
                0,
                0,
                // reserved
                q >> 24,
                q >> 16 & 255,
                q >> 8 & 255,
                q & 255,
                G >> 24,
                G >> 16 & 255,
                G >> 8 & 255,
                G & 255,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                // layer
                0,
                0,
                // alternate_group
                0,
                0,
                // non-audio track volume
                0,
                0,
                // reserved
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                64,
                0,
                0,
                0,
                // transformation: unity matrix
                P >> 8 & 255,
                P & 255,
                0,
                0,
                // width
                U >> 8 & 255,
                U & 255,
                0,
                0
                // height
              ]));
            }, A.traf = function(g, T) {
              var D = A.sdtp(g), P = g.id, U = Math.floor(T / (Ut + 1)), q = Math.floor(T % (Ut + 1));
              return A.box(
                A.types.traf,
                A.box(
                  A.types.tfhd,
                  new Uint8Array([
                    0,
                    // version 0
                    0,
                    0,
                    0,
                    // flags
                    P >> 24,
                    P >> 16 & 255,
                    P >> 8 & 255,
                    P & 255
                  ])
                  // track_ID
                ),
                A.box(A.types.tfdt, new Uint8Array([
                  1,
                  // version 1
                  0,
                  0,
                  0,
                  // flags
                  U >> 24,
                  U >> 16 & 255,
                  U >> 8 & 255,
                  U & 255,
                  q >> 24,
                  q >> 16 & 255,
                  q >> 8 & 255,
                  q & 255
                ])),
                A.trun(g, D.length + 16 + // tfhd
                20 + // tfdt
                8 + // traf header
                16 + // mfhd
                8 + // moof header
                8),
                // mdat header
                D
              );
            }, A.trak = function(g) {
              return g.duration = g.duration || 4294967295, A.box(A.types.trak, A.tkhd(g), A.mdia(g));
            }, A.trex = function(g) {
              var T = g.id;
              return A.box(A.types.trex, new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                T >> 24,
                T >> 16 & 255,
                T >> 8 & 255,
                T & 255,
                // track_ID
                0,
                0,
                0,
                1,
                // default_sample_description_index
                0,
                0,
                0,
                0,
                // default_sample_duration
                0,
                0,
                0,
                0,
                // default_sample_size
                0,
                1,
                0,
                1
                // default_sample_flags
              ]));
            }, A.trun = function(g, T) {
              var D = g.samples || [], P = D.length, U = 12 + 16 * P, q = new Uint8Array(U), G, W, ie, Y, ue, ae;
              for (T += 8 + U, q.set([
                0,
                // version 0
                0,
                15,
                1,
                // flags
                P >>> 24 & 255,
                P >>> 16 & 255,
                P >>> 8 & 255,
                P & 255,
                // sample_count
                T >>> 24 & 255,
                T >>> 16 & 255,
                T >>> 8 & 255,
                T & 255
                // data_offset
              ], 0), G = 0; G < P; G++)
                W = D[G], ie = W.duration, Y = W.size, ue = W.flags, ae = W.cts, q.set([
                  ie >>> 24 & 255,
                  ie >>> 16 & 255,
                  ie >>> 8 & 255,
                  ie & 255,
                  // sample_duration
                  Y >>> 24 & 255,
                  Y >>> 16 & 255,
                  Y >>> 8 & 255,
                  Y & 255,
                  // sample_size
                  ue.isLeading << 2 | ue.dependsOn,
                  ue.isDependedOn << 6 | ue.hasRedundancy << 4 | ue.paddingValue << 1 | ue.isNonSync,
                  ue.degradPrio & 61440,
                  ue.degradPrio & 15,
                  // sample_flags
                  ae >>> 24 & 255,
                  ae >>> 16 & 255,
                  ae >>> 8 & 255,
                  ae & 255
                  // sample_composition_time_offset
                ], 12 + 16 * G);
              return A.box(A.types.trun, q);
            }, A.initSegment = function(g) {
              A.types || A.init();
              var T = A.moov(g), D;
              return D = new Uint8Array(A.FTYP.byteLength + T.byteLength), D.set(A.FTYP), D.set(T, A.FTYP.byteLength), D;
            }, A;
          }(), Gt = Ze;
          function Ye(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var Et = 10 * 1e3, Xr = function() {
            function A(j, g, T, D) {
              Ye(this, A), this.observer = j, this.config = g, this.typeSupported = T;
              var P = navigator.userAgent;
              this.isSafari = D && D.indexOf("Apple") > -1 && P && !P.match("CriOS"), this.ISGenerated = !1;
            }
            return A.prototype.destroy = function() {
            }, A.prototype.resetTimeStamp = function(g) {
              this._initPTS = this._initDTS = g;
            }, A.prototype.resetInitSegment = function() {
              this.ISGenerated = !1;
            }, A.prototype.remux = function(g, T, D, P, U, q, G) {
              if (this.ISGenerated || this.generateIS(g, T, U), this.ISGenerated) {
                var W = g.samples.length, ie = T.samples.length, Y = U, ue = U;
                if (W && ie) {
                  var ae = (g.samples[0].dts - T.samples[0].dts) / T.inputTimeScale;
                  Y += Math.max(0, ae), ue += Math.max(0, -ae);
                }
                if (W) {
                  g.timescale || (d.b.warn("regenerate InitSegment as audio detected"), this.generateIS(g, T, U));
                  var me = this.remuxAudio(g, Y, q, G);
                  if (ie) {
                    var fe = void 0;
                    me && (fe = me.endPTS - me.startPTS), T.timescale || (d.b.warn("regenerate InitSegment as video detected"), this.generateIS(g, T, U)), this.remuxVideo(T, ue, q, fe, G);
                  }
                } else {
                  var Q = void 0;
                  ie && (Q = this.remuxVideo(T, ue, q, G)), Q && g.codec && this.remuxEmptyAudio(g, Y, q, Q);
                }
              }
              D.samples.length && this.remuxID3(D, U), P.samples.length && this.remuxText(P, U), this.observer.trigger(y.a.FRAG_PARSED);
            }, A.prototype.generateIS = function(g, T, D) {
              var P = this.observer, U = g.samples, q = T.samples, G = this.typeSupported, W = "audio/mp4", ie = {}, Y = { tracks: ie }, ue = this._initPTS === void 0, ae, me;
              if (ue && (ae = me = 1 / 0), g.config && U.length && (g.timescale = g.samplerate, d.b.log("audio sampling rate : " + g.samplerate), g.isAAC || (G.mpeg ? (W = "audio/mpeg", g.codec = "") : G.mp3 && (g.codec = "mp3")), ie.audio = {
                container: W,
                codec: g.codec,
                initSegment: !g.isAAC && G.mpeg ? new Uint8Array() : Gt.initSegment([g]),
                metadata: {
                  channelCount: g.channelCount
                }
              }, ue && (ae = me = U[0].pts - g.inputTimeScale * D)), T.sps && T.pps && q.length) {
                var fe = T.inputTimeScale;
                T.timescale = fe, ie.video = {
                  container: "video/mp4",
                  codec: T.codec,
                  initSegment: Gt.initSegment([T]),
                  metadata: {
                    width: T.width,
                    height: T.height
                  }
                }, ue && (ae = Math.min(ae, q[0].pts - fe * D), me = Math.min(me, q[0].dts - fe * D), this.observer.trigger(y.a.INIT_PTS_FOUND, { initPTS: ae }));
              }
              Object.keys(ie).length ? (P.trigger(y.a.FRAG_PARSING_INIT_SEGMENT, Y), this.ISGenerated = !0, ue && (this._initPTS = ae, this._initDTS = me)) : P.trigger(y.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.FRAG_PARSING_ERROR, fatal: !1, reason: "no audio/video samples found" });
            }, A.prototype.remuxVideo = function(g, T, D, P, U) {
              var q = 8, G = g.timescale, W, ie, Y, ue, ae, me, fe, Q = g.samples, oe = [], Ke = Q.length, nt = this._PTSNormalize, ot = this._initDTS, qe = this.nextAvcDts, Je = this.isSafari;
              Je && (D |= Q.length && qe && (U && Math.abs(T - qe / G) < 0.1 || Math.abs(Q[0].pts - qe - ot) < G / 5)), D || (qe = T * G), Q.forEach(function(c) {
                c.pts = nt(c.pts - ot, qe), c.dts = nt(c.dts - ot, qe);
              }), Q.sort(function(c, R) {
                var L = c.dts - R.dts, K = c.pts - R.pts;
                return L || K || c.id - R.id;
              });
              var Le = Q.reduce(function(c, R) {
                return Math.max(Math.min(c, R.pts - R.dts), -18e3);
              }, 0);
              if (Le < 0) {
                d.b.warn("PTS < DTS detected in video samples, shifting DTS by " + Math.round(Le / 90) + " ms to overcome this issue");
                for (var ct = 0; ct < Q.length; ct++)
                  Q[ct].dts += Le;
              }
              var Lt = Q[0];
              ae = Math.max(Lt.dts, 0), ue = Math.max(Lt.pts, 0);
              var ut = Math.round((ae - qe) / 90);
              D && ut && (ut > 1 ? d.b.log("AVC:" + ut + " ms hole between fragments detected,filling it") : ut < -1 && d.b.log("AVC:" + -ut + " ms overlapping between fragments detected"), ae = qe, Q[0].dts = ae, ue = Math.max(ue - ut, qe), Q[0].pts = ue, d.b.log("Video/PTS/DTS adjusted: " + Math.round(ue / 90) + "/" + Math.round(ae / 90) + ",delta:" + ut + " ms")), Lt = Q[Q.length - 1], fe = Math.max(Lt.dts, 0), me = Math.max(Lt.pts, 0, fe), Je && (W = Math.round((fe - ae) / (Q.length - 1)));
              for (var At = 0, Kt = 0, rr = 0; rr < Ke; rr++) {
                for (var Mt = Q[rr], br = Mt.units, qt = br.length, ir = 0, Hr = 0; Hr < qt; Hr++)
                  ir += br[Hr].data.length;
                Kt += ir, At += qt, Mt.length = ir, Je ? Mt.dts = ae + rr * W : Mt.dts = Math.max(Mt.dts, ae), Mt.pts = Math.max(Mt.pts, Mt.dts);
              }
              var Zr = Kt + 4 * At + 8;
              try {
                ie = new Uint8Array(Zr);
              } catch {
                this.observer.trigger(y.a.ERROR, { type: b.b.MUX_ERROR, details: b.a.REMUX_ALLOC_ERROR, fatal: !1, bytes: Zr, reason: "fail allocating video mdat " + Zr });
                return;
              }
              var Ui = new DataView(ie.buffer);
              Ui.setUint32(0, Zr), ie.set(Gt.types.mdat, 4);
              for (var Xt = 0; Xt < Ke; Xt++) {
                for (var kt = Q[Xt], Cr = kt.units, Wr = 0, Vr = void 0, Oi = 0, dn = Cr.length; Oi < dn; Oi++) {
                  var Ki = Cr[Oi], Mi = Ki.data, jr = Ki.data.byteLength;
                  Ui.setUint32(q, jr), q += 4, ie.set(Mi, q), q += jr, Wr += 4 + jr;
                }
                if (Je)
                  Vr = Math.max(0, W * Math.round((kt.pts - kt.dts) / W));
                else {
                  if (Xt < Ke - 1)
                    W = Q[Xt + 1].dts - kt.dts;
                  else {
                    var Yr = this.config, Jr = kt.dts - Q[Xt > 0 ? Xt - 1 : Xt].dts;
                    if (Yr.stretchShortVideoTrack) {
                      var fn = Yr.maxBufferHole, Fr = Yr.maxSeekHole, Ma = Math.floor(Math.min(fn, Fr) * G), kn = (P ? ue + P * G : this.nextAudioPts) - kt.pts;
                      kn > Ma ? (W = kn - Jr, W < 0 && (W = Jr), d.b.log("It is approximately " + kn / 90 + " ms to the next segment; using duration " + W / 90 + " ms for the last video frame.")) : W = Jr;
                    } else
                      W = Jr;
                  }
                  Vr = Math.round(kt.pts - kt.dts);
                }
                oe.push({
                  size: Wr,
                  // constant duration
                  duration: W,
                  cts: Vr,
                  flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: kt.key ? 2 : 1,
                    isNonSync: kt.key ? 0 : 1
                  }
                });
              }
              this.nextAvcDts = fe + W;
              var Na = g.dropped;
              if (g.len = 0, g.nbNalu = 0, g.dropped = 0, oe.length && navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                var na = oe[0].flags;
                na.dependsOn = 2, na.isNonSync = 0;
              }
              g.samples = oe, Y = Gt.moof(g.sequenceNumber++, ae, g), g.samples = [];
              var O = {
                data1: Y,
                data2: ie,
                startPTS: ue / G,
                endPTS: (me + W) / G,
                startDTS: ae / G,
                endDTS: this.nextAvcDts / G,
                type: "video",
                nb: oe.length,
                dropped: Na
              };
              return this.observer.trigger(y.a.FRAG_PARSING_DATA, O), O;
            }, A.prototype.remuxAudio = function(g, T, D, P) {
              var U = g.inputTimeScale, q = g.timescale, G = U / q, W = g.isAAC ? 1024 : 1152, ie = W * G, Y = this._PTSNormalize, ue = this._initDTS, ae = !g.isAAC && this.typeSupported.mpeg, me, fe, Q, oe, Ke, nt, ot, qe = g.samples, Je = [], Le = this.nextAudioPts;
              if (D |= qe.length && Le && (P && Math.abs(T - Le / U) < 0.1 || Math.abs(qe[0].pts - Le - ue) < 20 * ie), qe.forEach(function(Fr) {
                Fr.pts = Fr.dts = Y(Fr.pts - ue, T * U);
              }), qe = qe.filter(function(Fr) {
                return Fr.pts >= 0;
              }), qe.length !== 0) {
                if (D || (P ? Le = T * U : Le = qe[0].pts), g.isAAC)
                  for (var ct = this.config.maxAudioFramesDrift, Lt = 0, ut = Le; Lt < qe.length; ) {
                    var At = qe[Lt], Kt, rr = At.pts;
                    Kt = rr - ut;
                    var Mt = Math.abs(1e3 * Kt / U);
                    if (Kt <= -ct * ie)
                      d.b.warn("Dropping 1 audio frame @ " + (ut / U).toFixed(3) + "s due to " + Math.round(Mt) + " ms overlap."), qe.splice(Lt, 1), g.len -= At.unit.length;
                    else if (Kt >= ct * ie && Mt < Et && ut) {
                      var br = Math.round(Kt / ie);
                      d.b.warn("Injecting " + br + " audio frame @ " + (ut / U).toFixed(3) + "s due to " + Math.round(1e3 * Kt / U) + " ms gap.");
                      for (var qt = 0; qt < br; qt++) {
                        var ir = Math.max(ut, 0);
                        Q = Ct.getSilentFrame(g.manifestCodec || g.codec, g.channelCount), Q || (d.b.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), Q = At.unit.subarray()), qe.splice(Lt, 0, { unit: Q, pts: ir, dts: ir }), g.len += Q.length, ut += ie, Lt++;
                      }
                      At.pts = At.dts = ut, ut += ie, Lt++;
                    } else
                      At.pts = At.dts = ut, ut += ie, Lt++;
                  }
                for (var Hr = 0, Zr = qe.length; Hr < Zr; Hr++) {
                  var Ui = qe[Hr], Xt = Ui.unit, kt = Ui.pts;
                  if (ot !== void 0)
                    fe.duration = Math.round((kt - ot) / G);
                  else {
                    var Cr = Math.round(1e3 * (kt - Le) / U), Wr = 0;
                    if (D && g.isAAC && Cr) {
                      if (Cr > 0 && Cr < Et)
                        Wr = Math.round((kt - Le) / ie), d.b.log(Cr + " ms hole between AAC samples detected,filling it"), Wr > 0 && (Q = Ct.getSilentFrame(g.manifestCodec || g.codec, g.channelCount), Q || (Q = Xt.subarray()), g.len += Wr * Q.length);
                      else if (Cr < -12) {
                        d.b.log("drop overlapping AAC sample, expected/parsed/delta:" + (Le / U).toFixed(3) + "s/" + (kt / U).toFixed(3) + "s/" + -Cr + "ms"), g.len -= Xt.byteLength;
                        continue;
                      }
                      kt = Le;
                    }
                    if (nt = kt, g.len > 0) {
                      var Vr = ae ? g.len : g.len + 8;
                      me = ae ? 0 : 8;
                      try {
                        oe = new Uint8Array(Vr);
                      } catch {
                        this.observer.trigger(y.a.ERROR, { type: b.b.MUX_ERROR, details: b.a.REMUX_ALLOC_ERROR, fatal: !1, bytes: Vr, reason: "fail allocating audio mdat " + Vr });
                        return;
                      }
                      if (!ae) {
                        var Oi = new DataView(oe.buffer);
                        Oi.setUint32(0, Vr), oe.set(Gt.types.mdat, 4);
                      }
                    } else
                      return;
                    for (var dn = 0; dn < Wr; dn++)
                      Q = Ct.getSilentFrame(g.manifestCodec || g.codec, g.channelCount), Q || (d.b.log("Unable to get silent frame for given audio codec; duplicating this frame instead."), Q = Xt.subarray()), oe.set(Q, me), me += Q.byteLength, fe = {
                        size: Q.byteLength,
                        cts: 0,
                        duration: 1024,
                        flags: {
                          isLeading: 0,
                          isDependedOn: 0,
                          hasRedundancy: 0,
                          degradPrio: 0,
                          dependsOn: 1
                        }
                      }, Je.push(fe);
                  }
                  oe.set(Xt, me);
                  var Ki = Xt.byteLength;
                  me += Ki, fe = {
                    size: Ki,
                    cts: 0,
                    duration: 0,
                    flags: {
                      isLeading: 0,
                      isDependedOn: 0,
                      hasRedundancy: 0,
                      degradPrio: 0,
                      dependsOn: 1
                    }
                  }, Je.push(fe), ot = kt;
                }
                var Mi = 0, jr = Je.length;
                if (jr >= 2 && (Mi = Je[jr - 2].duration, fe.duration = Mi), jr) {
                  this.nextAudioPts = Le = ot + G * Mi, g.len = 0, g.samples = Je, ae ? Ke = new Uint8Array() : Ke = Gt.moof(g.sequenceNumber++, nt / G, g), g.samples = [];
                  var Yr = nt / U, Jr = Le / U, fn = {
                    data1: Ke,
                    data2: oe,
                    startPTS: Yr,
                    endPTS: Jr,
                    startDTS: Yr,
                    endDTS: Jr,
                    type: "audio",
                    nb: jr
                  };
                  return this.observer.trigger(y.a.FRAG_PARSING_DATA, fn), fn;
                }
                return null;
              }
            }, A.prototype.remuxEmptyAudio = function(g, T, D, P) {
              var U = g.inputTimeScale, q = g.samplerate ? g.samplerate : U, G = U / q, W = this.nextAudioPts, ie = (W !== void 0 ? W : P.startDTS * U) + this._initDTS, Y = P.endDTS * U + this._initDTS, ue = 1024, ae = G * ue, me = Math.ceil((Y - ie) / ae), fe = Ct.getSilentFrame(g.manifestCodec || g.codec, g.channelCount);
              if (d.b.warn("remux empty Audio"), !fe) {
                d.b.trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!");
                return;
              }
              for (var Q = [], oe = 0; oe < me; oe++) {
                var Ke = ie + oe * ae;
                Q.push({ unit: fe, pts: Ke, dts: Ke }), g.len += fe.length;
              }
              g.samples = Q, this.remuxAudio(g, T, D);
            }, A.prototype.remuxID3 = function(g, T) {
              var D = g.samples.length, P, U = g.inputTimeScale, q = this._initPTS, G = this._initDTS;
              if (D) {
                for (var W = 0; W < D; W++)
                  P = g.samples[W], P.pts = (P.pts - q) / U, P.dts = (P.dts - G) / U;
                this.observer.trigger(y.a.FRAG_PARSING_METADATA, {
                  samples: g.samples
                });
              }
              g.samples = [];
            }, A.prototype.remuxText = function(g, T) {
              g.samples.sort(function(W, ie) {
                return W.pts - ie.pts;
              });
              var D = g.samples.length, P, U = g.inputTimeScale, q = this._initPTS;
              if (D) {
                for (var G = 0; G < D; G++)
                  P = g.samples[G], P.pts = (P.pts - q) / U;
                this.observer.trigger(y.a.FRAG_PARSING_USERDATA, {
                  samples: g.samples
                });
              }
              g.samples = [];
            }, A.prototype._PTSNormalize = function(g, T) {
              var D;
              if (T === void 0)
                return g;
              for (T < g ? D = -8589934592 : D = 8589934592; Math.abs(g - T) > 4294967296; )
                g += D;
              return g;
            }, A;
          }(), Ot = Xr;
          function _r(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ii = function() {
            function A(j) {
              _r(this, A), this.observer = j;
            }
            return A.prototype.destroy = function() {
            }, A.prototype.resetTimeStamp = function() {
            }, A.prototype.resetInitSegment = function() {
            }, A.prototype.remux = function(g, T, D, P, U, q, G, W) {
              var ie = this.observer, Y = "";
              g && (Y += "audio"), T && (Y += "video"), ie.trigger(y.a.FRAG_PARSING_DATA, {
                data1: W,
                startPTS: U,
                startDTS: U,
                type: Y,
                nb: 1,
                dropped: 0
              }), ie.trigger(y.a.FRAG_PARSED);
            }, A;
          }(), li = Ii;
          function zr(A, j) {
            if (!(A instanceof j))
              throw new TypeError("Cannot call a class as a function");
          }
          var Nr = function() {
            function A(j, g, T, D) {
              zr(this, A), this.observer = j, this.typeSupported = g, this.config = T, this.vendor = D;
            }
            return A.prototype.destroy = function() {
              var g = this.demuxer;
              g && g.destroy();
            }, A.prototype.push = function(g, T, D, P, U, q, G, W, ie, Y, ue, ae) {
              if (g.byteLength > 0 && T != null && T.key != null && T.method === "AES-128") {
                var me = this.decrypter;
                me == null && (me = this.decrypter = new h.a(this.observer, this.config));
                var fe = this, Q;
                try {
                  Q = performance.now();
                } catch {
                  Q = Date.now();
                }
                me.decrypt(g, T.key.buffer, T.iv.buffer, function(oe) {
                  var Ke;
                  try {
                    Ke = performance.now();
                  } catch {
                    Ke = Date.now();
                  }
                  fe.observer.trigger(y.a.FRAG_DECRYPTED, { stats: { tstart: Q, tdecrypt: Ke } }), fe.pushDecrypted(new Uint8Array(oe), T, new Uint8Array(D), P, U, q, G, W, ie, Y, ue, ae);
                });
              } else
                this.pushDecrypted(new Uint8Array(g), T, new Uint8Array(D), P, U, q, G, W, ie, Y, ue, ae);
            }, A.prototype.pushDecrypted = function(g, T, D, P, U, q, G, W, ie, Y, ue, ae) {
              var me = this.demuxer;
              if (!me || // in case of continuity change, we might switch from content type (AAC container to TS container for example)
              // so let's check that current demuxer is still valid
              G && !this.probe(g)) {
                for (var fe = this.observer, Q = this.typeSupported, oe = this.config, Ke = [{ demux: Fe, remux: Ot }, { demux: Ue, remux: li }, { demux: xe, remux: Ot }, { demux: yr, remux: Ot }], nt = 0, ot = Ke.length; nt < ot; nt++) {
                  var qe = Ke[nt], Je = qe.demux.probe;
                  if (Je(g)) {
                    var Le = this.remuxer = new qe.remux(fe, oe, Q, this.vendor);
                    me = new qe.demux(fe, Le, oe, Q), this.probe = Je;
                    break;
                  }
                }
                if (!me) {
                  fe.trigger(y.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.FRAG_PARSING_ERROR, fatal: !0, reason: "no demux matching with content found" });
                  return;
                }
                this.demuxer = me;
              }
              var ct = this.remuxer;
              (G || W) && (me.resetInitSegment(D, P, U, Y), ct.resetInitSegment()), G && (me.resetTimeStamp(ae), ct.resetTimeStamp(ae)), typeof me.setDecryptData == "function" && me.setDecryptData(T), me.append(g, q, ie, ue);
            }, A;
          }();
          n.a = Nr;
        },
        /* 8 */
        /***/
        function(r, n, u) {
          Object.defineProperty(n, "__esModule", { value: !0 });
          var y = {};
          u.d(y, "newCue", function() {
            return sm;
          });
          var b = u(6), h = /* @__PURE__ */ u.n(b), d = u(1), m = u(2), p = u(0), _ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(x) {
            return typeof x;
          } : function(x) {
            return x && typeof Symbol == "function" && x.constructor === Symbol && x !== Symbol.prototype ? "symbol" : typeof x;
          };
          function B(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var N = function() {
            function x(s) {
              B(this, x), this.hls = s, this.onEvent = this.onEvent.bind(this);
              for (var o = arguments.length, a = Array(o > 1 ? o - 1 : 0), l = 1; l < o; l++)
                a[l - 1] = arguments[l];
              this.handledEvents = a, this.useGenericHandler = !0, this.registerListeners();
            }
            return x.prototype.destroy = function() {
              this.unregisterListeners();
            }, x.prototype.isEventHandler = function() {
              return _(this.handledEvents) === "object" && this.handledEvents.length && typeof this.onEvent == "function";
            }, x.prototype.registerListeners = function() {
              this.isEventHandler() && this.handledEvents.forEach(function(o) {
                if (o === "hlsEventGeneric")
                  throw new Error("Forbidden event name: " + o);
                this.hls.on(o, this.onEvent);
              }, this);
            }, x.prototype.unregisterListeners = function() {
              this.isEventHandler() && this.handledEvents.forEach(function(o) {
                this.hls.off(o, this.onEvent);
              }, this);
            }, x.prototype.onEvent = function(o, a) {
              this.onEventGeneric(o, a);
            }, x.prototype.onEventGeneric = function(o, a) {
              var l = function(v, C) {
                var w = "on" + v.replace("hls", "");
                if (typeof this[w] != "function")
                  throw new Error("Event " + v + " has no generic handler in this " + this.constructor.name + " class (tried " + w + ")");
                return this[w].bind(this, C);
              };
              try {
                l.call(this, o, a).call();
              } catch (f) {
                p.b.error("internal error happened while processing " + o + ":" + f.message), this.hls.trigger(d.a.ERROR, { type: m.b.OTHER_ERROR, details: m.a.INTERNAL_EXCEPTION, fatal: !1, event: o, err: f });
              }
            }, x;
          }(), X = N;
          function te(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var re = /^(\d+)x(\d+)$/, J = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g, F = function() {
            function x(s) {
              te(this, x), typeof s == "string" && (s = x.parseAttrList(s));
              for (var o in s)
                s.hasOwnProperty(o) && (this[o] = s[o]);
            }
            return x.prototype.decimalInteger = function(o) {
              var a = parseInt(this[o], 10);
              return a > Number.MAX_SAFE_INTEGER ? 1 / 0 : a;
            }, x.prototype.hexadecimalInteger = function(o) {
              if (this[o]) {
                var a = (this[o] || "0x").slice(2);
                a = (a.length & 1 ? "0" : "") + a;
                for (var l = new Uint8Array(a.length / 2), f = 0; f < a.length / 2; f++)
                  l[f] = parseInt(a.slice(f * 2, f * 2 + 2), 16);
                return l;
              } else
                return null;
            }, x.prototype.hexadecimalIntegerAsNumber = function(o) {
              var a = parseInt(this[o], 16);
              return a > Number.MAX_SAFE_INTEGER ? 1 / 0 : a;
            }, x.prototype.decimalFloatingPoint = function(o) {
              return parseFloat(this[o]);
            }, x.prototype.enumeratedString = function(o) {
              return this[o];
            }, x.prototype.decimalResolution = function(o) {
              var a = re.exec(this[o]);
              if (a !== null)
                return {
                  width: parseInt(a[1], 10),
                  height: parseInt(a[2], 10)
                };
            }, x.parseAttrList = function(o) {
              var a, l = {};
              for (J.lastIndex = 0; (a = J.exec(o)) !== null; ) {
                var f = a[2], v = '"';
                f.indexOf(v) === 0 && f.lastIndexOf(v) === f.length - 1 && (f = f.slice(1, -1)), l[a[1]] = f;
              }
              return l;
            }, x;
          }(), z = F, ee = {
            audio: {
              a3ds: !0,
              "ac-3": !0,
              "ac-4": !0,
              alac: !0,
              alaw: !0,
              dra1: !0,
              "dts+": !0,
              "dts-": !0,
              dtsc: !0,
              dtse: !0,
              dtsh: !0,
              "ec-3": !0,
              enca: !0,
              g719: !0,
              g726: !0,
              m4ae: !0,
              mha1: !0,
              mha2: !0,
              mhm1: !0,
              mhm2: !0,
              mlpa: !0,
              mp4a: !0,
              "raw ": !0,
              Opus: !0,
              samr: !0,
              sawb: !0,
              sawp: !0,
              sevc: !0,
              sqcp: !0,
              ssmv: !0,
              twos: !0,
              ulaw: !0
            },
            video: {
              avc1: !0,
              avc2: !0,
              avc3: !0,
              avc4: !0,
              avcp: !0,
              drac: !0,
              dvav: !0,
              dvhe: !0,
              encv: !0,
              hev1: !0,
              hvc1: !0,
              mjp2: !0,
              mp4v: !0,
              mvc1: !0,
              mvc2: !0,
              mvc3: !0,
              mvc4: !0,
              resv: !0,
              rv60: !0,
              s263: !0,
              svc1: !0,
              svc2: !0,
              "vc-1": !0,
              vp08: !0,
              vp09: !0
            }
          };
          function ye(x, s) {
            var o = ee[s];
            return !!o && o[x.slice(0, 4)] === !0;
          }
          function xe(x, s) {
            return MediaSource.isTypeSupported((s || "video") + '/mp4;codecs="' + x + '"');
          }
          var Ee = /* @__PURE__ */ function() {
            function x(s, o) {
              for (var a = 0; a < o.length; a++) {
                var l = o[a];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, a) {
              return o && x(s.prototype, o), a && x(s, a), s;
            };
          }();
          function Ae(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function De(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          function Ue(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ve = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g, tt = /#EXT-X-MEDIA:(.*)/g, dt = new RegExp([
            /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
            // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
            /|(?!#)(\S+)/.source,
            // segment URI, group 3 => the URI (note newline is not eaten)
            /|#EXT-X-BYTERANGE:*(.+)/.source,
            // next segment's byterange, group 4 => range spec (x@y)
            /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
            // next segment's program date/time group 5 => the datetime spec
            /|#.*/.source
            // All other non-segment oriented tags will match with all groups empty
          ].join(""), "g"), ft = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/, $t = function() {
            function x() {
              Ue(this, x), this.method = null, this.key = null, this.iv = null, this._uri = null;
            }
            return Ee(x, [{
              key: "uri",
              get: function() {
                return !this._uri && this.reluri && (this._uri = h.a.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: !0 })), this._uri;
              }
            }]), x;
          }(), ze = function() {
            function x() {
              Ue(this, x), this._url = null, this._byteRange = null, this._decryptdata = null, this.tagList = [];
            }
            return x.prototype.createInitializationVector = function(o) {
              for (var a = new Uint8Array(16), l = 12; l < 16; l++)
                a[l] = o >> 8 * (15 - l) & 255;
              return a;
            }, x.prototype.fragmentDecryptdataFromLevelkey = function(o, a) {
              var l = o;
              return o && o.method && o.uri && !o.iv && (l = new $t(), l.method = o.method, l.baseuri = o.baseuri, l.reluri = o.reluri, l.iv = this.createInitializationVector(a)), l;
            }, x.prototype.cloneObj = function(o) {
              return JSON.parse(JSON.stringify(o));
            }, Ee(x, [{
              key: "url",
              get: function() {
                return !this._url && this.relurl && (this._url = h.a.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url;
              },
              set: function(o) {
                this._url = o;
              }
            }, {
              key: "programDateTime",
              get: function() {
                return !this._programDateTime && this.rawProgramDateTime && (this._programDateTime = new Date(Date.parse(this.rawProgramDateTime))), this._programDateTime;
              }
            }, {
              key: "byteRange",
              get: function() {
                if (!this._byteRange) {
                  var o = this._byteRange = [];
                  if (this.rawByteRange) {
                    var a = this.rawByteRange.split("@", 2);
                    if (a.length === 1) {
                      var l = this.lastByteRangeEndOffset;
                      o[0] = l || 0;
                    } else
                      o[0] = parseInt(a[1]);
                    o[1] = parseInt(a[0]) + o[0];
                  }
                }
                return this._byteRange;
              }
            }, {
              key: "byteRangeStartOffset",
              get: function() {
                return this.byteRange[0];
              }
            }, {
              key: "byteRangeEndOffset",
              get: function() {
                return this.byteRange[1];
              }
            }, {
              key: "decryptdata",
              get: function() {
                return this._decryptdata || (this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn)), this._decryptdata;
              }
            }]), x;
          }();
          function Tt(x, s) {
            if (!x)
              return null;
            for (var o = null, a = 0; a < x.length; a++) {
              var l = x[a];
              l.id === s && (o = l);
            }
            return o;
          }
          var pt = function(x) {
            De(s, x);
            function s(o) {
              Ue(this, s);
              var a = Ae(this, x.call(this, o, d.a.MANIFEST_LOADING, d.a.LEVEL_LOADING, d.a.AUDIO_TRACK_LOADING, d.a.SUBTITLE_TRACK_LOADING));
              return a.loaders = {}, a;
            }
            return s.prototype.destroy = function() {
              for (var a in this.loaders) {
                var l = this.loaders[a];
                l && l.destroy();
              }
              this.loaders = {}, X.prototype.destroy.call(this);
            }, s.prototype.onManifestLoading = function(a) {
              this.load(a.url, { type: "manifest" });
            }, s.prototype.onLevelLoading = function(a) {
              this.load(a.url, { type: "level", level: a.level, id: a.id });
            }, s.prototype.onAudioTrackLoading = function(a) {
              this.load(a.url, { type: "audioTrack", id: a.id });
            }, s.prototype.onSubtitleTrackLoading = function(a) {
              this.load(a.url, { type: "subtitleTrack", id: a.id });
            }, s.prototype.load = function(a, l) {
              var f = this.loaders[l.type];
              if (f !== void 0) {
                var v = f.context;
                if (v && v.url === a) {
                  p.b.trace("playlist request ongoing");
                  return;
                } else
                  p.b.warn("abort previous loader for type:" + l.type), f.abort();
              }
              var C = this.hls.config, w = void 0, k = void 0, I = void 0, M = void 0;
              l.type === "manifest" ? (w = C.manifestLoadingMaxRetry, k = C.manifestLoadingTimeOut, I = C.manifestLoadingRetryDelay, M = C.manifestLoadingMaxRetryTimeout) : l.type === "level" ? (w = 0, k = C.levelLoadingTimeOut) : (w = C.levelLoadingMaxRetry, k = C.levelLoadingTimeOut, I = C.levelLoadingRetryDelay, M = C.levelLoadingMaxRetryTimeout, p.b.log("loading playlist for " + l.type + " " + (l.level || l.id))), f = this.loaders[l.type] = l.loader = typeof C.pLoader < "u" ? new C.pLoader(C) : new C.loader(C), l.url = a, l.responseType = "";
              var $ = void 0, H = void 0;
              $ = { timeout: k, maxRetry: w, retryDelay: I, maxRetryDelay: M }, H = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }, f.load(l, $, H);
            }, s.prototype.resolve = function(a, l) {
              return h.a.buildAbsoluteURL(l, a, { alwaysNormalize: !0 });
            }, s.prototype.parseMasterPlaylist = function(a, l) {
              var f = [], v = void 0;
              Ve.lastIndex = 0;
              function C(M, $) {
                ["video", "audio"].forEach(function(H) {
                  var le = M.filter(function(Re) {
                    return ye(Re, H);
                  });
                  if (le.length) {
                    var ge = le.filter(function(Re) {
                      return Re.lastIndexOf("avc1", 0) === 0 || Re.lastIndexOf("mp4a", 0) === 0;
                    });
                    $[H + "Codec"] = ge.length > 0 ? ge[0] : le[0], M = M.filter(function(Re) {
                      return le.indexOf(Re) === -1;
                    });
                  }
                }), $.unknownCodecs = M;
              }
              for (; (v = Ve.exec(a)) != null; ) {
                var w = {}, k = w.attrs = new z(v[1]);
                w.url = this.resolve(v[2], l);
                var I = k.decimalResolution("RESOLUTION");
                I && (w.width = I.width, w.height = I.height), w.bitrate = k.decimalInteger("AVERAGE-BANDWIDTH") || k.decimalInteger("BANDWIDTH"), w.name = k.NAME, C([].concat((k.CODECS || "").split(/[ ,]+/)), w), w.videoCodec && w.videoCodec.indexOf("avc1") !== -1 && (w.videoCodec = this.avc1toavcoti(w.videoCodec)), f.push(w);
              }
              return f;
            }, s.prototype.parseMasterPlaylistMedia = function(a, l, f) {
              var v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [], C = void 0, w = [], k = 0;
              for (tt.lastIndex = 0; (C = tt.exec(a)) !== null; ) {
                var I = {}, M = new z(C[1]);
                if (M.TYPE === f) {
                  if (I.groupId = M["GROUP-ID"], I.name = M.NAME, I.type = f, I.default = M.DEFAULT === "YES", I.autoselect = M.AUTOSELECT === "YES", I.forced = M.FORCED === "YES", M.URI && (I.url = this.resolve(M.URI, l)), I.lang = M.LANGUAGE, I.name || (I.name = I.lang), v.length) {
                    var $ = Tt(v, I.groupId);
                    I.audioCodec = $ ? $.codec : v[0].codec;
                  }
                  I.id = k++, w.push(I);
                }
              }
              return w;
            }, s.prototype.avc1toavcoti = function(a) {
              var l, f = a.split(".");
              return f.length > 2 ? (l = f.shift() + ".", l += parseInt(f.shift()).toString(16), l += ("000" + parseInt(f.shift()).toString(16)).substr(-4)) : l = a, l;
            }, s.prototype.parseLevelPlaylist = function(a, l, f, v) {
              var C = 0, w = 0, k = { type: null, version: null, url: l, fragments: [], live: !0, startSN: 0 }, I = new $t(), M = 0, $ = null, H = new ze(), le, ge;
              for (dt.lastIndex = 0; (le = dt.exec(a)) !== null; ) {
                var Re = le[1];
                if (Re) {
                  H.duration = parseFloat(Re);
                  var ve = (" " + le[2]).slice(1);
                  H.title = ve || null, H.tagList.push(ve ? ["INF", Re, ve] : ["INF", Re]);
                } else if (le[3]) {
                  if (!isNaN(H.duration)) {
                    var Pe = C++;
                    H.type = v, H.start = w, H.levelkey = I, H.sn = Pe, H.level = f, H.cc = M, H.baseurl = l, H.relurl = (" " + le[3]).slice(1), k.fragments.push(H), $ = H, w += H.duration, H = new ze();
                  }
                } else if (le[4]) {
                  if (H.rawByteRange = (" " + le[4]).slice(1), $) {
                    var Be = $.byteRangeEndOffset;
                    Be && (H.lastByteRangeEndOffset = Be);
                  }
                } else if (le[5])
                  H.rawProgramDateTime = (" " + le[5]).slice(1), H.tagList.push(["PROGRAM-DATE-TIME", H.rawProgramDateTime]), k.programDateTime === void 0 && (k.programDateTime = new Date(new Date(Date.parse(le[5])) - 1e3 * w));
                else {
                  for (le = le[0].match(ft), ge = 1; ge < le.length && le[ge] === void 0; ge++)
                    ;
                  var Ne = (" " + le[ge + 1]).slice(1), et = (" " + le[ge + 2]).slice(1);
                  switch (le[ge]) {
                    case "#":
                      H.tagList.push(et ? [Ne, et] : [Ne]);
                      break;
                    case "PLAYLIST-TYPE":
                      k.type = Ne.toUpperCase();
                      break;
                    case "MEDIA-SEQUENCE":
                      C = k.startSN = parseInt(Ne);
                      break;
                    case "TARGETDURATION":
                      k.targetduration = parseFloat(Ne);
                      break;
                    case "VERSION":
                      k.version = parseInt(Ne);
                      break;
                    case "EXTM3U":
                      break;
                    case "ENDLIST":
                      k.live = !1;
                      break;
                    case "DIS":
                      M++, H.tagList.push(["DIS"]);
                      break;
                    case "DISCONTINUITY-SEQ":
                      M = parseInt(Ne);
                      break;
                    case "KEY":
                      var _t = Ne, Ce = new z(_t), zt = Ce.enumeratedString("METHOD"), bt = Ce.URI, pn = Ce.hexadecimalInteger("IV");
                      zt && (I = new $t(), bt && ["AES-128", "SAMPLE-AES"].indexOf(zt) >= 0 && (I.method = zt, I.baseuri = l, I.reluri = bt, I.key = null, I.iv = pn));
                      break;
                    case "START":
                      var Qe = Ne, $e = new z(Qe), nr = $e.decimalFloatingPoint("TIME-OFFSET");
                      isNaN(nr) || (k.startTimeOffset = nr);
                      break;
                    case "MAP":
                      var vl = new z(Ne);
                      H.relurl = vl.URI, H.rawByteRange = vl.BYTERANGE, H.baseurl = l, H.level = f, H.type = v, H.sn = "initSegment", k.initSegment = H, H = new ze();
                      break;
                    default:
                      p.b.warn("line parsed but not handled: " + le);
                      break;
                  }
                }
              }
              return H = $, H && !H.relurl && (k.fragments.pop(), w -= H.duration), k.totalduration = w, k.averagetargetduration = w / k.fragments.length, k.endSN = C - 1, k.startCC = k.fragments[0] ? k.fragments[0].cc : 0, k.endCC = M, k;
            }, s.prototype.loadsuccess = function(a, l, f) {
              var v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, C = a.data, w = a.url, k = f.type, I = f.id, M = f.level, $ = this.hls;
              if (this.loaders[k] = void 0, (w === void 0 || w.indexOf("data:") === 0) && (w = f.url), l.tload = performance.now(), C.indexOf("#EXTM3U") === 0)
                if (C.indexOf("#EXTINF:") > 0) {
                  var H = k !== "audioTrack" && k !== "subtitleTrack", le = isNaN(M) ? isNaN(I) ? 0 : I : M, ge = this.parseLevelPlaylist(C, w, le, k === "audioTrack" ? "audio" : k === "subtitleTrack" ? "subtitle" : "main");
                  ge.tload = l.tload, k === "manifest" && $.trigger(d.a.MANIFEST_LOADED, { levels: [{ url: w, details: ge }], audioTracks: [], url: w, stats: l, networkDetails: v }), l.tparsed = performance.now(), ge.targetduration ? H ? $.trigger(d.a.LEVEL_LOADED, { details: ge, level: M || 0, id: I || 0, stats: l, networkDetails: v }) : k === "audioTrack" ? $.trigger(d.a.AUDIO_TRACK_LOADED, { details: ge, id: I, stats: l, networkDetails: v }) : k === "subtitleTrack" && $.trigger(d.a.SUBTITLE_TRACK_LOADED, { details: ge, id: I, stats: l, networkDetails: v }) : $.trigger(d.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.MANIFEST_PARSING_ERROR, fatal: !0, url: w, reason: "invalid targetduration", networkDetails: v });
                } else {
                  var Re = this.parseMasterPlaylist(C, w);
                  if (Re.length) {
                    var ve = Re.map(function(et) {
                      return { id: et.attrs.AUDIO, codec: et.audioCodec };
                    }), Pe = this.parseMasterPlaylistMedia(C, w, "AUDIO", ve), Be = this.parseMasterPlaylistMedia(C, w, "SUBTITLES");
                    if (Pe.length) {
                      var Ne = !1;
                      Pe.forEach(function(et) {
                        et.url || (Ne = !0);
                      }), Ne === !1 && Re[0].audioCodec && !Re[0].attrs.AUDIO && (p.b.log("audio codec signaled in quality level, but no embedded audio track signaled, create one"), Pe.unshift({ type: "main", name: "main" }));
                    }
                    $.trigger(d.a.MANIFEST_LOADED, { levels: Re, audioTracks: Pe, subtitles: Be, url: w, stats: l, networkDetails: v });
                  } else
                    $.trigger(d.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.MANIFEST_PARSING_ERROR, fatal: !0, url: w, reason: "no level found in manifest", networkDetails: v });
                }
              else
                $.trigger(d.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.MANIFEST_PARSING_ERROR, fatal: !0, url: w, reason: "no EXTM3U delimiter", networkDetails: v });
            }, s.prototype.loaderror = function(a, l) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, v, C, w = l.loader;
              switch (l.type) {
                case "manifest":
                  v = m.a.MANIFEST_LOAD_ERROR, C = !0;
                  break;
                case "level":
                  v = m.a.LEVEL_LOAD_ERROR, C = !1;
                  break;
                case "audioTrack":
                  v = m.a.AUDIO_TRACK_LOAD_ERROR, C = !1;
                  break;
              }
              w && (w.abort(), this.loaders[l.type] = void 0), this.hls.trigger(d.a.ERROR, { type: m.b.NETWORK_ERROR, details: v, fatal: C, url: w.url, loader: w, response: a, context: l, networkDetails: f });
            }, s.prototype.loadtimeout = function(a, l) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, v, C, w = l.loader;
              switch (l.type) {
                case "manifest":
                  v = m.a.MANIFEST_LOAD_TIMEOUT, C = !0;
                  break;
                case "level":
                  v = m.a.LEVEL_LOAD_TIMEOUT, C = !1;
                  break;
                case "audioTrack":
                  v = m.a.AUDIO_TRACK_LOAD_TIMEOUT, C = !1;
                  break;
              }
              w && (w.abort(), this.loaders[l.type] = void 0), this.hls.trigger(d.a.ERROR, { type: m.b.NETWORK_ERROR, details: v, fatal: C, url: w.url, loader: w, context: l, networkDetails: f });
            }, s;
          }(X), st = pt;
          function rt(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function ht(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function Fe(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var tr = function(x) {
            Fe(s, x);
            function s(o) {
              rt(this, s);
              var a = ht(this, x.call(this, o, d.a.FRAG_LOADING));
              return a.loaders = {}, a;
            }
            return s.prototype.destroy = function() {
              var a = this.loaders;
              for (var l in a) {
                var f = a[l];
                f && f.destroy();
              }
              this.loaders = {}, X.prototype.destroy.call(this);
            }, s.prototype.onFragLoading = function(a) {
              var l = a.frag, f = l.type, v = this.loaders[f], C = this.hls.config;
              l.loaded = 0, v && (p.b.warn("abort previous fragment loader for type:" + f), v.abort()), v = this.loaders[f] = l.loader = typeof C.fLoader < "u" ? new C.fLoader(C) : new C.loader(C);
              var w = void 0, k = void 0, I = void 0;
              w = { url: l.url, frag: l, responseType: "arraybuffer", progressData: !1 };
              var M = l.byteRangeStartOffset, $ = l.byteRangeEndOffset;
              !isNaN(M) && !isNaN($) && (w.rangeStart = M, w.rangeEnd = $), k = { timeout: C.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: C.fragLoadingMaxRetryTimeout }, I = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) }, v.load(w, k, I);
            }, s.prototype.loadsuccess = function(a, l, f) {
              var v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, C = a.data, w = f.frag;
              w.loader = void 0, this.loaders[w.type] = void 0, this.hls.trigger(d.a.FRAG_LOADED, { payload: C, frag: w, stats: l, networkDetails: v });
            }, s.prototype.loaderror = function(a, l) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, v = l.loader;
              v && v.abort(), this.loaders[l.type] = void 0, this.hls.trigger(d.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.FRAG_LOAD_ERROR, fatal: !1, frag: l.frag, response: a, networkDetails: f });
            }, s.prototype.loadtimeout = function(a, l) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, v = l.loader;
              v && v.abort(), this.loaders[l.type] = void 0, this.hls.trigger(d.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.FRAG_LOAD_TIMEOUT, fatal: !1, frag: l.frag, networkDetails: f });
            }, s.prototype.loadprogress = function(a, l, f) {
              var v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, C = l.frag;
              C.loaded = a.loaded, this.hls.trigger(d.a.FRAG_LOAD_PROGRESS, { frag: C, stats: a, networkDetails: v });
            }, s;
          }(X), it = tr;
          function yr(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function St(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function xt(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var Ct = function(x) {
            xt(s, x);
            function s(o) {
              yr(this, s);
              var a = St(this, x.call(this, o, d.a.KEY_LOADING));
              return a.loaders = {}, a.decryptkey = null, a.decrypturl = null, a;
            }
            return s.prototype.destroy = function() {
              for (var a in this.loaders) {
                var l = this.loaders[a];
                l && l.destroy();
              }
              this.loaders = {}, X.prototype.destroy.call(this);
            }, s.prototype.onKeyLoading = function(a) {
              var l = a.frag, f = l.type, v = this.loaders[f], C = l.decryptdata, w = C.uri;
              if (w !== this.decrypturl || this.decryptkey === null) {
                var k = this.hls.config;
                v && (p.b.warn("abort previous key loader for type:" + f), v.abort()), l.loader = this.loaders[f] = new k.loader(k), this.decrypturl = w, this.decryptkey = null;
                var I = void 0, M = void 0, $ = void 0;
                I = { url: w, frag: l, responseType: "arraybuffer" }, M = { timeout: k.fragLoadingTimeOut, maxRetry: k.fragLoadingMaxRetry, retryDelay: k.fragLoadingRetryDelay, maxRetryDelay: k.fragLoadingMaxRetryTimeout }, $ = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }, l.loader.load(I, M, $);
              } else this.decryptkey && (C.key = this.decryptkey, this.hls.trigger(d.a.KEY_LOADED, { frag: l }));
            }, s.prototype.loadsuccess = function(a, l, f) {
              var v = f.frag;
              this.decryptkey = v.decryptdata.key = new Uint8Array(a.data), v.loader = void 0, this.loaders[v.type] = void 0, this.hls.trigger(d.a.KEY_LOADED, { frag: v });
            }, s.prototype.loaderror = function(a, l) {
              var f = l.frag, v = f.loader;
              v && v.abort(), this.loaders[l.type] = void 0, this.hls.trigger(d.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.KEY_LOAD_ERROR, fatal: !1, frag: f, response: a });
            }, s.prototype.loadtimeout = function(a, l) {
              var f = l.frag, v = f.loader;
              v && v.abort(), this.loaders[l.type] = void 0, this.hls.trigger(d.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.KEY_LOAD_TIMEOUT, fatal: !1, frag: f });
            }, s;
          }(X), mt = Ct, Ut = {
            /**
             * Searches for an item in an array which matches a certain condition.
             * This requires the condition to only match one item in the array,
             * and for the array to be ordered.
             *
             * @param {Array} list The array to search.
             * @param {Function} comparisonFunction
             *      Called and provided a candidate item as the first argument.
             *      Should return:
             *          > -1 if the item should be located at a lower index than the provided item.
             *          > 1 if the item should be located at a higher index than the provided item.
             *          > 0 if the item is the item you're looking for.
             *
             * @return {*} The object if it is found or null otherwise.
             */
            search: function(s, o) {
              for (var a = 0, l = s.length - 1, f = null, v = null; a <= l; ) {
                f = (a + l) / 2 | 0, v = s[f];
                var C = o(v);
                if (C > 0)
                  a = f + 1;
                else if (C < 0)
                  l = f - 1;
                else
                  return v;
              }
              return null;
            }
          }, Ze = Ut, Gt = {
            isBuffered: function(s, o) {
              try {
                if (s) {
                  for (var a = s.buffered, l = 0; l < a.length; l++)
                    if (o >= a.start(l) && o <= a.end(l))
                      return !0;
                }
              } catch {
              }
              return !1;
            },
            bufferInfo: function(s, o, a) {
              try {
                if (s) {
                  var l = s.buffered, f = [], v;
                  for (v = 0; v < l.length; v++)
                    f.push({ start: l.start(v), end: l.end(v) });
                  return this.bufferedInfo(f, o, a);
                }
              } catch {
              }
              return { len: 0, start: o, end: o, nextStart: void 0 };
            },
            bufferedInfo: function(s, o, a) {
              var l = [], f, v, C, w, k;
              for (s.sort(function(le, ge) {
                var Re = le.start - ge.start;
                return Re || ge.end - le.end;
              }), k = 0; k < s.length; k++) {
                var I = l.length;
                if (I) {
                  var M = l[I - 1].end;
                  s[k].start - M < a ? s[k].end > M && (l[I - 1].end = s[k].end) : l.push(s[k]);
                } else
                  l.push(s[k]);
              }
              for (k = 0, f = 0, v = C = o; k < l.length; k++) {
                var $ = l[k].start, H = l[k].end;
                if (o + a >= $ && o < H)
                  v = $, C = H, f = C - o;
                else if (o + a < $) {
                  w = $;
                  break;
                }
              }
              return { len: f, start: v, end: C, nextStart: w };
            }
          }, Ye = Gt, Et = u(7), Xr = u(5), Ot = /* @__PURE__ */ u.n(Xr), _r = u(9), Ii = /* @__PURE__ */ u.n(_r);
          function li() {
            if (typeof window < "u")
              return window.MediaSource || window.WebKitMediaSource;
          }
          function zr(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var Nr = li(), A = function() {
            function x(s, o) {
              zr(this, x), this.hls = s, this.id = o;
              var a = this.observer = new Ot.a(), l = s.config;
              a.trigger = function(I) {
                for (var M = arguments.length, $ = Array(M > 1 ? M - 1 : 0), H = 1; H < M; H++)
                  $[H - 1] = arguments[H];
                a.emit.apply(a, [I, I].concat($));
              }, a.off = function(I) {
                for (var M = arguments.length, $ = Array(M > 1 ? M - 1 : 0), H = 1; H < M; H++)
                  $[H - 1] = arguments[H];
                a.removeListener.apply(a, [I].concat($));
              };
              var f = function(k, I) {
                I = I || {}, I.frag = this.frag, I.id = this.id, s.trigger(k, I);
              }.bind(this);
              a.on(d.a.FRAG_DECRYPTED, f), a.on(d.a.FRAG_PARSING_INIT_SEGMENT, f), a.on(d.a.FRAG_PARSING_DATA, f), a.on(d.a.FRAG_PARSED, f), a.on(d.a.ERROR, f), a.on(d.a.FRAG_PARSING_METADATA, f), a.on(d.a.FRAG_PARSING_USERDATA, f), a.on(d.a.INIT_PTS_FOUND, f);
              var v = {
                mp4: Nr.isTypeSupported("video/mp4"),
                mpeg: Nr.isTypeSupported("audio/mpeg"),
                mp3: Nr.isTypeSupported('audio/mp4; codecs="mp3"')
              }, C = navigator.vendor;
              if (l.enableWorker && typeof Worker < "u") {
                p.b.log("demuxing in webworker");
                var w = void 0;
                try {
                  w = this.w = Ii()(
                    /*require.resolve*/
                    10
                  ), this.onwmsg = this.onWorkerMessage.bind(this), w.addEventListener("message", this.onwmsg), w.onerror = function(k) {
                    s.trigger(d.a.ERROR, { type: m.b.OTHER_ERROR, details: m.a.INTERNAL_EXCEPTION, fatal: !0, event: "demuxerWorker", err: { message: k.message + " (" + k.filename + ":" + k.lineno + ")" } });
                  }, w.postMessage({ cmd: "init", typeSupported: v, vendor: C, id: o, config: JSON.stringify(l) });
                } catch {
                  p.b.error("error while initializing DemuxerWorker, fallback on DemuxerInline"), w && URL.revokeObjectURL(w.objectURL), this.demuxer = new Et.a(a, v, l, C), this.w = void 0;
                }
              } else
                this.demuxer = new Et.a(a, v, l, C);
            }
            return x.prototype.destroy = function() {
              var o = this.w;
              if (o)
                o.removeEventListener("message", this.onwmsg), o.terminate(), this.w = null;
              else {
                var a = this.demuxer;
                a && (a.destroy(), this.demuxer = null);
              }
              var l = this.observer;
              l && (l.removeAllListeners(), this.observer = null);
            }, x.prototype.push = function(o, a, l, f, v, C, w, k) {
              var I = this.w, M = isNaN(v.startDTS) ? v.start : v.startDTS, $ = v.decryptdata, H = this.frag, le = !(H && v.cc === H.cc), ge = !(H && v.level === H.level), Re = H && v.sn === H.sn + 1, ve = !ge && Re;
              if (le && p.b.log(this.id + ":discontinuity detected"), ge && p.b.log(this.id + ":switch detected"), this.frag = v, I)
                I.postMessage({ cmd: "demux", data: o, decryptdata: $, initSegment: a, audioCodec: l, videoCodec: f, timeOffset: M, discontinuity: le, trackSwitch: ge, contiguous: ve, duration: C, accurateTimeOffset: w, defaultInitPTS: k }, o instanceof ArrayBuffer ? [o] : []);
              else {
                var Pe = this.demuxer;
                Pe && Pe.push(o, $, a, l, f, M, le, ge, ve, C, w, k);
              }
            }, x.prototype.onWorkerMessage = function(o) {
              var a = o.data, l = this.hls;
              switch (a.event) {
                case "init":
                  URL.revokeObjectURL(this.w.objectURL);
                  break;
                case d.a.FRAG_PARSING_DATA:
                  a.data.data1 = new Uint8Array(a.data1), a.data2 && (a.data.data2 = new Uint8Array(a.data2));
                default:
                  a.data = a.data || {}, a.data.frag = this.frag, a.data.id = this.id, l.trigger(a.event, a.data);
                  break;
              }
            }, x;
          }(), j = A;
          function g(x, s, o) {
            var a = x[s], l = x[o], f = l.startPTS;
            isNaN(f) ? o > s ? l.start = a.start + a.duration : l.start = Math.max(a.start - l.duration, 0) : o > s ? (a.duration = f - a.start, a.duration < 0 && p.b.warn("negative duration computed for frag " + a.sn + ",level " + a.level + ", there should be some duration drift between playlist and fragment!")) : (l.duration = a.start - f, l.duration < 0 && p.b.warn("negative duration computed for frag " + l.sn + ",level " + l.level + ", there should be some duration drift between playlist and fragment!"));
          }
          function T(x, s, o, a, l, f) {
            var v = o;
            if (!isNaN(s.startPTS)) {
              var C = Math.abs(s.startPTS - o);
              isNaN(s.deltaPTS) ? s.deltaPTS = C : s.deltaPTS = Math.max(C, s.deltaPTS), v = Math.max(o, s.startPTS), o = Math.min(o, s.startPTS), a = Math.max(a, s.endPTS), l = Math.min(l, s.startDTS), f = Math.max(f, s.endDTS);
            }
            var w = o - s.start;
            s.start = s.startPTS = o, s.maxStartPTS = v, s.endPTS = a, s.startDTS = l, s.endDTS = f, s.duration = a - o;
            var k = s.sn;
            if (!x || k < x.startSN || k > x.endSN)
              return 0;
            var I, M, $;
            for (I = k - x.startSN, M = x.fragments, M[I] = s, $ = I; $ > 0; $--)
              g(M, $, $ - 1);
            for ($ = I; $ < M.length - 1; $++)
              g(M, $, $ + 1);
            return x.PTSKnown = !0, w;
          }
          function D(x, s) {
            var o = Math.max(x.startSN, s.startSN) - s.startSN, a = Math.min(x.endSN, s.endSN) - s.startSN, l = s.startSN - x.startSN, f = x.fragments, v = s.fragments, C = 0, w;
            if (a < o) {
              s.PTSKnown = !1;
              return;
            }
            for (var k = o; k <= a; k++) {
              var I = f[l + k], M = v[k];
              M && I && (C = I.cc - M.cc, isNaN(I.startPTS) || (M.start = M.startPTS = I.startPTS, M.endPTS = I.endPTS, M.duration = I.duration, M.backtracked = I.backtracked, M.dropped = I.dropped, w = M));
            }
            if (C)
              for (p.b.log("discontinuity sliding from playlist, take drift into account"), k = 0; k < v.length; k++)
                v[k].cc += C;
            if (w)
              T(s, w, w.startPTS, w.endPTS, w.startDTS, w.endDTS);
            else if (l >= 0 && l < f.length) {
              var $ = f[l].start;
              for (k = 0; k < v.length; k++)
                v[k].start += $;
            }
            s.PTSKnown = x.PTSKnown;
          }
          var P = {
            toString: function(s) {
              for (var o = "", a = s.length, l = 0; l < a; l++)
                o += "[" + s.start(l).toFixed(3) + "," + s.end(l).toFixed(3) + "]";
              return o;
            }
          }, U = P;
          function q(x, s) {
            for (var o = null, a = 0; a < x.length; a += 1) {
              var l = x[a];
              if (l && l.cc === s) {
                o = l;
                break;
              }
            }
            return o;
          }
          function G(x, s) {
            return Ze.search(x, function(o) {
              return o.cc < s ? 1 : o.cc > s ? -1 : 0;
            });
          }
          function W(x, s, o) {
            var a = !1;
            return s && s.details && o && (o.endCC > o.startCC || x && x.cc < o.startCC) && (a = !0), a;
          }
          function ie(x, s) {
            var o = x.fragments, a = s.fragments;
            if (!a.length || !o.length) {
              p.b.log("No fragments to align");
              return;
            }
            var l = q(o, a[0].cc);
            if (!l || l && !l.startPTS) {
              p.b.log("No frag in previous level to align on");
              return;
            }
            return l;
          }
          function Y(x, s) {
            s.fragments.forEach(function(o) {
              if (o) {
                var a = o.start + x;
                o.start = o.startPTS = a, o.endPTS = a + o.duration;
              }
            }), s.PTSKnown = !0;
          }
          function ue(x, s, o) {
            if (W(x, s, o)) {
              var a = ie(s.details, o);
              a && (p.b.log("Adjusting PTS using last level due to CC increase within current level"), Y(a.start, o));
            }
            if (o.PTSKnown === !1 && s && s.details) {
              var l = s.details.programDateTime, f = o.programDateTime, v = (f - l) / 1e3 + s.details.fragments[0].start;
              isNaN(v) || (p.b.log("adjusting PTS using programDateTime delta, sliding:" + v.toFixed(3)), Y(v, o));
            }
          }
          var ae = /* @__PURE__ */ function() {
            function x(s, o) {
              for (var a = 0; a < o.length; a++) {
                var l = o[a];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, a) {
              return o && x(s.prototype, o), a && x(s, a), s;
            };
          }();
          function me(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function fe(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function Q(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var oe = {
            STOPPED: "STOPPED",
            IDLE: "IDLE",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING",
            FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
            WAITING_LEVEL: "WAITING_LEVEL",
            PARSING: "PARSING",
            PARSED: "PARSED",
            BUFFER_FLUSHING: "BUFFER_FLUSHING",
            ENDED: "ENDED",
            ERROR: "ERROR"
          }, Ke = function(x) {
            Q(s, x);
            function s(o) {
              me(this, s);
              var a = fe(this, x.call(this, o, d.a.MEDIA_ATTACHED, d.a.MEDIA_DETACHING, d.a.MANIFEST_LOADING, d.a.MANIFEST_PARSED, d.a.LEVEL_LOADED, d.a.KEY_LOADED, d.a.FRAG_LOADED, d.a.FRAG_LOAD_EMERGENCY_ABORTED, d.a.FRAG_PARSING_INIT_SEGMENT, d.a.FRAG_PARSING_DATA, d.a.FRAG_PARSED, d.a.ERROR, d.a.AUDIO_TRACK_SWITCHING, d.a.AUDIO_TRACK_SWITCHED, d.a.BUFFER_CREATED, d.a.BUFFER_APPENDED, d.a.BUFFER_FLUSHED));
              return a.config = o.config, a.audioCodecSwap = !1, a.ticks = 0, a._state = oe.STOPPED, a.ontick = a.tick.bind(a), a;
            }
            return s.prototype.destroy = function() {
              this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), X.prototype.destroy.call(this), this.state = oe.STOPPED;
            }, s.prototype.startLoad = function(a) {
              if (this.levels) {
                var l = this.lastCurrentTime, f = this.hls;
                if (this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {
                  var v = f.startLevel;
                  v === -1 && (v = 0, this.bitrateTest = !0), this.level = f.nextLoadLevel = v, this.loadedmetadata = !1;
                }
                l > 0 && a === -1 && (p.b.log("override startPosition with lastCurrentTime @" + l.toFixed(3)), a = l), this.state = oe.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = a, this.tick();
              } else
                this.forceStartLoad = !0, this.state = oe.STOPPED;
            }, s.prototype.stopLoad = function() {
              var a = this.fragCurrent;
              a && (a.loader && a.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = oe.STOPPED, this.forceStartLoad = !1;
            }, s.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, s.prototype.doTick = function() {
              switch (this.state) {
                case oe.ERROR:
                  break;
                case oe.BUFFER_FLUSHING:
                  this.fragLoadError = 0;
                  break;
                case oe.IDLE:
                  this._doTickIdle();
                  break;
                case oe.WAITING_LEVEL:
                  var a = this.levels[this.level];
                  a && a.details && (this.state = oe.IDLE);
                  break;
                case oe.FRAG_LOADING_WAITING_RETRY:
                  var l = performance.now(), f = this.retryDate;
                  (!f || l >= f || this.media && this.media.seeking) && (p.b.log("mediaController: retryDate reached, switch back to IDLE state"), this.state = oe.IDLE);
                  break;
              }
              this._checkBuffer(), this._checkFragmentChanged();
            }, s.prototype._doTickIdle = function() {
              var a = this.hls, l = a.config, f = this.media;
              if (!(this.levelLastLoaded === void 0 || !f && (this.startFragRequested || !l.startFragPrefetch))) {
                var v = void 0;
                this.loadedmetadata ? v = f.currentTime : v = this.nextLoadPosition;
                var C = a.nextLoadLevel, w = this.levels[C];
                if (w) {
                  var k = w.bitrate, I = void 0;
                  k ? I = Math.max(8 * l.maxBufferSize / k, l.maxBufferLength) : I = l.maxBufferLength, I = Math.min(I, l.maxMaxBufferLength);
                  var M = Ye.bufferInfo(this.mediaBuffer ? this.mediaBuffer : f, v, l.maxBufferHole), $ = M.len;
                  if (!($ >= I)) {
                    p.b.trace("buffer length of " + $.toFixed(3) + " is below max of " + I.toFixed(3) + ". checking for more payload ..."), this.level = a.nextLoadLevel = C;
                    var H = w.details;
                    if (H === void 0 || H.live === !0 && this.levelLastLoaded !== C) {
                      this.state = oe.WAITING_LEVEL;
                      return;
                    }
                    var le = this.fragPrevious;
                    if (!H.live && le && !le.backtracked && le.sn === H.endSN && !M.nextStart) {
                      var ge = Math.min(f.duration, le.start + le.duration);
                      if (ge - Math.max(M.end, le.start) <= Math.max(0.2, le.duration)) {
                        var Re = {};
                        this.altAudio && (Re.type = "video"), this.hls.trigger(d.a.BUFFER_EOS, Re), this.state = oe.ENDED;
                        return;
                      }
                    }
                    this._fetchPayloadOrEos(v, M, H);
                  }
                }
              }
            }, s.prototype._fetchPayloadOrEos = function(a, l, f) {
              var v = this.fragPrevious, C = this.level, w = f.fragments, k = w.length;
              if (k !== 0) {
                var I = w[0].start, M = w[k - 1].start + w[k - 1].duration, $ = l.end, H = void 0;
                if (f.initSegment && !f.initSegment.data)
                  H = f.initSegment;
                else if (f.live) {
                  var le = this.config.initialLiveManifestSize;
                  if (k < le) {
                    p.b.warn("Can not start playback of a level, reason: not enough fragments " + k + " < " + le);
                    return;
                  }
                  if (H = this._ensureFragmentAtLivePoint(f, $, I, M, v, w, k), H === null)
                    return;
                } else
                  $ < I && (H = w[0]);
                H || (H = this._findFragment(I, v, k, w, $, M, f)), H && this._loadFragmentOrKey(H, C, f, a, $);
              }
            }, s.prototype._ensureFragmentAtLivePoint = function(a, l, f, v, C, w, k) {
              var I = this.hls.config, M = this.media, $ = void 0, H = I.liveMaxLatencyDuration !== void 0 ? I.liveMaxLatencyDuration : I.liveMaxLatencyDurationCount * a.targetduration;
              if (l < Math.max(f - I.maxFragLookUpTolerance, v - H)) {
                var le = this.liveSyncPosition = this.computeLivePosition(f, a);
                p.b.log("buffer end: " + l.toFixed(3) + " is located too far from the end of live sliding playlist, reset currentTime to : " + le.toFixed(3)), l = le, M && M.readyState && M.duration > le && (M.currentTime = le), this.nextLoadPosition = le;
              }
              if (a.PTSKnown && l > v && M && M.readyState)
                return null;
              if (this.startFragRequested && !a.PTSKnown) {
                if (C) {
                  var ge = C.sn + 1;
                  if (ge >= a.startSN && ge <= a.endSN) {
                    var Re = w[ge - a.startSN];
                    C.cc === Re.cc && ($ = Re, p.b.log("live playlist, switching playlist, load frag with next SN: " + $.sn));
                  }
                  $ || ($ = Ze.search(w, function(ve) {
                    return C.cc - ve.cc;
                  }), $ && p.b.log("live playlist, switching playlist, load frag with same CC: " + $.sn));
                }
                $ || ($ = w[Math.min(k - 1, Math.round(k / 2))], p.b.log("live playlist, switching playlist, unknown, load middle frag : " + $.sn));
              }
              return $;
            }, s.prototype._findFragment = function(a, l, f, v, C, w, k) {
              var I = this.hls.config, M = void 0, $ = void 0, H = I.maxFragLookUpTolerance, le = l ? v[l.sn - v[0].sn + 1] : void 0, ge = function(_t) {
                var Ce = Math.min(H, _t.duration + (_t.deltaPTS ? _t.deltaPTS : 0));
                return _t.start + _t.duration - Ce <= C ? 1 : _t.start - Ce > C && _t.start ? -1 : 0;
              };
              if (C < w ? (C > w - H && (H = 0), le && !ge(le) ? $ = le : $ = Ze.search(v, ge)) : $ = v[f - 1], $) {
                M = $;
                var Re = M.sn - k.startSN, ve = l && M.level === l.level, Pe = v[Re - 1], Be = v[Re + 1];
                if (l && M.sn === l.sn)
                  if (ve && !M.backtracked)
                    if (M.sn < k.endSN) {
                      var Ne = l.deltaPTS;
                      Ne && Ne > I.maxBufferHole && l.dropped && Re ? (M = Pe, p.b.warn("SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this"), l.loadCounter--) : (M = Be, p.b.log("SN just loaded, load next one: " + M.sn));
                    } else
                      M = null;
                  else M.backtracked && (Be && Be.backtracked ? (p.b.warn("Already backtracked from fragment " + Be.sn + ", will not backtrack to fragment " + M.sn + ". Loading fragment " + Be.sn), M = Be) : (p.b.warn("Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe"), M.dropped = 0, Pe ? (Pe.loadCounter && Pe.loadCounter--, M = Pe, M.backtracked = !0) : Re && (M = null)));
              }
              return M;
            }, s.prototype._loadFragmentOrKey = function(a, l, f, v, C) {
              var w = this.hls, k = w.config;
              if (a.decryptdata && a.decryptdata.uri != null && a.decryptdata.key == null)
                p.b.log("Loading key for " + a.sn + " of [" + f.startSN + " ," + f.endSN + "],level " + l), this.state = oe.KEY_LOADING, w.trigger(d.a.KEY_LOADING, { frag: a });
              else {
                if (p.b.log("Loading " + a.sn + " of [" + f.startSN + " ," + f.endSN + "],level " + l + ", currentTime:" + v.toFixed(3) + ",bufferEnd:" + C.toFixed(3)), this.fragLoadIdx !== void 0 ? this.fragLoadIdx++ : this.fragLoadIdx = 0, a.loadCounter) {
                  a.loadCounter++;
                  var I = k.fragLoadingLoopThreshold;
                  if (a.loadCounter > I && Math.abs(this.fragLoadIdx - a.loadIdx) < I) {
                    w.trigger(d.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.FRAG_LOOP_LOADING_ERROR, fatal: !1, frag: a });
                    return;
                  }
                } else
                  a.loadCounter = 1;
                a.loadIdx = this.fragLoadIdx, a.autoLevel = w.autoLevelEnabled, a.bitrateTest = this.bitrateTest, this.fragCurrent = a, this.startFragRequested = !0, !isNaN(a.sn) && !a.bitrateTest && (this.nextLoadPosition = a.start + a.duration), w.trigger(d.a.FRAG_LOADING, { frag: a }), this.demuxer || (this.demuxer = new j(w, "main")), this.state = oe.FRAG_LOADING;
                return;
              }
            }, s.prototype.getBufferedFrag = function(a) {
              return Ze.search(this._bufferedFrags, function(l) {
                return a < l.startPTS ? -1 : a > l.endPTS ? 1 : 0;
              });
            }, s.prototype.followingBufferedFrag = function(a) {
              return a ? this.getBufferedFrag(a.endPTS + 0.5) : null;
            }, s.prototype._checkFragmentChanged = function() {
              var a, l, f = this.media;
              if (f && f.readyState && f.seeking === !1 && (l = f.currentTime, l > f.playbackRate * this.lastCurrentTime && (this.lastCurrentTime = l), Ye.isBuffered(f, l) ? a = this.getBufferedFrag(l) : Ye.isBuffered(f, l + 0.1) && (a = this.getBufferedFrag(l + 0.1)), a)) {
                var v = a;
                if (v !== this.fragPlaying) {
                  this.hls.trigger(d.a.FRAG_CHANGED, { frag: v });
                  var C = v.level;
                  (!this.fragPlaying || this.fragPlaying.level !== C) && this.hls.trigger(d.a.LEVEL_SWITCHED, { level: C }), this.fragPlaying = v;
                }
              }
            }, s.prototype.immediateLevelSwitch = function() {
              if (p.b.log("immediateLevelSwitch"), !this.immediateSwitch) {
                this.immediateSwitch = !0;
                var a = this.media, l = void 0;
                a ? (l = a.paused, a.pause()) : l = !0, this.previouslyPaused = l;
              }
              var f = this.fragCurrent;
              f && f.loader && f.loader.abort(), this.fragCurrent = null, this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }, s.prototype.immediateLevelSwitchEnd = function() {
              var a = this.media;
              a && a.buffered.length && (this.immediateSwitch = !1, Ye.isBuffered(a, a.currentTime) && (a.currentTime -= 1e-4), this.previouslyPaused || a.play());
            }, s.prototype.nextLevelSwitch = function() {
              var a = this.media;
              if (a && a.readyState) {
                var l = void 0, f = void 0, v = void 0;
                if (this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), f = this.getBufferedFrag(a.currentTime), f && f.startPTS > 1 && this.flushMainBuffer(0, f.startPTS - 1), a.paused)
                  l = 0;
                else {
                  var C = this.hls.nextLoadLevel, w = this.levels[C], k = this.fragLastKbps;
                  k && this.fragCurrent ? l = this.fragCurrent.duration * w.bitrate / (1e3 * k) + 1 : l = 0;
                }
                if (v = this.getBufferedFrag(a.currentTime + l), v && (v = this.followingBufferedFrag(v), v)) {
                  var I = this.fragCurrent;
                  I && I.loader && I.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(v.maxStartPTS, Number.POSITIVE_INFINITY);
                }
              }
            }, s.prototype.flushMainBuffer = function(a, l) {
              this.state = oe.BUFFER_FLUSHING;
              var f = { startOffset: a, endOffset: l };
              this.altAudio && (f.type = "video"), this.hls.trigger(d.a.BUFFER_FLUSHING, f);
            }, s.prototype.onMediaAttached = function(a) {
              var l = this.media = this.mediaBuffer = a.media;
              this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), l.addEventListener("seeking", this.onvseeking), l.addEventListener("seeked", this.onvseeked), l.addEventListener("ended", this.onvended);
              var f = this.config;
              this.levels && f.autoStartLoad && this.hls.startLoad(f.startPosition);
            }, s.prototype.onMediaDetaching = function() {
              var a = this.media;
              a && a.ended && (p.b.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
              var l = this.levels;
              l && l.forEach(function(f) {
                f.details && f.details.fragments.forEach(function(v) {
                  v.loadCounter = void 0, v.backtracked = void 0;
                });
              }), a && (a.removeEventListener("seeking", this.onvseeking), a.removeEventListener("seeked", this.onvseeked), a.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad();
            }, s.prototype.onMediaSeeking = function() {
              var a = this.media, l = a ? a.currentTime : void 0, f = this.config;
              isNaN(l) || p.b.log("media seeking to " + l.toFixed(3));
              var v = this.mediaBuffer ? this.mediaBuffer : a, C = Ye.bufferInfo(v, l, this.config.maxBufferHole);
              if (this.state === oe.FRAG_LOADING) {
                var w = this.fragCurrent;
                if (C.len === 0 && w) {
                  var k = f.maxFragLookUpTolerance, I = w.start - k, M = w.start + w.duration + k;
                  l < I || l > M ? (w.loader && (p.b.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), w.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.state = oe.IDLE) : p.b.log("seeking outside of buffer but within currently loaded fragment range");
                }
              } else this.state === oe.ENDED && (C.len === 0 && (this.fragPrevious = 0), this.state = oe.IDLE);
              a && (this.lastCurrentTime = l), this.state !== oe.FRAG_LOADING && this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * f.fragLoadingLoopThreshold), this.loadedmetadata || (this.nextLoadPosition = this.startPosition = l), this.tick();
            }, s.prototype.onMediaSeeked = function() {
              var a = this.media, l = a ? a.currentTime : void 0;
              isNaN(l) || p.b.log("media seeked to " + l.toFixed(3)), this.tick();
            }, s.prototype.onMediaEnded = function() {
              p.b.log("media ended"), this.startPosition = this.lastCurrentTime = 0;
            }, s.prototype.onManifestLoading = function() {
              p.b.log("trigger BUFFER_RESET"), this.hls.trigger(d.a.BUFFER_RESET), this._bufferedFrags = [], this.stalled = !1, this.startPosition = this.lastCurrentTime = 0;
            }, s.prototype.onManifestParsed = function(a) {
              var l = !1, f = !1, v;
              a.levels.forEach(function(w) {
                v = w.audioCodec, v && (v.indexOf("mp4a.40.2") !== -1 && (l = !0), v.indexOf("mp4a.40.5") !== -1 && (f = !0));
              }), this.audioCodecSwitch = l && f, this.audioCodecSwitch && p.b.log("both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = a.levels, this.startFragRequested = !1;
              var C = this.config;
              (C.autoStartLoad || this.forceStartLoad) && this.hls.startLoad(C.startPosition);
            }, s.prototype.onLevelLoaded = function(a) {
              var l = a.details, f = a.level, v = this.levels[this.levelLastLoaded], C = this.levels[f], w = l.totalduration, k = 0;
              if (p.b.log("level " + f + " loaded [" + l.startSN + "," + l.endSN + "],duration:" + w), l.live) {
                var I = C.details;
                I && l.fragments.length > 0 ? (D(I, l), k = l.fragments[0].start, this.liveSyncPosition = this.computeLivePosition(k, I), l.PTSKnown && !isNaN(k) ? p.b.log("live playlist sliding:" + k.toFixed(3)) : (p.b.log("live playlist - outdated PTS, unknown sliding"), ue(this.fragPrevious, v, l))) : (p.b.log("live playlist - first load, unknown sliding"), l.PTSKnown = !1, ue(this.fragPrevious, v, l));
              } else
                l.PTSKnown = !1;
              if (C.details = l, this.levelLastLoaded = f, this.hls.trigger(d.a.LEVEL_UPDATED, { details: l, level: f }), this.startFragRequested === !1) {
                if (this.startPosition === -1 || this.lastCurrentTime === -1) {
                  var M = l.startTimeOffset;
                  isNaN(M) ? l.live ? (this.startPosition = this.computeLivePosition(k, l), p.b.log("configure startPosition to " + this.startPosition)) : this.startPosition = 0 : (M < 0 && (p.b.log("negative start time offset " + M + ", count from end of last fragment"), M = k + w + M), p.b.log("start time offset found in playlist, adjust startPosition to " + M), this.startPosition = M), this.lastCurrentTime = this.startPosition;
                }
                this.nextLoadPosition = this.startPosition;
              }
              this.state === oe.WAITING_LEVEL && (this.state = oe.IDLE), this.tick();
            }, s.prototype.onKeyLoaded = function() {
              this.state === oe.KEY_LOADING && (this.state = oe.IDLE, this.tick());
            }, s.prototype.onFragLoaded = function(a) {
              var l = this.fragCurrent, f = a.frag;
              if (this.state === oe.FRAG_LOADING && l && f.type === "main" && f.level === l.level && f.sn === l.sn) {
                var v = a.stats, C = this.levels[l.level], w = C.details;
                if (p.b.log("Loaded  " + l.sn + " of [" + w.startSN + " ," + w.endSN + "],level " + l.level), this.bitrateTest = !1, this.stats = v, f.bitrateTest === !0 && this.hls.nextLoadLevel)
                  this.state = oe.IDLE, this.startFragRequested = !1, v.tparsed = v.tbuffered = performance.now(), this.hls.trigger(d.a.FRAG_BUFFERED, { stats: v, frag: l, id: "main" }), this.tick();
                else if (f.sn === "initSegment")
                  this.state = oe.IDLE, v.tparsed = v.tbuffered = performance.now(), w.initSegment.data = a.payload, this.hls.trigger(d.a.FRAG_BUFFERED, { stats: v, frag: l, id: "main" }), this.tick();
                else {
                  this.state = oe.PARSING;
                  var k = w.totalduration, I = l.level, M = l.sn, $ = this.config.defaultAudioCodec || C.audioCodec;
                  this.audioCodecSwap && (p.b.log("swapping playlist audio codec"), $ === void 0 && ($ = this.lastAudioCodec), $ && ($.indexOf("mp4a.40.5") !== -1 ? $ = "mp4a.40.2" : $ = "mp4a.40.5")), this.pendingBuffering = !0, this.appended = !1, p.b.log("Parsing " + M + " of [" + w.startSN + " ," + w.endSN + "],level " + I + ", cc " + l.cc);
                  var H = this.demuxer;
                  H || (H = this.demuxer = new j(this.hls, "main"));
                  var le = this.media, ge = le && le.seeking, Re = !ge && (w.PTSKnown || !w.live), ve = w.initSegment ? w.initSegment.data : [];
                  H.push(a.payload, ve, $, C.videoCodec, l, k, Re, void 0);
                }
              }
              this.fragLoadError = 0;
            }, s.prototype.onFragParsingInitSegment = function(a) {
              var l = this.fragCurrent, f = a.frag;
              if (l && a.id === "main" && f.sn === l.sn && f.level === l.level && this.state === oe.PARSING) {
                var v = a.tracks, C, w;
                if (v.audio && this.altAudio && delete v.audio, w = v.audio, w) {
                  var k = this.levels[this.level].audioCodec, I = navigator.userAgent.toLowerCase();
                  k && this.audioCodecSwap && (p.b.log("swapping playlist audio codec"), k.indexOf("mp4a.40.5") !== -1 ? k = "mp4a.40.2" : k = "mp4a.40.5"), this.audioCodecSwitch && w.metadata.channelCount !== 1 && // don't force HE-AAC if firefox
                  I.indexOf("firefox") === -1 && (k = "mp4a.40.5"), I.indexOf("android") !== -1 && w.container !== "audio/mpeg" && (k = "mp4a.40.2", p.b.log("Android: force audio codec to " + k)), w.levelCodec = k, w.id = a.id;
                }
                w = v.video, w && (w.levelCodec = this.levels[this.level].videoCodec, w.id = a.id), this.hls.trigger(d.a.BUFFER_CODECS, v);
                for (C in v) {
                  w = v[C], p.b.log("main track:" + C + ",container:" + w.container + ",codecs[level/parsed]=[" + w.levelCodec + "/" + w.codec + "]");
                  var M = w.initSegment;
                  M && (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(d.a.BUFFER_APPENDING, { type: C, data: M, parent: "main", content: "initSegment" }));
                }
                this.tick();
              }
            }, s.prototype.onFragParsingData = function(a) {
              var l = this, f = this.fragCurrent, v = a.frag;
              if (f && a.id === "main" && v.sn === f.sn && v.level === f.level && !(a.type === "audio" && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
              this.state === oe.PARSING) {
                var C = this.levels[this.level], w = f;
                if (isNaN(a.endPTS) && (a.endPTS = a.startPTS + f.duration, a.endDTS = a.startDTS + f.duration), p.b.log("Parsed " + a.type + ",PTS:[" + a.startPTS.toFixed(3) + "," + a.endPTS.toFixed(3) + "],DTS:[" + a.startDTS.toFixed(3) + "/" + a.endDTS.toFixed(3) + "],nb:" + a.nb + ",dropped:" + (a.dropped || 0)), a.type === "video")
                  if (w.dropped = a.dropped, w.dropped)
                    if (w.backtracked)
                      p.b.warn("Already backtracked on this fragment, appending with the gap");
                    else {
                      var k = C.details;
                      if (k && w.sn === k.startSN)
                        p.b.warn("missing video frame(s) on first frag, appending with gap");
                      else {
                        p.b.warn("missing video frame(s), backtracking fragment"), w.backtracked = !0, this.nextLoadPosition = a.startPTS, this.state = oe.IDLE, this.fragPrevious = w, this.tick();
                        return;
                      }
                    }
                  else
                    w.backtracked = !1;
                var I = T(C.details, w, a.startPTS, a.endPTS, a.startDTS, a.endDTS), M = this.hls;
                M.trigger(d.a.LEVEL_PTS_UPDATED, { details: C.details, level: this.level, drift: I, type: a.type, start: a.startPTS, end: a.endPTS }), [a.data1, a.data2].forEach(function($) {
                  $ && $.length && l.state === oe.PARSING && (l.appended = !0, l.pendingBuffering = !0, M.trigger(d.a.BUFFER_APPENDING, { type: a.type, data: $, parent: "main", content: "data" }));
                }), this.tick();
              }
            }, s.prototype.onFragParsed = function(a) {
              var l = this.fragCurrent, f = a.frag;
              l && a.id === "main" && f.sn === l.sn && f.level === l.level && this.state === oe.PARSING && (this.stats.tparsed = performance.now(), this.state = oe.PARSED, this._checkAppendedParsed());
            }, s.prototype.onAudioTrackSwitching = function(a) {
              var l = !!a.url, f = a.id;
              if (!l) {
                if (this.mediaBuffer !== this.media) {
                  p.b.log("switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                  var v = this.fragCurrent;
                  v.loader && (p.b.log("switching to main audio track, cancel main fragment load"), v.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = oe.IDLE;
                }
                var C = this.hls;
                C.trigger(d.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), C.trigger(d.a.AUDIO_TRACK_SWITCHED, { id: f }), this.altAudio = !1;
              }
            }, s.prototype.onAudioTrackSwitched = function(a) {
              var l = a.id, f = !!this.hls.audioTracks[l].url;
              if (f) {
                var v = this.videoBuffer;
                v && this.mediaBuffer !== v && (p.b.log("switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = v);
              }
              this.altAudio = f, this.tick();
            }, s.prototype.onBufferCreated = function(a) {
              var l = a.tracks, f = void 0, v = void 0, C = !1;
              for (var w in l) {
                var k = l[w];
                k.id === "main" ? (v = w, f = k, w === "video" && (this.videoBuffer = l[w].buffer)) : C = !0;
              }
              C && f ? (p.b.log("alternate track found, use " + v + ".buffered to schedule main fragment loading"), this.mediaBuffer = f.buffer) : this.mediaBuffer = this.media;
            }, s.prototype.onBufferAppended = function(a) {
              if (a.parent === "main") {
                var l = this.state;
                (l === oe.PARSING || l === oe.PARSED) && (this.pendingBuffering = a.pending > 0, this._checkAppendedParsed());
              }
            }, s.prototype._checkAppendedParsed = function() {
              if (this.state === oe.PARSED && (!this.appended || !this.pendingBuffering)) {
                var a = this.fragCurrent;
                if (a) {
                  var l = this.mediaBuffer ? this.mediaBuffer : this.media;
                  p.b.log("main buffered : " + U.toString(l.buffered));
                  var f = this._bufferedFrags.filter(function(C) {
                    return Ye.isBuffered(l, (C.startPTS + C.endPTS) / 2);
                  });
                  f.push(a), this._bufferedFrags = f.sort(function(C, w) {
                    return C.startPTS - w.startPTS;
                  }), this.fragPrevious = a;
                  var v = this.stats;
                  v.tbuffered = performance.now(), this.fragLastKbps = Math.round(8 * v.total / (v.tbuffered - v.tfirst)), this.hls.trigger(d.a.FRAG_BUFFERED, { stats: v, frag: a, id: "main" }), this.state = oe.IDLE;
                }
                this.tick();
              }
            }, s.prototype.onError = function(a) {
              var l = a.frag || this.fragCurrent;
              if (!(l && l.type !== "main")) {
                var f = !!this.media && Ye.isBuffered(this.media, this.media.currentTime) && Ye.isBuffered(this.media, this.media.currentTime + 0.5);
                switch (a.details) {
                  case m.a.FRAG_LOAD_ERROR:
                  case m.a.FRAG_LOAD_TIMEOUT:
                  case m.a.KEY_LOAD_ERROR:
                  case m.a.KEY_LOAD_TIMEOUT:
                    if (!a.fatal)
                      if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
                        var v = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
                        l.loadCounter = 0, p.b.warn("mediaController: frag loading failed, retry in " + v + " ms"), this.retryDate = performance.now() + v, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.fragLoadError++, this.state = oe.FRAG_LOADING_WAITING_RETRY;
                      } else
                        p.b.error("mediaController: " + a.details + " reaches max retry, redispatch as fatal ..."), a.fatal = !0, this.state = oe.ERROR;
                    break;
                  case m.a.FRAG_LOOP_LOADING_ERROR:
                    a.fatal || (f ? (this._reduceMaxBufferLength(l.duration), this.state = oe.IDLE) : (!l.autoLevel || l.level === 0) && (a.fatal = !0, this.state = oe.ERROR));
                    break;
                  case m.a.LEVEL_LOAD_ERROR:
                  case m.a.LEVEL_LOAD_TIMEOUT:
                    this.state !== oe.ERROR && (a.fatal ? (this.state = oe.ERROR, p.b.warn("streamController: " + a.details + ",switch to " + this.state + " state ...")) : !a.levelRetry && this.state === oe.WAITING_LEVEL && (this.state = oe.IDLE));
                    break;
                  case m.a.BUFFER_FULL_ERROR:
                    a.parent === "main" && (this.state === oe.PARSING || this.state === oe.PARSED) && (f ? (this._reduceMaxBufferLength(this.config.maxBufferLength), this.state = oe.IDLE) : (p.b.warn("buffer full error also media.currentTime is not buffered, flush everything"), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY)));
                    break;
                }
              }
            }, s.prototype._reduceMaxBufferLength = function(a) {
              var l = this.config;
              l.maxMaxBufferLength >= a && (l.maxMaxBufferLength /= 2, p.b.warn("main:reduce max buffer length to " + l.maxMaxBufferLength + "s"), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * l.fragLoadingLoopThreshold));
            }, s.prototype._checkBuffer = function() {
              var a = this.media, l = this.config;
              if (a && a.readyState) {
                var f = a.currentTime, v = this.mediaBuffer ? this.mediaBuffer : a, C = v.buffered;
                if (!this.loadedmetadata && C.length) {
                  this.loadedmetadata = !0;
                  var w = a.seeking ? f : this.startPosition, k = Ye.isBuffered(v, w), I = C.start(0), M = !k && Math.abs(w - I) < l.maxSeekHole;
                  (f !== w || M) && (p.b.log("target start position:" + w), M && (w = I, p.b.log("target start position not buffered, seek to buffered.start(0) " + w)), p.b.log("adjust currentTime from " + f + " to " + w), a.currentTime = w);
                } else if (this.immediateSwitch)
                  this.immediateLevelSwitchEnd();
                else {
                  var $ = Ye.bufferInfo(a, f, 0), H = !(a.paused || // not playing when media is paused
                  a.ended || // not playing when media is ended
                  a.buffered.length === 0), le = 0.5, ge = f !== this.lastCurrentTime;
                  if (ge)
                    this.stallReported && (p.b.warn("playback not stuck anymore @" + f + ", after " + Math.round(performance.now() - this.stalled) + "ms"), this.stallReported = !1), this.stalled = void 0, this.nudgeRetry = 0;
                  else if (H) {
                    var Re = performance.now(), ve = this.hls;
                    if (!this.stalled)
                      this.stalled = Re, this.stallReported = !1;
                    else {
                      var Pe = Re - this.stalled, Be = $.len, Ne = this.nudgeRetry || 0;
                      if (Be <= le && Pe > l.lowBufferWatchdogPeriod * 1e3) {
                        this.stallReported || (this.stallReported = !0, p.b.warn("playback stalling in low buffer @" + f), ve.trigger(d.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.BUFFER_STALLED_ERROR, fatal: !1, buffer: Be }));
                        var et = $.nextStart, _t = et - f;
                        if (et && _t < l.maxSeekHole && _t > 0) {
                          this.nudgeRetry = ++Ne;
                          var Ce = Ne * l.nudgeOffset;
                          p.b.log("adjust currentTime from " + a.currentTime + " to next buffered @ " + et + " + nudge " + Ce), a.currentTime = et + Ce, this.stalled = void 0, ve.trigger(d.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.BUFFER_SEEK_OVER_HOLE, fatal: !1, hole: et + Ce - f });
                        }
                      } else if (Be > le && Pe > l.highBufferWatchdogPeriod * 1e3)
                        if (this.stallReported || (this.stallReported = !0, p.b.warn("playback stalling in high buffer @" + f), ve.trigger(d.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.BUFFER_STALLED_ERROR, fatal: !1, buffer: Be })), this.stalled = void 0, this.nudgeRetry = ++Ne, Ne < l.nudgeMaxRetry) {
                          var zt = a.currentTime, bt = zt + Ne * l.nudgeOffset;
                          p.b.log("adjust currentTime from " + zt + " to " + bt), a.currentTime = bt, ve.trigger(d.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.BUFFER_NUDGE_ON_STALL, fatal: !1 });
                        } else
                          p.b.error("still stuck in high buffer @" + f + " after " + l.nudgeMaxRetry + ", raise fatal error"), ve.trigger(d.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.BUFFER_STALLED_ERROR, fatal: !0 });
                    }
                  }
                }
              }
            }, s.prototype.onFragLoadEmergencyAborted = function() {
              this.state = oe.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tick();
            }, s.prototype.onBufferFlushed = function() {
              var a = this.mediaBuffer ? this.mediaBuffer : this.media;
              this._bufferedFrags = this._bufferedFrags.filter(function(l) {
                return Ye.isBuffered(a, (l.startPTS + l.endPTS) / 2);
              }), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.state = oe.IDLE, this.fragPrevious = null;
            }, s.prototype.swapAudioCodec = function() {
              this.audioCodecSwap = !this.audioCodecSwap;
            }, s.prototype.computeLivePosition = function(a, l) {
              var f = this.config.liveSyncDuration !== void 0 ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * l.targetduration;
              return a + Math.max(0, l.totalduration - f);
            }, ae(s, [{
              key: "state",
              set: function(a) {
                if (this.state !== a) {
                  var l = this.state;
                  this._state = a, p.b.log("main stream:" + l + "->" + a), this.hls.trigger(d.a.STREAM_STATE_TRANSITION, { previousState: l, nextState: a });
                }
              },
              get: function() {
                return this._state;
              }
            }, {
              key: "currentLevel",
              get: function() {
                var a = this.media;
                if (a) {
                  var l = this.getBufferedFrag(a.currentTime);
                  if (l)
                    return l.level;
                }
                return -1;
              }
            }, {
              key: "nextBufferedFrag",
              get: function() {
                var a = this.media;
                return a ? this.followingBufferedFrag(this.getBufferedFrag(a.currentTime)) : null;
              }
            }, {
              key: "nextLevel",
              get: function() {
                var a = this.nextBufferedFrag;
                return a ? a.level : -1;
              }
            }, {
              key: "liveSyncPosition",
              get: function() {
                return this._liveSyncPosition;
              },
              set: function(a) {
                this._liveSyncPosition = a;
              }
            }]), s;
          }(X), nt = Ke, ot = /* @__PURE__ */ function() {
            function x(s, o) {
              for (var a = 0; a < o.length; a++) {
                var l = o[a];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, a) {
              return o && x(s.prototype, o), a && x(s, a), s;
            };
          }();
          function qe(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Je(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function Le(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var ct = function(x) {
            Le(s, x);
            function s(o) {
              qe(this, s);
              var a = Je(this, x.call(this, o, d.a.MANIFEST_LOADED, d.a.LEVEL_LOADED, d.a.FRAG_LOADED, d.a.ERROR));
              return a.canload = !1, a.currentLevelIndex = null, a.manualLevelIndex = -1, a.timer = null, a;
            }
            return s.prototype.destroy = function() {
              this.cleanTimer(), this.manualLevelIndex = -1;
            }, s.prototype.cleanTimer = function() {
              this.timer !== null && (clearTimeout(this.timer), this.timer = null);
            }, s.prototype.startLoad = function() {
              var a = this._levels;
              this.canload = !0, this.levelRetryCount = 0, a && a.forEach(function(l) {
                l.loadError = 0;
                var f = l.details;
                f && f.live && (l.details = void 0);
              }), this.timer !== null && this.loadLevel();
            }, s.prototype.stopLoad = function() {
              this.canload = !1;
            }, s.prototype.onManifestLoaded = function(a) {
              var l = [], f = void 0, v = {}, C = null, w = !1, k = !1, I = /chrome|firefox/.test(navigator.userAgent.toLowerCase()), M = [];
              if (a.levels.forEach(function(H) {
                H.loadError = 0, H.fragmentError = !1, w = w || !!H.videoCodec, k = k || !!H.audioCodec || !!(H.attrs && H.attrs.AUDIO), I === !0 && H.audioCodec && H.audioCodec.indexOf("mp4a.40.34") !== -1 && (H.audioCodec = void 0), C = v[H.bitrate], C === void 0 ? (H.url = [H.url], H.urlId = 0, v[H.bitrate] = H, l.push(H)) : C.url.push(H.url);
              }), w === !0 && k === !0 && (l = l.filter(function(H) {
                var le = H.videoCodec;
                return !!le;
              })), l = l.filter(function(H) {
                var le = H.audioCodec, ge = H.videoCodec;
                return (!le || xe(le)) && (!ge || xe(ge));
              }), a.audioTracks && (M = a.audioTracks.filter(function(H) {
                return !H.audioCodec || xe(H.audioCodec, "audio");
              })), l.length > 0) {
                f = l[0].bitrate, l.sort(function(H, le) {
                  return H.bitrate - le.bitrate;
                }), this._levels = l;
                for (var $ = 0; $ < l.length; $++)
                  if (l[$].bitrate === f) {
                    this._firstLevel = $, p.b.log("manifest loaded," + l.length + " level(s) found, first bitrate:" + f);
                    break;
                  }
                this.hls.trigger(d.a.MANIFEST_PARSED, {
                  levels: l,
                  audioTracks: M,
                  firstLevel: this._firstLevel,
                  stats: a.stats,
                  audio: k,
                  video: w,
                  altAudio: M.length > 0
                });
              } else
                this.hls.trigger(d.a.ERROR, {
                  type: m.b.MEDIA_ERROR,
                  details: m.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                  fatal: !0,
                  url: this.hls.url,
                  reason: "no level with compatible codecs found in manifest"
                });
            }, s.prototype.setLevelInternal = function(a) {
              var l = this._levels, f = this.hls;
              if (a >= 0 && a < l.length) {
                if (this.cleanTimer(), this.currentLevelIndex !== a) {
                  p.b.log("switching to level " + a), this.currentLevelIndex = a;
                  var v = l[a];
                  v.level = a, f.trigger(d.a.LEVEL_SWITCH, v), f.trigger(d.a.LEVEL_SWITCHING, v);
                }
                var C = l[a], w = C.details;
                if (!w || w.live === !0) {
                  var k = C.urlId;
                  f.trigger(d.a.LEVEL_LOADING, { url: C.url[k], level: a, id: k });
                }
              } else
                f.trigger(d.a.ERROR, {
                  type: m.b.OTHER_ERROR,
                  details: m.a.LEVEL_SWITCH_ERROR,
                  level: a,
                  fatal: !1,
                  reason: "invalid level idx"
                });
            }, s.prototype.onError = function(a) {
              if (a.fatal === !0) {
                a.type === m.b.NETWORK_ERROR && this.cleanTimer();
                return;
              }
              var l = !1, f = !1, v = void 0;
              switch (a.details) {
                case m.a.FRAG_LOAD_ERROR:
                case m.a.FRAG_LOAD_TIMEOUT:
                case m.a.FRAG_LOOP_LOADING_ERROR:
                case m.a.KEY_LOAD_ERROR:
                case m.a.KEY_LOAD_TIMEOUT:
                  v = a.frag.level, f = !0;
                  break;
                case m.a.LEVEL_LOAD_ERROR:
                case m.a.LEVEL_LOAD_TIMEOUT:
                  v = a.context.level, l = !0;
                  break;
                case m.a.REMUX_ALLOC_ERROR:
                  v = a.level, l = !0;
                  break;
              }
              v !== void 0 && this.recoverLevel(a, v, l, f);
            }, s.prototype.recoverLevel = function(a, l, f, v) {
              var C = this, w = this.hls.config, k = a.details, I = this._levels[l], M = void 0, $ = void 0, H = void 0;
              if (I.loadError++, I.fragmentError = v, f === !0)
                if (this.levelRetryCount + 1 <= w.levelLoadingMaxRetry)
                  $ = Math.min(Math.pow(2, this.levelRetryCount) * w.levelLoadingRetryDelay, w.levelLoadingMaxRetryTimeout), this.timer = setTimeout(function() {
                    return C.loadLevel();
                  }, $), a.levelRetry = !0, this.levelRetryCount++, p.b.warn("level controller, " + k + ", retry in " + $ + " ms, current retry count is " + this.levelRetryCount);
                else {
                  p.b.error("level controller, cannot recover from " + k + " error"), this.currentLevelIndex = null, this.cleanTimer(), a.fatal = !0;
                  return;
                }
              (f === !0 || v === !0) && (M = I.url.length, M > 1 && I.loadError < M ? (p.b.warn("level controller, " + k + " for level " + l + ": switching to redundant stream id " + I.urlId), I.urlId = (I.urlId + 1) % M, I.details = void 0) : this.manualLevelIndex === -1 ? (H = l === 0 ? this._levels.length - 1 : l - 1, p.b.warn("level controller, " + k + ": switch to " + H), this.hls.nextAutoLevel = this.currentLevelIndex = H) : v === !0 && (p.b.warn("level controller, " + k + ": reload a fragment"), this.currentLevelIndex = null));
            }, s.prototype.onFragLoaded = function(a) {
              var l = a.frag;
              if (l !== void 0 && l.type === "main") {
                var f = this._levels[l.level];
                f !== void 0 && (f.fragmentError = !1, f.loadError = 0, this.levelRetryCount = 0);
              }
            }, s.prototype.onLevelLoaded = function(a) {
              var l = this, f = a.level;
              if (f === this.currentLevelIndex) {
                var v = this._levels[f];
                v.fragmentError === !1 && (v.loadError = 0, this.levelRetryCount = 0);
                var C = a.details;
                if (C.live) {
                  var w = 1e3 * (C.averagetargetduration ? C.averagetargetduration : C.targetduration), k = v.details;
                  k && C.endSN === k.endSN && (w /= 2, p.b.log("same live playlist, reload twice faster")), w -= performance.now() - a.stats.trequest, w = Math.max(1e3, Math.round(w)), p.b.log("live playlist, reload in " + w + " ms"), this.timer = setTimeout(function() {
                    return l.loadLevel();
                  }, w);
                } else
                  this.cleanTimer();
              }
            }, s.prototype.loadLevel = function() {
              var a = void 0, l = void 0;
              this.currentLevelIndex !== null && this.canload === !0 && (a = this._levels[this.currentLevelIndex], a !== void 0 && a.url.length > 0 && (l = a.urlId, this.hls.trigger(d.a.LEVEL_LOADING, { url: a.url[l], level: this.currentLevelIndex, id: l })));
            }, ot(s, [{
              key: "levels",
              get: function() {
                return this._levels;
              }
            }, {
              key: "level",
              get: function() {
                return this.currentLevelIndex;
              },
              set: function(a) {
                var l = this._levels;
                l && (a = Math.min(a, l.length - 1), (this.currentLevelIndex !== a || l[a].details === void 0) && this.setLevelInternal(a));
              }
            }, {
              key: "manualLevel",
              get: function() {
                return this.manualLevelIndex;
              },
              set: function(a) {
                this.manualLevelIndex = a, this._startLevel === void 0 && (this._startLevel = a), a !== -1 && (this.level = a);
              }
            }, {
              key: "firstLevel",
              get: function() {
                return this._firstLevel;
              },
              set: function(a) {
                this._firstLevel = a;
              }
            }, {
              key: "startLevel",
              get: function() {
                if (this._startLevel === void 0) {
                  var a = this.hls.config.startLevel;
                  return a !== void 0 ? a : this._firstLevel;
                } else
                  return this._startLevel;
              },
              set: function(a) {
                this._startLevel = a;
              }
            }, {
              key: "nextLoadLevel",
              get: function() {
                return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel;
              },
              set: function(a) {
                this.level = a, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = a);
              }
            }]), s;
          }(X), Lt = ct, ut = u(3);
          function At(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Kt(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function rr(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var Mt = function(x) {
            rr(s, x);
            function s(o) {
              At(this, s);
              var a = Kt(this, x.call(this, o, d.a.MEDIA_ATTACHED, d.a.MEDIA_DETACHING, d.a.FRAG_PARSING_METADATA));
              return a.id3Track = void 0, a.media = void 0, a;
            }
            return s.prototype.destroy = function() {
              X.prototype.destroy.call(this);
            }, s.prototype.onMediaAttached = function(a) {
              this.media = a.media, this.media;
            }, s.prototype.onMediaDetaching = function() {
              this.media = void 0;
            }, s.prototype.onFragParsingMetadata = function(a) {
              var l = a.frag, f = a.samples;
              this.id3Track || (this.id3Track = this.media.addTextTrack("metadata", "id3"), this.id3Track.mode = "hidden");
              for (var v = window.WebKitDataCue || window.VTTCue || window.TextTrackCue, C = 0; C < f.length; C++) {
                var w = ut.a.getID3Frames(f[C].data);
                if (w) {
                  var k = f[C].pts, I = C < f.length - 1 ? f[C + 1].pts : l.endPTS;
                  k === I && (I += 1e-4);
                  for (var M = 0; M < w.length; M++) {
                    var $ = w[M];
                    if (!ut.a.isTimeStampFrame($)) {
                      var H = new v(k, I, "");
                      H.value = $, this.id3Track.addCue(H);
                    }
                  }
                }
              }
            }, s;
          }(X), br = Mt;
          function qt() {
            var x = li(), s = window.SourceBuffer || window.WebKitSourceBuffer, o = x && typeof x.isTypeSupported == "function" && x.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'), a = !s || s.prototype && typeof s.prototype.appendBuffer == "function" && typeof s.prototype.remove == "function";
            return !!o && !!a;
          }
          function ir(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var Hr = function() {
            function x(s) {
              ir(this, x), this.alpha_ = s ? Math.exp(Math.log(0.5) / s) : 0, this.estimate_ = 0, this.totalWeight_ = 0;
            }
            return x.prototype.sample = function(o, a) {
              var l = Math.pow(this.alpha_, o);
              this.estimate_ = a * (1 - l) + l * this.estimate_, this.totalWeight_ += o;
            }, x.prototype.getTotalWeight = function() {
              return this.totalWeight_;
            }, x.prototype.getEstimate = function() {
              if (this.alpha_) {
                var o = 1 - Math.pow(this.alpha_, this.totalWeight_);
                return this.estimate_ / o;
              } else
                return this.estimate_;
            }, x;
          }(), Zr = Hr;
          function Ui(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var Xt = function() {
            function x(s, o, a, l) {
              Ui(this, x), this.hls = s, this.defaultEstimate_ = l, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new Zr(o), this.fast_ = new Zr(a);
            }
            return x.prototype.sample = function(o, a) {
              o = Math.max(o, this.minDelayMs_);
              var l = 8e3 * a / o, f = o / 1e3;
              this.fast_.sample(f, l), this.slow_.sample(f, l);
            }, x.prototype.canEstimate = function() {
              var o = this.fast_;
              return o && o.getTotalWeight() >= this.minWeight_;
            }, x.prototype.getEstimate = function() {
              return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
            }, x.prototype.destroy = function() {
            }, x;
          }(), kt = Xt, Cr = /* @__PURE__ */ function() {
            function x(s, o) {
              for (var a = 0; a < o.length; a++) {
                var l = o[a];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, a) {
              return o && x(s.prototype, o), a && x(s, a), s;
            };
          }();
          function Wr(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Vr(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function Oi(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var dn = function(x) {
            Oi(s, x);
            function s(o) {
              Wr(this, s);
              var a = Vr(this, x.call(this, o, d.a.FRAG_LOADING, d.a.FRAG_LOADED, d.a.FRAG_BUFFERED, d.a.ERROR));
              return a.lastLoadedFragLevel = 0, a._nextAutoLevel = -1, a.hls = o, a.timer = null, a._bwEstimator = null, a.onCheck = a._abandonRulesCheck.bind(a), a;
            }
            return s.prototype.destroy = function() {
              this.clearTimer(), X.prototype.destroy.call(this);
            }, s.prototype.onFragLoading = function(a) {
              var l = a.frag;
              if (l.type === "main") {
                if (this.timer || (this.timer = setInterval(this.onCheck, 100)), !this._bwEstimator) {
                  var f = this.hls, v = a.frag.level, C = f.levels[v].details.live, w = f.config, k = void 0, I = void 0;
                  C ? (k = w.abrEwmaFastLive, I = w.abrEwmaSlowLive) : (k = w.abrEwmaFastVoD, I = w.abrEwmaSlowVoD), this._bwEstimator = new kt(f, I, k, w.abrEwmaDefaultEstimate);
                }
                this.fragCurrent = l;
              }
            }, s.prototype._abandonRulesCheck = function() {
              var a = this.hls, l = a.media, f = this.fragCurrent, v = f.loader, C = a.minAutoLevel;
              if (!v || v.stats && v.stats.aborted) {
                p.b.warn("frag loader destroy or aborted, disarm abandonRules"), this.clearTimer(), this._nextAutoLevel = -1;
                return;
              }
              var w = v.stats;
              if (l && w && (!l.paused && l.playbackRate !== 0 || !l.readyState) && f.autoLevel && f.level) {
                var k = performance.now() - w.trequest, I = Math.abs(l.playbackRate);
                if (k > 500 * f.duration / I) {
                  var M = a.levels, $ = Math.max(1, w.bw ? w.bw / 8 : w.loaded * 1e3 / k), H = M[f.level], le = H.realBitrate ? Math.max(H.realBitrate, H.bitrate) : H.bitrate, ge = w.total ? w.total : Math.max(w.loaded, Math.round(f.duration * le / 8)), Re = l.currentTime, ve = (ge - w.loaded) / $, Pe = (Ye.bufferInfo(l, Re, a.config.maxBufferHole).end - Re) / I;
                  if (Pe < 2 * f.duration / I && ve > Pe) {
                    var Be = void 0, Ne = void 0;
                    for (Ne = f.level - 1; Ne > C; Ne--) {
                      var et = M[Ne].realBitrate ? Math.max(M[Ne].realBitrate, M[Ne].bitrate) : M[Ne].bitrate;
                      if (Be = f.duration * et / (8 * 0.8 * $), Be < Pe)
                        break;
                    }
                    Be < ve && (p.b.warn("loading too slow, abort fragment loading and switch to level " + Ne + ":fragLoadedDelay[" + Ne + "]<fragLoadedDelay[" + (f.level - 1) + "];bufferStarvationDelay:" + Be.toFixed(1) + "<" + ve.toFixed(1) + ":" + Pe.toFixed(1)), a.nextLoadLevel = Ne, this._bwEstimator.sample(k, w.loaded), v.abort(), this.clearTimer(), a.trigger(d.a.FRAG_LOAD_EMERGENCY_ABORTED, { frag: f, stats: w }));
                  }
                }
              }
            }, s.prototype.onFragLoaded = function(a) {
              var l = a.frag;
              if (l.type === "main" && !isNaN(l.sn)) {
                if (this.clearTimer(), this.lastLoadedFragLevel = l.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
                  var f = this.hls.levels[l.level], v = (f.loaded ? f.loaded.bytes : 0) + a.stats.loaded, C = (f.loaded ? f.loaded.duration : 0) + a.frag.duration;
                  f.loaded = { bytes: v, duration: C }, f.realBitrate = Math.round(8 * v / C);
                }
                if (a.frag.bitrateTest) {
                  var w = a.stats;
                  w.tparsed = w.tbuffered = w.tload, this.onFragBuffered(a);
                }
              }
            }, s.prototype.onFragBuffered = function(a) {
              var l = a.stats, f = a.frag;
              if (l.aborted !== !0 && f.loadCounter === 1 && f.type === "main" && !isNaN(f.sn) && (!f.bitrateTest || l.tload === l.tbuffered)) {
                var v = l.tparsed - l.trequest;
                p.b.log("latency/loading/parsing/append/kbps:" + Math.round(l.tfirst - l.trequest) + "/" + Math.round(l.tload - l.tfirst) + "/" + Math.round(l.tparsed - l.tload) + "/" + Math.round(l.tbuffered - l.tparsed) + "/" + Math.round(8 * l.loaded / (l.tbuffered - l.trequest))), this._bwEstimator.sample(v, l.loaded), l.bwEstimate = this._bwEstimator.getEstimate(), f.bitrateTest ? this.bitrateTestDelay = v / 1e3 : this.bitrateTestDelay = 0;
              }
            }, s.prototype.onError = function(a) {
              switch (a.details) {
                case m.a.FRAG_LOAD_ERROR:
                case m.a.FRAG_LOAD_TIMEOUT:
                  this.clearTimer();
                  break;
              }
            }, s.prototype.clearTimer = function() {
              clearInterval(this.timer), this.timer = null;
            }, s.prototype._findBestLevel = function(a, l, f, v, C, w, k, I, M) {
              for (var $ = C; $ >= v; $--) {
                var H = M[$], le = H.details, ge = le ? le.totalduration / le.fragments.length : l, Re = le ? le.live : !1, ve = void 0;
                $ <= a ? ve = k * f : ve = I * f;
                var Pe = M[$].realBitrate ? Math.max(M[$].realBitrate, M[$].bitrate) : M[$].bitrate, Be = Pe * ge / ve;
                if (p.b.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + $ + "/" + Math.round(ve) + "/" + Pe + "/" + ge + "/" + w + "/" + Be), ve > Pe && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
                // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
                // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
                (!Be || Re && !this.bitrateTestDelay || Be < w))
                  return $;
              }
              return -1;
            }, Cr(s, [{
              key: "nextAutoLevel",
              get: function() {
                var a = this._nextAutoLevel, l = this._bwEstimator;
                if (a !== -1 && (!l || !l.canEstimate()))
                  return a;
                var f = this._nextABRAutoLevel;
                return a !== -1 && (f = Math.min(a, f)), f;
              },
              set: function(a) {
                this._nextAutoLevel = a;
              }
            }, {
              key: "_nextABRAutoLevel",
              get: function() {
                var a = this.hls, l = a.maxAutoLevel, f = a.levels, v = a.config, C = a.minAutoLevel, w = a.media, k = this.lastLoadedFragLevel, I = this.fragCurrent ? this.fragCurrent.duration : 0, M = w ? w.currentTime : 0, $ = w && w.playbackRate !== 0 ? Math.abs(w.playbackRate) : 1, H = this._bwEstimator ? this._bwEstimator.getEstimate() : v.abrEwmaDefaultEstimate, le = (Ye.bufferInfo(w, M, v.maxBufferHole).end - M) / $, ge = this._findBestLevel(k, I, H, C, l, le, v.abrBandWidthFactor, v.abrBandWidthUpFactor, f);
                if (ge >= 0)
                  return ge;
                p.b.trace("rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering");
                var Re = I ? Math.min(I, v.maxStarvationDelay) : v.maxStarvationDelay, ve = v.abrBandWidthFactor, Pe = v.abrBandWidthUpFactor;
                if (le === 0) {
                  var Be = this.bitrateTestDelay;
                  if (Be) {
                    var Ne = I ? Math.min(I, v.maxLoadingDelay) : v.maxLoadingDelay;
                    Re = Ne - Be, p.b.trace("bitrate test took " + Math.round(1e3 * Be) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * Re) + " ms"), ve = Pe = 1;
                  }
                }
                return ge = this._findBestLevel(k, I, H, C, l, le + Re, ve, Pe, f), Math.max(ge, 0);
              }
            }]), s;
          }(X), Ki = dn;
          function Mi(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function jr(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function Yr(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var Jr = li(), fn = function(x) {
            Yr(s, x);
            function s(o) {
              Mi(this, s);
              var a = jr(this, x.call(this, o, d.a.MEDIA_ATTACHING, d.a.MEDIA_DETACHING, d.a.MANIFEST_PARSED, d.a.BUFFER_RESET, d.a.BUFFER_APPENDING, d.a.BUFFER_CODECS, d.a.BUFFER_EOS, d.a.BUFFER_FLUSHING, d.a.LEVEL_PTS_UPDATED, d.a.LEVEL_UPDATED));
              return a._msDuration = null, a._levelDuration = null, a._live = null, a._objectUrl = null, a.onsbue = a.onSBUpdateEnd.bind(a), a.onsbe = a.onSBUpdateError.bind(a), a.pendingTracks = {}, a.tracks = {}, a;
            }
            return s.prototype.destroy = function() {
              X.prototype.destroy.call(this);
            }, s.prototype.onLevelPtsUpdated = function(a) {
              var l = a.type, f = this.tracks.audio;
              if (l === "audio" && f && f.container === "audio/mpeg") {
                var v = this.sourceBuffer.audio, C = Math.abs(v.timestampOffset - a.start);
                if (C > 0.1) {
                  var w = v.updating;
                  try {
                    v.abort();
                  } catch (k) {
                    w = !0, p.b.warn("can not abort audio buffer: " + k);
                  }
                  w ? this.audioTimestampOffset = a.start : (p.b.warn("change mpeg audio timestamp offset from " + v.timestampOffset + " to " + a.start), v.timestampOffset = a.start);
                }
              }
            }, s.prototype.onManifestParsed = function(a) {
              var l = a.audio, f = a.video || a.levels.length && a.audio, v = 0;
              a.altAudio && (l || f) && (v = (l ? 1 : 0) + (f ? 1 : 0), p.b.log(v + " sourceBuffer(s) expected")), this.sourceBufferNb = v;
            }, s.prototype.onMediaAttaching = function(a) {
              var l = this.media = a.media;
              if (l) {
                var f = this.mediaSource = new Jr();
                this.onmso = this.onMediaSourceOpen.bind(this), this.onmse = this.onMediaSourceEnded.bind(this), this.onmsc = this.onMediaSourceClose.bind(this), f.addEventListener("sourceopen", this.onmso), f.addEventListener("sourceended", this.onmse), f.addEventListener("sourceclose", this.onmsc), l.src = URL.createObjectURL(f), this._objectUrl = l.src;
              }
            }, s.prototype.onMediaDetaching = function() {
              p.b.log("media source detaching");
              var a = this.mediaSource;
              if (a) {
                if (a.readyState === "open")
                  try {
                    a.endOfStream();
                  } catch (l) {
                    p.b.warn("onMediaDetaching:" + l.message + " while calling endOfStream");
                  }
                a.removeEventListener("sourceopen", this.onmso), a.removeEventListener("sourceended", this.onmse), a.removeEventListener("sourceclose", this.onmsc), this.media && (URL.revokeObjectURL(this._objectUrl), this.media.src === this._objectUrl ? (this.media.removeAttribute("src"), this.media.load()) : p.b.warn("media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.pendingTracks = {}, this.tracks = {}, this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;
              }
              this.onmso = this.onmse = this.onmsc = null, this.hls.trigger(d.a.MEDIA_DETACHED);
            }, s.prototype.onMediaSourceOpen = function() {
              p.b.log("media source opened"), this.hls.trigger(d.a.MEDIA_ATTACHED, { media: this.media });
              var a = this.mediaSource;
              a && a.removeEventListener("sourceopen", this.onmso), this.checkPendingTracks();
            }, s.prototype.checkPendingTracks = function() {
              var a = this.pendingTracks, l = Object.keys(a).length;
              l && (this.sourceBufferNb <= l || this.sourceBufferNb === 0) && (this.createSourceBuffers(a), this.pendingTracks = {}, this.doAppending());
            }, s.prototype.onMediaSourceClose = function() {
              p.b.log("media source closed");
            }, s.prototype.onMediaSourceEnded = function() {
              p.b.log("media source ended");
            }, s.prototype.onSBUpdateEnd = function() {
              if (this.audioTimestampOffset) {
                var a = this.sourceBuffer.audio;
                p.b.warn("change mpeg audio timestamp offset from " + a.timestampOffset + " to " + this.audioTimestampOffset), a.timestampOffset = this.audioTimestampOffset, delete this.audioTimestampOffset;
              }
              this._needsFlush && this.doFlush(), this._needsEos && this.checkEos(), this.appending = !1;
              var l = this.parent, f = this.segments.reduce(function(v, C) {
                return C.parent === l ? v + 1 : v;
              }, 0);
              this.hls.trigger(d.a.BUFFER_APPENDED, { parent: l, pending: f }), this._needsFlush || this.doAppending(), this.updateMediaElementDuration();
            }, s.prototype.onSBUpdateError = function(a) {
              p.b.error("sourceBuffer error:", a), this.hls.trigger(d.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.BUFFER_APPENDING_ERROR, fatal: !1 });
            }, s.prototype.onBufferReset = function() {
              var a = this.sourceBuffer;
              for (var l in a) {
                var f = a[l];
                try {
                  this.mediaSource.removeSourceBuffer(f), f.removeEventListener("updateend", this.onsbue), f.removeEventListener("error", this.onsbe);
                } catch {
                }
              }
              this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;
            }, s.prototype.onBufferCodecs = function(a) {
              if (Object.keys(this.sourceBuffer).length === 0) {
                for (var l in a)
                  this.pendingTracks[l] = a[l];
                var f = this.mediaSource;
                f && f.readyState === "open" && this.checkPendingTracks();
              }
            }, s.prototype.createSourceBuffers = function(a) {
              var l = this.sourceBuffer, f = this.mediaSource;
              for (var v in a)
                if (!l[v]) {
                  var C = a[v], w = C.levelCodec || C.codec, k = C.container + ";codecs=" + w;
                  p.b.log("creating sourceBuffer(" + k + ")");
                  try {
                    var I = l[v] = f.addSourceBuffer(k);
                    I.addEventListener("updateend", this.onsbue), I.addEventListener("error", this.onsbe), this.tracks[v] = { codec: w, container: C.container }, C.buffer = I;
                  } catch (M) {
                    p.b.error("error while trying to add sourceBuffer:" + M.message), this.hls.trigger(d.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.BUFFER_ADD_CODEC_ERROR, fatal: !1, err: M, mimeType: k });
                  }
                }
              this.hls.trigger(d.a.BUFFER_CREATED, { tracks: a });
            }, s.prototype.onBufferAppending = function(a) {
              this._needsFlush || (this.segments ? this.segments.push(a) : this.segments = [a], this.doAppending());
            }, s.prototype.onBufferAppendFail = function(a) {
              p.b.error("sourceBuffer error:", a.event), this.hls.trigger(d.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.BUFFER_APPENDING_ERROR, fatal: !1 });
            }, s.prototype.onBufferEos = function(a) {
              var l = this.sourceBuffer, f = a.type;
              for (var v in l)
                (!f || v === f) && (l[v].ended || (l[v].ended = !0, p.b.log(v + " sourceBuffer now EOS")));
              this.checkEos();
            }, s.prototype.checkEos = function() {
              var a = this.sourceBuffer, l = this.mediaSource;
              if (!l || l.readyState !== "open") {
                this._needsEos = !1;
                return;
              }
              for (var f in a) {
                var v = a[f];
                if (!v.ended)
                  return;
                if (v.updating) {
                  this._needsEos = !0;
                  return;
                }
              }
              p.b.log("all media data available, signal endOfStream() to MediaSource and stop loading fragment");
              try {
                l.endOfStream();
              } catch {
                p.b.warn("exception while calling mediaSource.endOfStream()");
              }
              this._needsEos = !1;
            }, s.prototype.onBufferFlushing = function(a) {
              this.flushRange.push({ start: a.startOffset, end: a.endOffset, type: a.type }), this.flushBufferCounter = 0, this.doFlush();
            }, s.prototype.onLevelUpdated = function(a) {
              var l = a.details;
              l.fragments.length > 0 && (this._levelDuration = l.totalduration + l.fragments[0].start, this._live = l.live, this.updateMediaElementDuration());
            }, s.prototype.updateMediaElementDuration = function() {
              var a = this.hls.config, l = void 0;
              if (!(this._levelDuration === null || !this.media || !this.mediaSource || !this.sourceBuffer || this.media.readyState === 0 || this.mediaSource.readyState !== "open")) {
                for (var f in this.sourceBuffer)
                  if (this.sourceBuffer[f].updating === !0)
                    return;
                l = this.media.duration, this._msDuration === null && (this._msDuration = this.mediaSource.duration), this._live === !0 && a.liveDurationInfinity === !0 ? (p.b.log("Media Source duration is set to Infinity"), this._msDuration = this.mediaSource.duration = 1 / 0) : (this._levelDuration > this._msDuration && this._levelDuration > l || l === 1 / 0 || isNaN(l)) && (p.b.log("Updating Media Source duration to " + this._levelDuration.toFixed(3)), this._msDuration = this.mediaSource.duration = this._levelDuration);
              }
            }, s.prototype.doFlush = function() {
              for (; this.flushRange.length; ) {
                var a = this.flushRange[0];
                if (this.flushBuffer(a.start, a.end, a.type))
                  this.flushRange.shift(), this.flushBufferCounter = 0;
                else {
                  this._needsFlush = !0;
                  return;
                }
              }
              if (this.flushRange.length === 0) {
                this._needsFlush = !1;
                var l = 0, f = this.sourceBuffer;
                try {
                  for (var v in f)
                    l += f[v].buffered.length;
                } catch {
                  p.b.error("error while accessing sourceBuffer.buffered");
                }
                this.appended = l, this.hls.trigger(d.a.BUFFER_FLUSHED);
              }
            }, s.prototype.doAppending = function() {
              var a = this.hls, l = this.sourceBuffer, f = this.segments;
              if (Object.keys(l).length) {
                if (this.media.error) {
                  this.segments = [], p.b.error("trying to append although a media error occured, flush segment and abort");
                  return;
                }
                if (this.appending)
                  return;
                if (f && f.length) {
                  var v = f.shift();
                  try {
                    var C = v.type, w = l[C];
                    w ? w.updating ? f.unshift(v) : (w.ended = !1, this.parent = v.parent, w.appendBuffer(v.data), this.appendError = 0, this.appended++, this.appending = !0) : this.onSBUpdateEnd();
                  } catch (I) {
                    p.b.error("error while trying to append buffer:" + I.message), f.unshift(v);
                    var k = { type: m.b.MEDIA_ERROR, parent: v.parent };
                    if (I.code !== 22)
                      if (this.appendError ? this.appendError++ : this.appendError = 1, k.details = m.a.BUFFER_APPEND_ERROR, this.appendError > a.config.appendErrorMaxRetry) {
                        p.b.log("fail " + a.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), f = [], k.fatal = !0, a.trigger(d.a.ERROR, k);
                        return;
                      } else
                        k.fatal = !1, a.trigger(d.a.ERROR, k);
                    else {
                      this.segments = [], k.details = m.a.BUFFER_FULL_ERROR, k.fatal = !1, a.trigger(d.a.ERROR, k);
                      return;
                    }
                  }
                }
              }
            }, s.prototype.flushBuffer = function(a, l, f) {
              var v, C, w, k, I, M, $ = this.sourceBuffer;
              if (Object.keys($).length) {
                if (p.b.log("flushBuffer,pos/start/end: " + this.media.currentTime.toFixed(3) + "/" + a + "/" + l), this.flushBufferCounter < this.appended) {
                  for (var H in $)
                    if (!(f && H !== f)) {
                      if (v = $[H], v.ended = !1, v.updating)
                        return p.b.warn("cannot flush, sb updating in progress"), !1;
                      try {
                        for (C = 0; C < v.buffered.length; C++)
                          if (w = v.buffered.start(C), k = v.buffered.end(C), navigator.userAgent.toLowerCase().indexOf("firefox") !== -1 && l === Number.POSITIVE_INFINITY ? (I = a, M = l) : (I = Math.max(w, a), M = Math.min(k, l)), Math.min(M, k) - I > 0.5)
                            return this.flushBufferCounter++, p.b.log("flush " + H + " [" + I + "," + M + "], of [" + w + "," + k + "], pos:" + this.media.currentTime), v.remove(I, M), !1;
                      } catch {
                        p.b.warn("exception while accessing sourcebuffer, it might have been removed from MediaSource");
                      }
                    }
                } else
                  p.b.warn("abort flushing too many retries");
                p.b.log("buffer flushed");
              }
              return !0;
            }, s;
          }(X), Fr = fn, Ma = /* @__PURE__ */ function() {
            function x(s, o) {
              for (var a = 0; a < o.length; a++) {
                var l = o[a];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, a) {
              return o && x(s.prototype, o), a && x(s, a), s;
            };
          }();
          function kn(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Na(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function na(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var O = function(x) {
            na(s, x);
            function s(o) {
              return kn(this, s), Na(this, x.call(this, o, d.a.FPS_DROP_LEVEL_CAPPING, d.a.MEDIA_ATTACHING, d.a.MANIFEST_PARSED));
            }
            return s.prototype.destroy = function() {
              this.hls.config.capLevelToPlayerSize && (this.media = this.restrictedLevels = null, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (this.timer = clearInterval(this.timer)));
            }, s.prototype.onFpsDropLevelCapping = function(a) {
              s.isLevelAllowed(a.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(a.droppedLevel);
            }, s.prototype.onMediaAttaching = function(a) {
              this.media = a.media instanceof HTMLVideoElement ? a.media : null;
            }, s.prototype.onManifestParsed = function(a) {
              var l = this.hls;
              this.restrictedLevels = [], l.config.capLevelToPlayerSize && (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.levels = a.levels, l.firstLevel = this.getMaxLevel(a.firstLevel), clearInterval(this.timer), this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
            }, s.prototype.detectPlayerSize = function() {
              if (this.media) {
                var a = this.levels ? this.levels.length : 0;
                if (a) {
                  var l = this.hls;
                  l.autoLevelCapping = this.getMaxLevel(a - 1), l.autoLevelCapping > this.autoLevelCapping && l.streamController.nextLevelSwitch(), this.autoLevelCapping = l.autoLevelCapping;
                }
              }
            }, s.prototype.getMaxLevel = function(a) {
              var l = this;
              if (!this.levels)
                return -1;
              var f = this.levels.filter(function(v, C) {
                return s.isLevelAllowed(C, l.restrictedLevels) && C <= a;
              });
              return s.getMaxLevelByMediaSize(f, this.mediaWidth, this.mediaHeight);
            }, s.isLevelAllowed = function(a) {
              var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
              return l.indexOf(a) === -1;
            }, s.getMaxLevelByMediaSize = function(a, l, f) {
              if (!a || a && !a.length)
                return -1;
              for (var v = function(M, $) {
                return $ ? M.width !== $.width || M.height !== $.height : !0;
              }, C = a.length - 1, w = 0; w < a.length; w += 1) {
                var k = a[w];
                if ((k.width >= l || k.height >= f) && v(k, a[w + 1])) {
                  C = w;
                  break;
                }
              }
              return C;
            }, Ma(s, [{
              key: "mediaWidth",
              get: function() {
                var a = void 0, l = this.media;
                return l && (a = l.width || l.clientWidth || l.offsetWidth, a *= s.contentScaleFactor), a;
              }
            }, {
              key: "mediaHeight",
              get: function() {
                var a = void 0, l = this.media;
                return l && (a = l.height || l.clientHeight || l.offsetHeight, a *= s.contentScaleFactor), a;
              }
            }], [{
              key: "contentScaleFactor",
              get: function() {
                var a = 1;
                try {
                  a = window.devicePixelRatio;
                } catch {
                }
                return a;
              }
            }]), s;
          }(X), c = O;
          function R(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function L(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function K(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var V = function(x) {
            K(s, x);
            function s(o) {
              return R(this, s), L(this, x.call(this, o, d.a.MEDIA_ATTACHING));
            }
            return s.prototype.destroy = function() {
              this.timer && clearInterval(this.timer), this.isVideoPlaybackQualityAvailable = !1;
            }, s.prototype.onMediaAttaching = function(a) {
              var l = this.hls.config;
              if (l.capLevelOnFPSDrop) {
                var f = this.video = a.media instanceof HTMLVideoElement ? a.media : null;
                typeof f.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), clearInterval(this.timer), this.timer = setInterval(this.checkFPSInterval.bind(this), l.fpsDroppedMonitoringPeriod);
              }
            }, s.prototype.checkFPS = function(a, l, f) {
              var v = performance.now();
              if (l) {
                if (this.lastTime) {
                  var C = v - this.lastTime, w = f - this.lastDroppedFrames, k = l - this.lastDecodedFrames, I = 1e3 * w / C, M = this.hls;
                  if (M.trigger(d.a.FPS_DROP, { currentDropped: w, currentDecoded: k, totalDroppedFrames: f }), I > 0 && w > M.config.fpsDroppedMonitoringThreshold * k) {
                    var $ = M.currentLevel;
                    p.b.warn("drop FPS ratio greater than max allowed value for currentLevel: " + $), $ > 0 && (M.autoLevelCapping === -1 || M.autoLevelCapping >= $) && ($ = $ - 1, M.trigger(d.a.FPS_DROP_LEVEL_CAPPING, { level: $, droppedLevel: M.currentLevel }), M.autoLevelCapping = $, M.streamController.nextLevelSwitch());
                  }
                }
                this.lastTime = v, this.lastDroppedFrames = f, this.lastDecodedFrames = l;
              }
            }, s.prototype.checkFPSInterval = function() {
              var a = this.video;
              if (a)
                if (this.isVideoPlaybackQualityAvailable) {
                  var l = a.getVideoPlaybackQuality();
                  this.checkFPS(a, l.totalVideoFrames, l.droppedVideoFrames);
                } else
                  this.checkFPS(a, a.webkitDecodedFrameCount, a.webkitDroppedFrameCount);
            }, s;
          }(X), ce = V;
          function se(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var _e = function() {
            function x(s) {
              se(this, x), s && s.xhrSetup && (this.xhrSetup = s.xhrSetup);
            }
            return x.prototype.destroy = function() {
              this.abort(), this.loader = null;
            }, x.prototype.abort = function() {
              var o = this.loader;
              o && o.readyState !== 4 && (this.stats.aborted = !0, o.abort()), window.clearTimeout(this.requestTimeout), this.requestTimeout = null, window.clearTimeout(this.retryTimeout), this.retryTimeout = null;
            }, x.prototype.load = function(o, a, l) {
              this.context = o, this.config = a, this.callbacks = l, this.stats = { trequest: performance.now(), retry: 0 }, this.retryDelay = a.retryDelay, this.loadInternal();
            }, x.prototype.loadInternal = function() {
              var o, a = this.context;
              o = this.loader = new XMLHttpRequest();
              var l = this.stats;
              l.tfirst = 0, l.loaded = 0;
              var f = this.xhrSetup;
              try {
                if (f)
                  try {
                    f(o, a.url);
                  } catch {
                    o.open("GET", a.url, !0), f(o, a.url);
                  }
                o.readyState || o.open("GET", a.url, !0);
              } catch (v) {
                this.callbacks.onError({ code: o.status, text: v.message }, a, o);
                return;
              }
              a.rangeEnd && o.setRequestHeader("Range", "bytes=" + a.rangeStart + "-" + (a.rangeEnd - 1)), o.onreadystatechange = this.readystatechange.bind(this), o.onprogress = this.loadprogress.bind(this), o.responseType = a.responseType, this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout), o.send();
            }, x.prototype.readystatechange = function(o) {
              var a = o.currentTarget, l = a.readyState, f = this.stats, v = this.context, C = this.config;
              if (!f.aborted && l >= 2)
                if (window.clearTimeout(this.requestTimeout), f.tfirst === 0 && (f.tfirst = Math.max(performance.now(), f.trequest)), l === 4) {
                  var w = a.status;
                  if (w >= 200 && w < 300) {
                    f.tload = Math.max(f.tfirst, performance.now());
                    var k = void 0, I = void 0;
                    v.responseType === "arraybuffer" ? (k = a.response, I = k.byteLength) : (k = a.responseText, I = k.length), f.loaded = f.total = I;
                    var M = { url: a.responseURL, data: k };
                    this.callbacks.onSuccess(M, f, v, a);
                  } else
                    f.retry >= C.maxRetry || w >= 400 && w < 499 ? (p.b.error(w + " while loading " + v.url), this.callbacks.onError({ code: w, text: a.statusText }, v, a)) : (p.b.warn(w + " while loading " + v.url + ", retrying in " + this.retryDelay + "..."), this.destroy(), this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, C.maxRetryDelay), f.retry++);
                } else
                  this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), C.timeout);
            }, x.prototype.loadtimeout = function() {
              p.b.warn("timeout while loading " + this.context.url), this.callbacks.onTimeout(this.stats, this.context, null);
            }, x.prototype.loadprogress = function(o) {
              var a = o.currentTarget, l = this.stats;
              l.loaded = o.loaded, o.lengthComputable && (l.total = o.total);
              var f = this.callbacks.onProgress;
              f && f(l, this.context, null, a);
            }, x;
          }(), we = _e, Oe = /* @__PURE__ */ function() {
            function x(s, o) {
              for (var a = 0; a < o.length; a++) {
                var l = o[a];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, a) {
              return o && x(s.prototype, o), a && x(s, a), s;
            };
          }();
          function wr(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function gl(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function Va(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var H0 = function(x) {
            Va(s, x);
            function s(o) {
              wr(this, s);
              var a = gl(this, x.call(this, o, d.a.MANIFEST_LOADING, d.a.MANIFEST_PARSED, d.a.AUDIO_TRACK_LOADED, d.a.ERROR));
              return a.ticks = 0, a.ontick = a.tick.bind(a), a;
            }
            return s.prototype.destroy = function() {
              this.cleanTimer(), X.prototype.destroy.call(this);
            }, s.prototype.cleanTimer = function() {
              this.timer && (clearTimeout(this.timer), this.timer = null);
            }, s.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, s.prototype.doTick = function() {
              this.updateTrack(this.trackId);
            }, s.prototype.onError = function(a) {
              a.fatal && a.type === m.b.NETWORK_ERROR && this.cleanTimer();
            }, s.prototype.onManifestLoading = function() {
              this.tracks = [], this.trackId = -1;
            }, s.prototype.onManifestParsed = function(a) {
              var l = this, f = a.audioTracks || [], v = !1;
              this.tracks = f, this.hls.trigger(d.a.AUDIO_TRACKS_UPDATED, { audioTracks: f });
              var C = 0;
              f.forEach(function(w) {
                if (w.default && !v) {
                  l.audioTrack = C, v = !0;
                  return;
                }
                C++;
              }), v === !1 && f.length && (p.b.log("no default audio track defined, use first audio track as default"), this.audioTrack = 0);
            }, s.prototype.onAudioTrackLoaded = function(a) {
              a.id < this.tracks.length && (p.b.log("audioTrack " + a.id + " loaded"), this.tracks[a.id].details = a.details, a.details.live && !this.timer && (this.timer = setInterval(this.ontick, 1e3 * a.details.targetduration)), !a.details.live && this.timer && this.cleanTimer());
            }, s.prototype.setAudioTrackInternal = function(a) {
              if (a >= 0 && a < this.tracks.length) {
                this.cleanTimer(), this.trackId = a, p.b.log("switching to audioTrack " + a);
                var l = this.tracks[a], f = this.hls, v = l.type, C = l.url, w = { id: a, type: v, url: C };
                f.trigger(d.a.AUDIO_TRACK_SWITCH, w), f.trigger(d.a.AUDIO_TRACK_SWITCHING, w);
                var k = l.details;
                C && (k === void 0 || k.live === !0) && (p.b.log("(re)loading playlist for audioTrack " + a), f.trigger(d.a.AUDIO_TRACK_LOADING, { url: C, id: a }));
              }
            }, s.prototype.updateTrack = function(a) {
              if (a >= 0 && a < this.tracks.length) {
                this.cleanTimer(), this.trackId = a, p.b.log("updating audioTrack " + a);
                var l = this.tracks[a], f = l.url, v = l.details;
                f && (v === void 0 || v.live === !0) && (p.b.log("(re)loading playlist for audioTrack " + a), this.hls.trigger(d.a.AUDIO_TRACK_LOADING, { url: f, id: a }));
              }
            }, Oe(s, [{
              key: "audioTracks",
              get: function() {
                return this.tracks;
              }
              /** get index of the selected audio track (index in audio track lists) **/
            }, {
              key: "audioTrack",
              get: function() {
                return this.trackId;
              },
              set: function(a) {
                (this.trackId !== a || this.tracks[a].details === void 0) && this.setAudioTrackInternal(a);
              }
            }]), s;
          }(X), Z0 = H0, W0 = /* @__PURE__ */ function() {
            function x(s, o) {
              for (var a = 0; a < o.length; a++) {
                var l = o[a];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, a) {
              return o && x(s.prototype, o), a && x(s, a), s;
            };
          }();
          function Y0(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function J0(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function Q0(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var Te = {
            STOPPED: "STOPPED",
            STARTING: "STARTING",
            IDLE: "IDLE",
            PAUSED: "PAUSED",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING",
            FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
            WAITING_TRACK: "WAITING_TRACK",
            PARSING: "PARSING",
            PARSED: "PARSED",
            BUFFER_FLUSHING: "BUFFER_FLUSHING",
            ENDED: "ENDED",
            ERROR: "ERROR",
            WAITING_INIT_PTS: "WAITING_INIT_PTS"
          }, em = function(x) {
            Q0(s, x);
            function s(o) {
              Y0(this, s);
              var a = J0(this, x.call(this, o, d.a.MEDIA_ATTACHED, d.a.MEDIA_DETACHING, d.a.AUDIO_TRACKS_UPDATED, d.a.AUDIO_TRACK_SWITCHING, d.a.AUDIO_TRACK_LOADED, d.a.KEY_LOADED, d.a.FRAG_LOADED, d.a.FRAG_PARSING_INIT_SEGMENT, d.a.FRAG_PARSING_DATA, d.a.FRAG_PARSED, d.a.ERROR, d.a.BUFFER_RESET, d.a.BUFFER_CREATED, d.a.BUFFER_APPENDED, d.a.BUFFER_FLUSHED, d.a.INIT_PTS_FOUND));
              return a.config = o.config, a.audioCodecSwap = !1, a.ticks = 0, a._state = Te.STOPPED, a.ontick = a.tick.bind(a), a.initPTS = [], a.waitingFragment = null, a.videoTrackCC = null, a;
            }
            return s.prototype.destroy = function() {
              this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), X.prototype.destroy.call(this), this.state = Te.STOPPED;
            }, s.prototype.onInitPtsFound = function(a) {
              var l = a.id, f = a.frag.cc, v = a.initPTS;
              l === "main" && (this.initPTS[f] = v, this.videoTrackCC = f, p.b.log("InitPTS for cc:" + f + " found from video track:" + v), this.state === Te.WAITING_INIT_PTS && this.tick());
            }, s.prototype.startLoad = function(a) {
              if (this.tracks) {
                var l = this.lastCurrentTime;
                this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.fragLoadError = 0, l > 0 && a === -1 ? (p.b.log("audio:override startPosition with lastCurrentTime @" + l.toFixed(3)), this.state = Te.IDLE) : (this.lastCurrentTime = this.startPosition ? this.startPosition : a, this.state = Te.STARTING), this.nextLoadPosition = this.startPosition = this.lastCurrentTime, this.tick();
              } else
                this.startPosition = a, this.state = Te.STOPPED;
            }, s.prototype.stopLoad = function() {
              var a = this.fragCurrent;
              a && (a.loader && a.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = Te.STOPPED;
            }, s.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, s.prototype.doTick = function() {
              var a, l, f, v = this.hls, C = v.config;
              switch (this.state) {
                case Te.ERROR:
                case Te.PAUSED:
                case Te.BUFFER_FLUSHING:
                  break;
                case Te.STARTING:
                  this.state = Te.WAITING_TRACK, this.loadedmetadata = !1;
                  break;
                case Te.IDLE:
                  var w = this.tracks;
                  if (!w || !this.media && (this.startFragRequested || !C.startFragPrefetch))
                    break;
                  if (this.loadedmetadata)
                    a = this.media.currentTime;
                  else if (a = this.nextLoadPosition, a === void 0)
                    break;
                  var k = this.mediaBuffer ? this.mediaBuffer : this.media, I = this.videoBuffer ? this.videoBuffer : this.media, M = Ye.bufferInfo(k, a, C.maxBufferHole), $ = Ye.bufferInfo(I, a, C.maxBufferHole), H = M.len, le = M.end, ge = this.fragPrevious, Re = Math.max(C.maxBufferLength, $.len), ve = this.audioSwitch, Pe = this.trackId;
                  if ((H < Re || ve) && Pe < w.length) {
                    if (f = w[Pe].details, typeof f > "u") {
                      this.state = Te.WAITING_TRACK;
                      break;
                    }
                    if (!ve && !f.live && ge && ge.sn === f.endSN && !M.nextStart && (!this.media.seeking || this.media.duration - le < ge.duration / 2)) {
                      this.hls.trigger(d.a.BUFFER_EOS, { type: "audio" }), this.state = Te.ENDED;
                      break;
                    }
                    var Be = f.fragments, Ne = Be.length, et = Be[0].start, _t = Be[Ne - 1].start + Be[Ne - 1].duration, Ce = void 0;
                    if (ve) {
                      if (f.live && !f.PTSKnown)
                        p.b.log("switching audiotrack, live stream, unknown PTS,load first fragment"), le = 0;
                      else if (le = a, f.PTSKnown && a < et)
                        if (M.end > et || M.nextStart)
                          p.b.log("alt audio track ahead of main track, seek to start of alt audio track"), this.media.currentTime = et + 0.05;
                        else
                          return;
                    }
                    if (f.initSegment && !f.initSegment.data)
                      Ce = f.initSegment;
                    else if (le <= et) {
                      if (Ce = Be[0], this.videoTrackCC !== null && Ce.cc !== this.videoTrackCC && (Ce = G(Be, this.videoTrackCC)), f.live && Ce.loadIdx && Ce.loadIdx === this.fragLoadIdx) {
                        var zt = M.nextStart ? M.nextStart : et;
                        p.b.log("no alt audio available @currentTime:" + this.media.currentTime + ", seeking @" + (zt + 0.05)), this.media.currentTime = zt + 0.05;
                        return;
                      }
                    } else {
                      var bt = void 0, pn = C.maxFragLookUpTolerance, Qe = ge ? Be[ge.sn - Be[0].sn + 1] : void 0, $e = function(ja) {
                        var Bc = Math.min(pn, ja.duration);
                        return ja.start + ja.duration - Bc <= le ? 1 : ja.start - Bc > le && ja.start ? -1 : 0;
                      };
                      le < _t ? (le > _t - pn && (pn = 0), Qe && !$e(Qe) ? bt = Qe : bt = Ze.search(Be, $e)) : bt = Be[Ne - 1], bt && (Ce = bt, et = bt.start, ge && Ce.level === ge.level && Ce.sn === ge.sn && (Ce.sn < f.endSN ? (Ce = Be[Ce.sn + 1 - f.startSN], p.b.log("SN just loaded, load next one: " + Ce.sn)) : Ce = null));
                    }
                    if (Ce)
                      if (Ce.decryptdata && Ce.decryptdata.uri != null && Ce.decryptdata.key == null)
                        p.b.log("Loading key for " + Ce.sn + " of [" + f.startSN + " ," + f.endSN + "],track " + Pe), this.state = Te.KEY_LOADING, v.trigger(d.a.KEY_LOADING, { frag: Ce });
                      else {
                        if (p.b.log("Loading " + Ce.sn + ", cc: " + Ce.cc + " of [" + f.startSN + " ," + f.endSN + "],track " + Pe + ", currentTime:" + a + ",bufferEnd:" + le.toFixed(3)), this.fragLoadIdx !== void 0 ? this.fragLoadIdx++ : this.fragLoadIdx = 0, Ce.loadCounter) {
                          Ce.loadCounter++;
                          var nr = C.fragLoadingLoopThreshold;
                          if (Ce.loadCounter > nr && Math.abs(this.fragLoadIdx - Ce.loadIdx) < nr) {
                            v.trigger(d.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.FRAG_LOOP_LOADING_ERROR, fatal: !1, frag: Ce });
                            return;
                          }
                        } else
                          Ce.loadCounter = 1;
                        Ce.loadIdx = this.fragLoadIdx, this.fragCurrent = Ce, this.startFragRequested = !0, isNaN(Ce.sn) || (this.nextLoadPosition = Ce.start + Ce.duration), v.trigger(d.a.FRAG_LOADING, { frag: Ce }), this.state = Te.FRAG_LOADING;
                      }
                  }
                  break;
                case Te.WAITING_TRACK:
                  l = this.tracks[this.trackId], l && l.details && (this.state = Te.IDLE);
                  break;
                case Te.FRAG_LOADING_WAITING_RETRY:
                  var vl = performance.now(), kc = this.retryDate;
                  k = this.media;
                  var $m = k && k.seeking;
                  (!kc || vl >= kc || $m) && (p.b.log("audioStreamController: retryDate reached, switch back to IDLE state"), this.state = Te.IDLE);
                  break;
                case Te.WAITING_INIT_PTS:
                  var xu = this.videoTrackCC;
                  if (this.initPTS[xu] === void 0)
                    break;
                  var Dc = this.waitingFragment;
                  if (Dc) {
                    var Pc = Dc.frag.cc;
                    xu !== Pc ? (l = this.tracks[this.trackId], l.details && l.details.live && (p.b.warn("Waiting fragment CC (" + Pc + ") does not match video track CC (" + xu + ")"), this.waitingFragment = null, this.state = Te.IDLE)) : (this.state = Te.FRAG_LOADING, this.onFragLoaded(this.waitingFragment), this.waitingFragment = null);
                  } else
                    this.state = Te.IDLE;
                  break;
              }
            }, s.prototype.onMediaAttached = function(a) {
              var l = this.media = this.mediaBuffer = a.media;
              this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), l.addEventListener("seeking", this.onvseeking), l.addEventListener("ended", this.onvended);
              var f = this.config;
              this.tracks && f.autoStartLoad && this.startLoad(f.startPosition);
            }, s.prototype.onMediaDetaching = function() {
              var a = this.media;
              a && a.ended && (p.b.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
              var l = this.tracks;
              l && l.forEach(function(f) {
                f.details && f.details.fragments.forEach(function(v) {
                  v.loadCounter = void 0;
                });
              }), a && (a.removeEventListener("seeking", this.onvseeking), a.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1, this.stopLoad();
            }, s.prototype.onMediaSeeking = function() {
              this.state === Te.ENDED && (this.state = Te.IDLE), this.media && (this.lastCurrentTime = this.media.currentTime), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.tick();
            }, s.prototype.onMediaEnded = function() {
              this.startPosition = this.lastCurrentTime = 0;
            }, s.prototype.onAudioTracksUpdated = function(a) {
              p.b.log("audio tracks updated"), this.tracks = a.audioTracks;
            }, s.prototype.onAudioTrackSwitching = function(a) {
              var l = !!a.url;
              this.trackId = a.id, this.fragCurrent = null, this.state = Te.PAUSED, this.waitingFragment = null, l ? this.timer || (this.timer = setInterval(this.ontick, 100)) : this.demuxer && (this.demuxer.destroy(), this.demuxer = null), l && (this.audioSwitch = !0, this.state = Te.IDLE, this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold)), this.tick();
            }, s.prototype.onAudioTrackLoaded = function(a) {
              var l = a.details, f = a.id, v = this.tracks[f], C = l.totalduration, w = 0;
              if (p.b.log("track " + f + " loaded [" + l.startSN + "," + l.endSN + "],duration:" + C), l.live) {
                var k = v.details;
                k && l.fragments.length > 0 ? (D(k, l), w = l.fragments[0].start, l.PTSKnown ? p.b.log("live audio playlist sliding:" + w.toFixed(3)) : p.b.log("live audio playlist - outdated PTS, unknown sliding")) : (l.PTSKnown = !1, p.b.log("live audio playlist - first load, unknown sliding"));
              } else
                l.PTSKnown = !1;
              if (v.details = l, !this.startFragRequested) {
                if (this.startPosition === -1) {
                  var I = l.startTimeOffset;
                  isNaN(I) ? this.startPosition = 0 : (p.b.log("start time offset found in playlist, adjust startPosition to " + I), this.startPosition = I);
                }
                this.nextLoadPosition = this.startPosition;
              }
              this.state === Te.WAITING_TRACK && (this.state = Te.IDLE), this.tick();
            }, s.prototype.onKeyLoaded = function() {
              this.state === Te.KEY_LOADING && (this.state = Te.IDLE, this.tick());
            }, s.prototype.onFragLoaded = function(a) {
              var l = this.fragCurrent, f = a.frag;
              if (this.state === Te.FRAG_LOADING && l && f.type === "audio" && f.level === l.level && f.sn === l.sn) {
                var v = this.tracks[this.trackId], C = v.details, w = C.totalduration, k = l.level, I = l.sn, M = l.cc, $ = this.config.defaultAudioCodec || v.audioCodec || "mp4a.40.2", H = this.stats = a.stats;
                if (I === "initSegment")
                  this.state = Te.IDLE, H.tparsed = H.tbuffered = performance.now(), C.initSegment.data = a.payload, this.hls.trigger(d.a.FRAG_BUFFERED, { stats: H, frag: l, id: "audio" }), this.tick();
                else {
                  this.state = Te.PARSING, this.appended = !1, this.demuxer || (this.demuxer = new j(this.hls, "audio"));
                  var le = this.initPTS[M], ge = C.initSegment ? C.initSegment.data : [];
                  if (C.initSegment || le !== void 0) {
                    this.pendingBuffering = !0, p.b.log("Demuxing " + I + " of [" + C.startSN + " ," + C.endSN + "],track " + k);
                    var Re = !1;
                    this.demuxer.push(a.payload, ge, $, null, l, w, Re, le);
                  } else
                    p.b.log("unknown video PTS for continuity counter " + M + ", waiting for video PTS before demuxing audio frag " + I + " of [" + C.startSN + " ," + C.endSN + "],track " + k), this.waitingFragment = a, this.state = Te.WAITING_INIT_PTS;
                }
              }
              this.fragLoadError = 0;
            }, s.prototype.onFragParsingInitSegment = function(a) {
              var l = this.fragCurrent, f = a.frag;
              if (l && a.id === "audio" && f.sn === l.sn && f.level === l.level && this.state === Te.PARSING) {
                var v = a.tracks, C = void 0;
                if (v.video && delete v.video, C = v.audio, C) {
                  C.levelCodec = C.codec, C.id = a.id, this.hls.trigger(d.a.BUFFER_CODECS, v), p.b.log("audio track:audio,container:" + C.container + ",codecs[level/parsed]=[" + C.levelCodec + "/" + C.codec + "]");
                  var w = C.initSegment;
                  if (w) {
                    var k = { type: "audio", data: w, parent: "audio", content: "initSegment" };
                    this.audioSwitch ? this.pendingData = [k] : (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(d.a.BUFFER_APPENDING, k));
                  }
                  this.tick();
                }
              }
            }, s.prototype.onFragParsingData = function(a) {
              var l = this, f = this.fragCurrent, v = a.frag;
              if (f && a.id === "audio" && a.type === "audio" && v.sn === f.sn && v.level === f.level && this.state === Te.PARSING) {
                var C = this.trackId, w = this.tracks[C], k = this.hls;
                isNaN(a.endPTS) && (a.endPTS = a.startPTS + f.duration, a.endDTS = a.startDTS + f.duration), p.b.log("parsed " + a.type + ",PTS:[" + a.startPTS.toFixed(3) + "," + a.endPTS.toFixed(3) + "],DTS:[" + a.startDTS.toFixed(3) + "/" + a.endDTS.toFixed(3) + "],nb:" + a.nb), T(w.details, f, a.startPTS, a.endPTS);
                var I = this.audioSwitch, M = this.media, $ = !1;
                if (I && M)
                  if (M.readyState) {
                    var H = M.currentTime;
                    p.b.log("switching audio track : currentTime:" + H), H >= a.startPTS && (p.b.log("switching audio track : flushing all audio"), this.state = Te.BUFFER_FLUSHING, k.trigger(d.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), $ = !0, this.audioSwitch = !1, k.trigger(d.a.AUDIO_TRACK_SWITCHED, { id: C }));
                  } else
                    this.audioSwitch = !1, k.trigger(d.a.AUDIO_TRACK_SWITCHED, { id: C });
                var le = this.pendingData;
                this.audioSwitch || ([a.data1, a.data2].forEach(function(ge) {
                  ge && ge.length && le.push({ type: a.type, data: ge, parent: "audio", content: "data" });
                }), !$ && le.length && (le.forEach(function(ge) {
                  l.state === Te.PARSING && (l.pendingBuffering = !0, l.hls.trigger(d.a.BUFFER_APPENDING, ge));
                }), this.pendingData = [], this.appended = !0)), this.tick();
              }
            }, s.prototype.onFragParsed = function(a) {
              var l = this.fragCurrent, f = a.frag;
              l && a.id === "audio" && f.sn === l.sn && f.level === l.level && this.state === Te.PARSING && (this.stats.tparsed = performance.now(), this.state = Te.PARSED, this._checkAppendedParsed());
            }, s.prototype.onBufferReset = function() {
              this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1;
            }, s.prototype.onBufferCreated = function(a) {
              var l = a.tracks.audio;
              l && (this.mediaBuffer = l.buffer, this.loadedmetadata = !0), a.tracks.video && (this.videoBuffer = a.tracks.video.buffer);
            }, s.prototype.onBufferAppended = function(a) {
              if (a.parent === "audio") {
                var l = this.state;
                (l === Te.PARSING || l === Te.PARSED) && (this.pendingBuffering = a.pending > 0, this._checkAppendedParsed());
              }
            }, s.prototype._checkAppendedParsed = function() {
              if (this.state === Te.PARSED && (!this.appended || !this.pendingBuffering)) {
                var a = this.fragCurrent, l = this.stats, f = this.hls;
                if (a) {
                  this.fragPrevious = a, l.tbuffered = performance.now(), f.trigger(d.a.FRAG_BUFFERED, { stats: l, frag: a, id: "audio" });
                  var v = this.mediaBuffer ? this.mediaBuffer : this.media;
                  p.b.log("audio buffered : " + U.toString(v.buffered)), this.audioSwitch && this.appended && (this.audioSwitch = !1, f.trigger(d.a.AUDIO_TRACK_SWITCHED, { id: this.trackId })), this.state = Te.IDLE;
                }
                this.tick();
              }
            }, s.prototype.onError = function(a) {
              var l = a.frag;
              if (!(l && l.type !== "audio"))
                switch (a.details) {
                  case m.a.FRAG_LOAD_ERROR:
                  case m.a.FRAG_LOAD_TIMEOUT:
                    if (!a.fatal) {
                      var f = this.fragLoadError;
                      f ? f++ : f = 1;
                      var v = this.config;
                      if (f <= v.fragLoadingMaxRetry) {
                        this.fragLoadError = f, l.loadCounter = 0;
                        var C = Math.min(Math.pow(2, f - 1) * v.fragLoadingRetryDelay, v.fragLoadingMaxRetryTimeout);
                        p.b.warn("audioStreamController: frag loading failed, retry in " + C + " ms"), this.retryDate = performance.now() + C, this.state = Te.FRAG_LOADING_WAITING_RETRY;
                      } else
                        p.b.error("audioStreamController: " + a.details + " reaches max retry, redispatch as fatal ..."), a.fatal = !0, this.state = Te.ERROR;
                    }
                    break;
                  case m.a.FRAG_LOOP_LOADING_ERROR:
                  case m.a.AUDIO_TRACK_LOAD_ERROR:
                  case m.a.AUDIO_TRACK_LOAD_TIMEOUT:
                  case m.a.KEY_LOAD_ERROR:
                  case m.a.KEY_LOAD_TIMEOUT:
                    this.state !== Te.ERROR && (this.state = a.fatal ? Te.ERROR : Te.IDLE, p.b.warn("audioStreamController: " + a.details + " while loading frag,switch to " + this.state + " state ..."));
                    break;
                  case m.a.BUFFER_FULL_ERROR:
                    if (a.parent === "audio" && (this.state === Te.PARSING || this.state === Te.PARSED)) {
                      var w = this.mediaBuffer, k = this.media.currentTime, I = w && Ye.isBuffered(w, k) && Ye.isBuffered(w, k + 0.5);
                      if (I) {
                        var M = this.config;
                        M.maxMaxBufferLength >= M.maxBufferLength && (M.maxMaxBufferLength /= 2, p.b.warn("audio:reduce max buffer length to " + M.maxMaxBufferLength + "s"), this.fragLoadIdx += 2 * M.fragLoadingLoopThreshold), this.state = Te.IDLE;
                      } else
                        p.b.warn("buffer full error also media.currentTime is not buffered, flush audio buffer"), this.fragCurrent = null, this.state = Te.BUFFER_FLUSHING, this.hls.trigger(d.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" });
                    }
                    break;
                }
            }, s.prototype.onBufferFlushed = function() {
              var a = this, l = this.pendingData;
              l && l.length ? (p.b.log("appending pending audio data on Buffer Flushed"), l.forEach(function(f) {
                a.hls.trigger(d.a.BUFFER_APPENDING, f);
              }), this.appended = !0, this.pendingData = [], this.state = Te.PARSED) : (this.state = Te.IDLE, this.fragPrevious = null, this.tick());
            }, W0(s, [{
              key: "state",
              set: function(a) {
                if (this.state !== a) {
                  var l = this.state;
                  this._state = a, p.b.log("audio stream:" + l + "->" + a);
                }
              },
              get: function() {
                return this._state;
              }
            }]), s;
          }(X), tm = em, gc = function() {
            if (typeof window < "u" && window.VTTCue)
              return window.VTTCue;
            var x = "auto", s = {
              "": !0,
              lr: !0,
              rl: !0
            }, o = {
              start: !0,
              middle: !0,
              end: !0,
              left: !0,
              right: !0
            };
            function a(C) {
              if (typeof C != "string")
                return !1;
              var w = s[C.toLowerCase()];
              return w ? C.toLowerCase() : !1;
            }
            function l(C) {
              if (typeof C != "string")
                return !1;
              var w = o[C.toLowerCase()];
              return w ? C.toLowerCase() : !1;
            }
            function f(C) {
              for (var w = 1; w < arguments.length; w++) {
                var k = arguments[w];
                for (var I in k)
                  C[I] = k[I];
              }
              return C;
            }
            function v(C, w, k) {
              var I = this, M = function() {
                if (!(typeof navigator > "u"))
                  return /MSIE\s8\.0/.test(navigator.userAgent);
              }(), $ = {};
              M ? I = document.createElement("custom") : $.enumerable = !0, I.hasBeenReset = !1;
              var H = "", le = !1, ge = C, Re = w, ve = k, Pe = null, Be = "", Ne = !0, et = "auto", _t = "start", Ce = 50, zt = "middle", bt = 50, pn = "middle";
              if (Object.defineProperty(I, "id", f({}, $, {
                get: function() {
                  return H;
                },
                set: function($e) {
                  H = "" + $e;
                }
              })), Object.defineProperty(I, "pauseOnExit", f({}, $, {
                get: function() {
                  return le;
                },
                set: function($e) {
                  le = !!$e;
                }
              })), Object.defineProperty(I, "startTime", f({}, $, {
                get: function() {
                  return ge;
                },
                set: function($e) {
                  if (typeof $e != "number")
                    throw new TypeError("Start time must be set to a number.");
                  ge = $e, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "endTime", f({}, $, {
                get: function() {
                  return Re;
                },
                set: function($e) {
                  if (typeof $e != "number")
                    throw new TypeError("End time must be set to a number.");
                  Re = $e, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "text", f({}, $, {
                get: function() {
                  return ve;
                },
                set: function($e) {
                  ve = "" + $e, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "region", f({}, $, {
                get: function() {
                  return Pe;
                },
                set: function($e) {
                  Pe = $e, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "vertical", f({}, $, {
                get: function() {
                  return Be;
                },
                set: function($e) {
                  var nr = a($e);
                  if (nr === !1)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  Be = nr, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "snapToLines", f({}, $, {
                get: function() {
                  return Ne;
                },
                set: function($e) {
                  Ne = !!$e, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "line", f({}, $, {
                get: function() {
                  return et;
                },
                set: function($e) {
                  if (typeof $e != "number" && $e !== x)
                    throw new SyntaxError("An invalid number or illegal string was specified.");
                  et = $e, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "lineAlign", f({}, $, {
                get: function() {
                  return _t;
                },
                set: function($e) {
                  var nr = l($e);
                  if (!nr)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  _t = nr, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "position", f({}, $, {
                get: function() {
                  return Ce;
                },
                set: function($e) {
                  if ($e < 0 || $e > 100)
                    throw new Error("Position must be between 0 and 100.");
                  Ce = $e, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "positionAlign", f({}, $, {
                get: function() {
                  return zt;
                },
                set: function($e) {
                  var nr = l($e);
                  if (!nr)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  zt = nr, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "size", f({}, $, {
                get: function() {
                  return bt;
                },
                set: function($e) {
                  if ($e < 0 || $e > 100)
                    throw new Error("Size must be between 0 and 100.");
                  bt = $e, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(I, "align", f({}, $, {
                get: function() {
                  return pn;
                },
                set: function($e) {
                  var nr = l($e);
                  if (!nr)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  pn = nr, this.hasBeenReset = !0;
                }
              })), I.displayState = void 0, M)
                return I;
            }
            return v.prototype.getCueAsHTML = function() {
              var C = window.WebVTT;
              return C.convertCueToDOMTree(window, this.text);
            }, v;
          }(), rm = function() {
            return {
              decode: function(o) {
                if (!o)
                  return "";
                if (typeof o != "string")
                  throw new Error("Error - expected string data.");
                return decodeURIComponent(encodeURIComponent(o));
              }
            };
          };
          function xc() {
            this.window = window, this.state = "INITIAL", this.buffer = "", this.decoder = new rm(), this.regionList = [];
          }
          function im(x) {
            function s(a, l, f, v) {
              return (a | 0) * 3600 + (l | 0) * 60 + (f | 0) + (v | 0) / 1e3;
            }
            var o = x.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
            return o ? o[3] ? s(o[1], o[2], o[3].replace(":", ""), o[4]) : o[1] > 59 ? s(o[1], o[2], 0, o[4]) : s(0, o[1], o[2], o[4]) : null;
          }
          function Ec() {
            this.values = /* @__PURE__ */ Object.create(null);
          }
          Ec.prototype = {
            // Only accept the first assignment to any key.
            set: function(s, o) {
              !this.get(s) && o !== "" && (this.values[s] = o);
            },
            // Return the value for a key, or a default value.
            // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
            // a number of possible default values as properties where 'defaultKey' is
            // the key of the property that will be chosen; otherwise it's assumed to be
            // a single value.
            get: function(s, o, a) {
              return a ? this.has(s) ? this.values[s] : o[a] : this.has(s) ? this.values[s] : o;
            },
            // Check whether we have a value for a key.
            has: function(s) {
              return s in this.values;
            },
            // Accept a setting if its one of the given alternatives.
            alt: function(s, o, a) {
              for (var l = 0; l < a.length; ++l)
                if (o === a[l]) {
                  this.set(s, o);
                  break;
                }
            },
            // Accept a setting if its a valid (signed) integer.
            integer: function(s, o) {
              /^-?\d+$/.test(o) && this.set(s, parseInt(o, 10));
            },
            // Accept a setting if its a valid percentage.
            percent: function(s, o) {
              return o.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (o = parseFloat(o), o >= 0 && o <= 100) ? (this.set(s, o), !0) : !1;
            }
          };
          function vc(x, s, o, a) {
            var l = a ? x.split(a) : [x];
            for (var f in l)
              if (typeof l[f] == "string") {
                var v = l[f].split(o);
                if (v.length === 2) {
                  var C = v[0], w = v[1];
                  s(C, w);
                }
              }
          }
          var mu = new gc(0, 0, 0), xl = mu.align === "middle" ? "middle" : "center";
          function nm(x, s, o) {
            var a = x;
            function l() {
              var C = im(x);
              if (C === null)
                throw new Error("Malformed timestamp: " + a);
              return x = x.replace(/^[^\sa-zA-Z-]+/, ""), C;
            }
            function f(C, w) {
              var k = new Ec();
              vc(C, function($, H) {
                switch ($) {
                  case "region":
                    for (var le = o.length - 1; le >= 0; le--)
                      if (o[le].id === H) {
                        k.set($, o[le].region);
                        break;
                      }
                    break;
                  case "vertical":
                    k.alt($, H, ["rl", "lr"]);
                    break;
                  case "line":
                    var ge = H.split(","), Re = ge[0];
                    k.integer($, Re), k.percent($, Re) && k.set("snapToLines", !1), k.alt($, Re, ["auto"]), ge.length === 2 && k.alt("lineAlign", ge[1], ["start", xl, "end"]);
                    break;
                  case "position":
                    ge = H.split(","), k.percent($, ge[0]), ge.length === 2 && k.alt("positionAlign", ge[1], ["start", xl, "end", "line-left", "line-right", "auto"]);
                    break;
                  case "size":
                    k.percent($, H);
                    break;
                  case "align":
                    k.alt($, H, ["start", xl, "end", "left", "right"]);
                    break;
                }
              }, /:/, /\s/), w.region = k.get("region", null), w.vertical = k.get("vertical", "");
              var I = k.get("line", "auto");
              I === "auto" && mu.line === -1 && (I = -1), w.line = I, w.lineAlign = k.get("lineAlign", "start"), w.snapToLines = k.get("snapToLines", !0), w.size = k.get("size", 100), w.align = k.get("align", xl);
              var M = k.get("position", "auto");
              M === "auto" && mu.position === 50 && (M = w.align === "start" || w.align === "left" ? 0 : w.align === "end" || w.align === "right" ? 100 : 50), w.position = M;
            }
            function v() {
              x = x.replace(/^\s+/, "");
            }
            if (v(), s.startTime = l(), v(), x.substr(0, 3) !== "-->")
              throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + a);
            x = x.substr(3), v(), s.endTime = l(), v(), f(x, s);
          }
          function Rc(x) {
            return x.replace(/<br(?: \/)?>/gi, `
`);
          }
          xc.prototype = {
            parse: function(s) {
              var o = this;
              s && (o.buffer += o.decoder.decode(s, { stream: !0 }));
              function a() {
                var k = o.buffer, I = 0;
                for (k = Rc(k); I < k.length && k[I] !== "\r" && k[I] !== `
`; )
                  ++I;
                var M = k.substr(0, I);
                return k[I] === "\r" && ++I, k[I] === `
` && ++I, o.buffer = k.substr(I), M;
              }
              function l(k) {
                vc(k, function(I, M) {
                  switch (I) {
                    case "Region":
                      console.log("parse region", M);
                      break;
                  }
                }, /:/);
              }
              try {
                var f;
                if (o.state === "INITIAL") {
                  if (!/\r\n|\n/.test(o.buffer))
                    return this;
                  f = a();
                  var v = f.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
                  if (!v || !v[0])
                    throw new Error("Malformed WebVTT signature.");
                  o.state = "HEADER";
                }
                for (var C = !1; o.buffer; ) {
                  if (!/\r\n|\n/.test(o.buffer))
                    return this;
                  switch (C ? C = !1 : f = a(), o.state) {
                    case "HEADER":
                      /:/.test(f) ? l(f) : f || (o.state = "ID");
                      continue;
                    case "NOTE":
                      f || (o.state = "ID");
                      continue;
                    case "ID":
                      if (/^NOTE($|[ \t])/.test(f)) {
                        o.state = "NOTE";
                        break;
                      }
                      if (!f)
                        continue;
                      if (o.cue = new gc(0, 0, ""), o.state = "CUE", f.indexOf("-->") === -1) {
                        o.cue.id = f;
                        continue;
                      }
                    case "CUE":
                      try {
                        nm(f, o.cue, o.regionList);
                      } catch {
                        o.cue = null, o.state = "BADCUE";
                        continue;
                      }
                      o.state = "CUETEXT";
                      continue;
                    case "CUETEXT":
                      var w = f.indexOf("-->") !== -1;
                      if (!f || w && (C = !0)) {
                        o.oncue && o.oncue(o.cue), o.cue = null, o.state = "ID";
                        continue;
                      }
                      o.cue.text && (o.cue.text += `
`), o.cue.text += f;
                      continue;
                    case "BADCUE":
                      f || (o.state = "ID");
                      continue;
                  }
                }
              } catch {
                o.state === "CUETEXT" && o.cue && o.oncue && o.oncue(o.cue), o.cue = null, o.state = o.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
              }
              return this;
            },
            flush: function() {
              var s = this;
              try {
                if (s.buffer += s.decoder.decode(), (s.cue || s.state === "HEADER") && (s.buffer += `

`, s.parse()), s.state === "INITIAL")
                  throw new Error("Malformed WebVTT signature.");
              } catch (o) {
                throw o;
              }
              return s.onflush && s.onflush(), this;
            }
          };
          var am = xc;
          function sm(x, s, o, a) {
            for (var l, f, v, C, w, k = window.VTTCue || window.TextTrackCue, I = 0; I < a.rows.length; I++)
              if (l = a.rows[I], v = !0, C = 0, w = "", !l.isEmpty()) {
                for (var M = 0; M < l.chars.length; M++)
                  l.chars[M].uchar.match(/\s/) && v ? C++ : (w += l.chars[M].uchar, v = !1);
                l.cueStartTime = s, s === o && (o += 1e-4), f = new k(s, o, Rc(w.trim())), C >= 16 ? C-- : C++, navigator.userAgent.match(/Firefox\//) ? f.line = I + 1 : f.line = I > 7 ? I - 2 : I + 1, f.align = "left", f.position = Math.max(0, Math.min(100, 100 * (C / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0))), x.addCue(f);
              }
          }
          function aa(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ac = {
            42: 225,
            // lowercase a, acute accent
            92: 233,
            // lowercase e, acute accent
            94: 237,
            // lowercase i, acute accent
            95: 243,
            // lowercase o, acute accent
            96: 250,
            // lowercase u, acute accent
            123: 231,
            // lowercase c with cedilla
            124: 247,
            // division symbol
            125: 209,
            // uppercase N tilde
            126: 241,
            // lowercase n tilde
            127: 9608,
            // Full block
            // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
            // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
            128: 174,
            // Registered symbol (R)
            129: 176,
            // degree sign
            130: 189,
            // 1/2 symbol
            131: 191,
            // Inverted (open) question mark
            132: 8482,
            // Trademark symbol (TM)
            133: 162,
            // Cents symbol
            134: 163,
            // Pounds sterling
            135: 9834,
            // Music 8'th note
            136: 224,
            // lowercase a, grave accent
            137: 32,
            // transparent space (regular)
            138: 232,
            // lowercase e, grave accent
            139: 226,
            // lowercase a, circumflex accent
            140: 234,
            // lowercase e, circumflex accent
            141: 238,
            // lowercase i, circumflex accent
            142: 244,
            // lowercase o, circumflex accent
            143: 251,
            // lowercase u, circumflex accent
            // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
            144: 193,
            // capital letter A with acute
            145: 201,
            // capital letter E with acute
            146: 211,
            // capital letter O with acute
            147: 218,
            // capital letter U with acute
            148: 220,
            // capital letter U with diaresis
            149: 252,
            // lowercase letter U with diaeresis
            150: 8216,
            // opening single quote
            151: 161,
            // inverted exclamation mark
            152: 42,
            // asterisk
            153: 8217,
            // closing single quote
            154: 9473,
            // box drawings heavy horizontal
            155: 169,
            // copyright sign
            156: 8480,
            // Service mark
            157: 8226,
            // (round) bullet
            158: 8220,
            // Left double quotation mark
            159: 8221,
            // Right double quotation mark
            160: 192,
            // uppercase A, grave accent
            161: 194,
            // uppercase A, circumflex
            162: 199,
            // uppercase C with cedilla
            163: 200,
            // uppercase E, grave accent
            164: 202,
            // uppercase E, circumflex
            165: 203,
            // capital letter E with diaresis
            166: 235,
            // lowercase letter e with diaresis
            167: 206,
            // uppercase I, circumflex
            168: 207,
            // uppercase I, with diaresis
            169: 239,
            // lowercase i, with diaresis
            170: 212,
            // uppercase O, circumflex
            171: 217,
            // uppercase U, grave accent
            172: 249,
            // lowercase u, grave accent
            173: 219,
            // uppercase U, circumflex
            174: 171,
            // left-pointing double angle quotation mark
            175: 187,
            // right-pointing double angle quotation mark
            // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
            176: 195,
            // Uppercase A, tilde
            177: 227,
            // Lowercase a, tilde
            178: 205,
            // Uppercase I, acute accent
            179: 204,
            // Uppercase I, grave accent
            180: 236,
            // Lowercase i, grave accent
            181: 210,
            // Uppercase O, grave accent
            182: 242,
            // Lowercase o, grave accent
            183: 213,
            // Uppercase O, tilde
            184: 245,
            // Lowercase o, tilde
            185: 123,
            // Open curly brace
            186: 125,
            // Closing curly brace
            187: 92,
            // Backslash
            188: 94,
            // Caret
            189: 95,
            // Underscore
            190: 124,
            // Pipe (vertical line)
            191: 8764,
            // Tilde operator
            192: 196,
            // Uppercase A, umlaut
            193: 228,
            // Lowercase A, umlaut
            194: 214,
            // Uppercase O, umlaut
            195: 246,
            // Lowercase o, umlaut
            196: 223,
            // Esszett (sharp S)
            197: 165,
            // Yen symbol
            198: 164,
            // Generic currency sign
            199: 9475,
            // Box drawings heavy vertical
            200: 197,
            // Uppercase A, ring
            201: 229,
            // Lowercase A, ring
            202: 216,
            // Uppercase O, stroke
            203: 248,
            // Lowercase o, strok
            204: 9487,
            // Box drawings heavy down and right
            205: 9491,
            // Box drawings heavy down and left
            206: 9495,
            // Box drawings heavy up and right
            207: 9499
            // Box drawings heavy up and left
          }, _c = function(s) {
            var o = s;
            return Ac.hasOwnProperty(s) && (o = Ac[s]), String.fromCharCode(o);
          }, Qr = 15, Ni = 100, om = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, lm = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, um = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }, cm = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, dm = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"], Xe = {
            verboseFilter: { DATA: 3, DEBUG: 3, INFO: 2, WARNING: 2, TEXT: 1, ERROR: 0 },
            time: null,
            verboseLevel: 0,
            // Only write errors
            setTime: function(s) {
              this.time = s;
            },
            log: function(s, o) {
              var a = this.verboseFilter[s];
              this.verboseLevel >= a && console.log(this.time + " [" + s + "] " + o);
            }
          }, Dn = function(s) {
            for (var o = [], a = 0; a < s.length; a++)
              o.push(s[a].toString(16));
            return o;
          }, wc = function() {
            function x(s, o, a, l, f) {
              aa(this, x), this.foreground = s || "white", this.underline = o || !1, this.italics = a || !1, this.background = l || "black", this.flash = f || !1;
            }
            return x.prototype.reset = function() {
              this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
            }, x.prototype.setStyles = function(o) {
              for (var a = ["foreground", "underline", "italics", "background", "flash"], l = 0; l < a.length; l++) {
                var f = a[l];
                o.hasOwnProperty(f) && (this[f] = o[f]);
              }
            }, x.prototype.isDefault = function() {
              return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
            }, x.prototype.equals = function(o) {
              return this.foreground === o.foreground && this.underline === o.underline && this.italics === o.italics && this.background === o.background && this.flash === o.flash;
            }, x.prototype.copy = function(o) {
              this.foreground = o.foreground, this.underline = o.underline, this.italics = o.italics, this.background = o.background, this.flash = o.flash;
            }, x.prototype.toString = function() {
              return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
            }, x;
          }(), fm = function() {
            function x(s, o, a, l, f, v) {
              aa(this, x), this.uchar = s || " ", this.penState = new wc(o, a, l, f, v);
            }
            return x.prototype.reset = function() {
              this.uchar = " ", this.penState.reset();
            }, x.prototype.setChar = function(o, a) {
              this.uchar = o, this.penState.copy(a);
            }, x.prototype.setPenState = function(o) {
              this.penState.copy(o);
            }, x.prototype.equals = function(o) {
              return this.uchar === o.uchar && this.penState.equals(o.penState);
            }, x.prototype.copy = function(o) {
              this.uchar = o.uchar, this.penState.copy(o.penState);
            }, x.prototype.isEmpty = function() {
              return this.uchar === " " && this.penState.isDefault();
            }, x;
          }(), pm = function() {
            function x() {
              aa(this, x), this.chars = [];
              for (var s = 0; s < Ni; s++)
                this.chars.push(new fm());
              this.pos = 0, this.currPenState = new wc();
            }
            return x.prototype.equals = function(o) {
              for (var a = !0, l = 0; l < Ni; l++)
                if (!this.chars[l].equals(o.chars[l])) {
                  a = !1;
                  break;
                }
              return a;
            }, x.prototype.copy = function(o) {
              for (var a = 0; a < Ni; a++)
                this.chars[a].copy(o.chars[a]);
            }, x.prototype.isEmpty = function() {
              for (var o = !0, a = 0; a < Ni; a++)
                if (!this.chars[a].isEmpty()) {
                  o = !1;
                  break;
                }
              return o;
            }, x.prototype.setCursor = function(o) {
              this.pos !== o && (this.pos = o), this.pos < 0 ? (Xe.log("ERROR", "Negative cursor position " + this.pos), this.pos = 0) : this.pos > Ni && (Xe.log("ERROR", "Too large cursor position " + this.pos), this.pos = Ni);
            }, x.prototype.moveCursor = function(o) {
              var a = this.pos + o;
              if (o > 1)
                for (var l = this.pos + 1; l < a + 1; l++)
                  this.chars[l].setPenState(this.currPenState);
              this.setCursor(a);
            }, x.prototype.backSpace = function() {
              this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
            }, x.prototype.insertChar = function(o) {
              o >= 144 && this.backSpace();
              var a = _c(o);
              if (this.pos >= Ni) {
                Xe.log("ERROR", "Cannot insert " + o.toString(16) + " (" + a + ") at position " + this.pos + ". Skipping it!");
                return;
              }
              this.chars[this.pos].setChar(a, this.currPenState), this.moveCursor(1);
            }, x.prototype.clearFromPos = function(o) {
              var a;
              for (a = o; a < Ni; a++)
                this.chars[a].reset();
            }, x.prototype.clear = function() {
              this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
            }, x.prototype.clearToEndOfRow = function() {
              this.clearFromPos(this.pos);
            }, x.prototype.getTextString = function() {
              for (var o = [], a = !0, l = 0; l < Ni; l++) {
                var f = this.chars[l].uchar;
                f !== " " && (a = !1), o.push(f);
              }
              return a ? "" : o.join("");
            }, x.prototype.setPenStyles = function(o) {
              this.currPenState.setStyles(o);
              var a = this.chars[this.pos];
              a.setPenState(this.currPenState);
            }, x;
          }(), yu = function() {
            function x() {
              aa(this, x), this.rows = [];
              for (var s = 0; s < Qr; s++)
                this.rows.push(new pm());
              this.currRow = Qr - 1, this.nrRollUpRows = null, this.reset();
            }
            return x.prototype.reset = function() {
              for (var o = 0; o < Qr; o++)
                this.rows[o].clear();
              this.currRow = Qr - 1;
            }, x.prototype.equals = function(o) {
              for (var a = !0, l = 0; l < Qr; l++)
                if (!this.rows[l].equals(o.rows[l])) {
                  a = !1;
                  break;
                }
              return a;
            }, x.prototype.copy = function(o) {
              for (var a = 0; a < Qr; a++)
                this.rows[a].copy(o.rows[a]);
            }, x.prototype.isEmpty = function() {
              for (var o = !0, a = 0; a < Qr; a++)
                if (!this.rows[a].isEmpty()) {
                  o = !1;
                  break;
                }
              return o;
            }, x.prototype.backSpace = function() {
              var o = this.rows[this.currRow];
              o.backSpace();
            }, x.prototype.clearToEndOfRow = function() {
              var o = this.rows[this.currRow];
              o.clearToEndOfRow();
            }, x.prototype.insertChar = function(o) {
              var a = this.rows[this.currRow];
              a.insertChar(o);
            }, x.prototype.setPen = function(o) {
              var a = this.rows[this.currRow];
              a.setPenStyles(o);
            }, x.prototype.moveCursor = function(o) {
              var a = this.rows[this.currRow];
              a.moveCursor(o);
            }, x.prototype.setCursor = function(o) {
              Xe.log("INFO", "setCursor: " + o);
              var a = this.rows[this.currRow];
              a.setCursor(o);
            }, x.prototype.setPAC = function(o) {
              Xe.log("INFO", "pacData = " + JSON.stringify(o));
              var a = o.row - 1;
              if (this.nrRollUpRows && a < this.nrRollUpRows - 1 && (a = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== a) {
                for (var l = 0; l < Qr; l++)
                  this.rows[l].clear();
                var f = this.currRow + 1 - this.nrRollUpRows, v = this.lastOutputScreen;
                if (v) {
                  var C = v.rows[f].cueStartTime;
                  if (C && C < Xe.time)
                    for (var w = 0; w < this.nrRollUpRows; w++)
                      this.rows[a - this.nrRollUpRows + w + 1].copy(v.rows[f + w]);
                }
              }
              this.currRow = a;
              var k = this.rows[this.currRow];
              if (o.indent !== null) {
                var I = o.indent, M = Math.max(I - 1, 0);
                k.setCursor(o.indent), o.color = k.chars[M].penState.foreground;
              }
              var $ = { foreground: o.color, underline: o.underline, italics: o.italics, background: "black", flash: !1 };
              this.setPen($);
            }, x.prototype.setBkgData = function(o) {
              Xe.log("INFO", "bkgData = " + JSON.stringify(o)), this.backSpace(), this.setPen(o), this.insertChar(32);
            }, x.prototype.setRollUpRows = function(o) {
              this.nrRollUpRows = o;
            }, x.prototype.rollUp = function() {
              if (this.nrRollUpRows === null) {
                Xe.log("DEBUG", "roll_up but nrRollUpRows not set yet");
                return;
              }
              Xe.log("TEXT", this.getDisplayText());
              var o = this.currRow + 1 - this.nrRollUpRows, a = this.rows.splice(o, 1)[0];
              a.clear(), this.rows.splice(this.currRow, 0, a), Xe.log("INFO", "Rolling up");
            }, x.prototype.getDisplayText = function(o) {
              o = o || !1;
              for (var a = [], l = "", f = -1, v = 0; v < Qr; v++) {
                var C = this.rows[v].getTextString();
                C && (f = v + 1, o ? a.push("Row " + f + ": '" + C + "'") : a.push(C.trim()));
              }
              return a.length > 0 && (o ? l = "[" + a.join(" | ") + "]" : l = a.join(`
`)), l;
            }, x.prototype.getTextAndFormat = function() {
              return this.rows;
            }, x;
          }(), Tc = function() {
            function x(s, o) {
              aa(this, x), this.chNr = s, this.outputFilter = o, this.mode = null, this.verbose = 0, this.displayedMemory = new yu(), this.nonDisplayedMemory = new yu(), this.lastOutputScreen = new yu(), this.currRollUpRow = this.displayedMemory.rows[Qr - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
            }
            return x.prototype.reset = function() {
              this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.currRollUpRow = this.displayedMemory.rows[Qr - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.lastCueEndTime = null;
            }, x.prototype.getHandler = function() {
              return this.outputFilter;
            }, x.prototype.setHandler = function(o) {
              this.outputFilter = o;
            }, x.prototype.setPAC = function(o) {
              this.writeScreen.setPAC(o);
            }, x.prototype.setBkgData = function(o) {
              this.writeScreen.setBkgData(o);
            }, x.prototype.setMode = function(o) {
              o !== this.mode && (this.mode = o, Xe.log("INFO", "MODE=" + o), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = o);
            }, x.prototype.insertChars = function(o) {
              for (var a = 0; a < o.length; a++)
                this.writeScreen.insertChar(o[a]);
              var l = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
              Xe.log("INFO", l + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (Xe.log("TEXT", "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
            }, x.prototype.ccRCL = function() {
              Xe.log("INFO", "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
            }, x.prototype.ccBS = function() {
              Xe.log("INFO", "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
            }, x.prototype.ccAOF = function() {
            }, x.prototype.ccAON = function() {
            }, x.prototype.ccDER = function() {
              Xe.log("INFO", "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
            }, x.prototype.ccRU = function(o) {
              Xe.log("INFO", "RU(" + o + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(o);
            }, x.prototype.ccFON = function() {
              Xe.log("INFO", "FON - Flash On"), this.writeScreen.setPen({ flash: !0 });
            }, x.prototype.ccRDC = function() {
              Xe.log("INFO", "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
            }, x.prototype.ccTR = function() {
              Xe.log("INFO", "TR"), this.setMode("MODE_TEXT");
            }, x.prototype.ccRTD = function() {
              Xe.log("INFO", "RTD"), this.setMode("MODE_TEXT");
            }, x.prototype.ccEDM = function() {
              Xe.log("INFO", "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
            }, x.prototype.ccCR = function() {
              Xe.log("CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
            }, x.prototype.ccENM = function() {
              Xe.log("INFO", "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
            }, x.prototype.ccEOC = function() {
              if (Xe.log("INFO", "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
                var o = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = o, this.writeScreen = this.nonDisplayedMemory, Xe.log("TEXT", "DISP: " + this.displayedMemory.getDisplayText());
              }
              this.outputDataUpdate(!0);
            }, x.prototype.ccTO = function(o) {
              Xe.log("INFO", "TO(" + o + ") - Tab Offset"), this.writeScreen.moveCursor(o);
            }, x.prototype.ccMIDROW = function(o) {
              var a = { flash: !1 };
              if (a.underline = o % 2 === 1, a.italics = o >= 46, a.italics)
                a.foreground = "white";
              else {
                var l = Math.floor(o / 2) - 16, f = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                a.foreground = f[l];
              }
              Xe.log("INFO", "MIDROW: " + JSON.stringify(a)), this.writeScreen.setPen(a);
            }, x.prototype.outputDataUpdate = function() {
              var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, a = Xe.time;
              a !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = a : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue && (this.outputFilter.newCue(this.cueStartTime, a, this.lastOutputScreen), o === !0 && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue()), this.cueStartTime = this.displayedMemory.isEmpty() ? null : a), this.lastOutputScreen.copy(this.displayedMemory));
            }, x.prototype.cueSplitAtTime = function(o) {
              this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, o, this.displayedMemory), this.cueStartTime = o));
            }, x;
          }(), hm = function() {
            function x(s, o, a) {
              aa(this, x), this.field = s || 1, this.outputs = [o, a], this.channels = [new Tc(1, o), new Tc(2, a)], this.currChNr = -1, this.lastCmdA = null, this.lastCmdB = null, this.bufferedData = [], this.startTime = null, this.lastTime = null, this.dataCounters = { padding: 0, char: 0, cmd: 0, other: 0 };
            }
            return x.prototype.getHandler = function(o) {
              return this.channels[o].getHandler();
            }, x.prototype.setHandler = function(o, a) {
              this.channels[o].setHandler(a);
            }, x.prototype.addData = function(o, a) {
              var l, f, v, C = !1;
              this.lastTime = o, Xe.setTime(o);
              for (var w = 0; w < a.length; w += 2) {
                if (f = a[w] & 127, v = a[w + 1] & 127, f === 0 && v === 0) {
                  this.dataCounters.padding += 2;
                  continue;
                } else
                  Xe.log("DATA", "[" + Dn([a[w], a[w + 1]]) + "] -> (" + Dn([f, v]) + ")");
                if (l = this.parseCmd(f, v), l || (l = this.parseMidrow(f, v)), l || (l = this.parsePAC(f, v)), l || (l = this.parseBackgroundAttributes(f, v)), !l && (C = this.parseChars(f, v), C))
                  if (this.currChNr && this.currChNr >= 0) {
                    var k = this.channels[this.currChNr - 1];
                    k.insertChars(C);
                  } else
                    Xe.log("WARNING", "No channel found yet. TEXT-MODE?");
                l ? this.dataCounters.cmd += 2 : C ? this.dataCounters.char += 2 : (this.dataCounters.other += 2, Xe.log("WARNING", "Couldn't parse cleaned data " + Dn([f, v]) + " orig: " + Dn([a[w], a[w + 1]])));
              }
            }, x.prototype.parseCmd = function(o, a) {
              var l = null, f = (o === 20 || o === 28) && 32 <= a && a <= 47, v = (o === 23 || o === 31) && 33 <= a && a <= 35;
              if (!(f || v))
                return !1;
              if (o === this.lastCmdA && a === this.lastCmdB)
                return this.lastCmdA = null, this.lastCmdB = null, Xe.log("DEBUG", "Repeated command (" + Dn([o, a]) + ") is dropped"), !0;
              o === 20 || o === 23 ? l = 1 : l = 2;
              var C = this.channels[l - 1];
              return o === 20 || o === 28 ? a === 32 ? C.ccRCL() : a === 33 ? C.ccBS() : a === 34 ? C.ccAOF() : a === 35 ? C.ccAON() : a === 36 ? C.ccDER() : a === 37 ? C.ccRU(2) : a === 38 ? C.ccRU(3) : a === 39 ? C.ccRU(4) : a === 40 ? C.ccFON() : a === 41 ? C.ccRDC() : a === 42 ? C.ccTR() : a === 43 ? C.ccRTD() : a === 44 ? C.ccEDM() : a === 45 ? C.ccCR() : a === 46 ? C.ccENM() : a === 47 && C.ccEOC() : C.ccTO(a - 32), this.lastCmdA = o, this.lastCmdB = a, this.currChNr = l, !0;
            }, x.prototype.parseMidrow = function(o, a) {
              var l = null;
              if ((o === 17 || o === 25) && 32 <= a && a <= 47) {
                if (o === 17 ? l = 1 : l = 2, l !== this.currChNr)
                  return Xe.log("ERROR", "Mismatch channel in midrow parsing"), !1;
                var f = this.channels[l - 1];
                return f.ccMIDROW(a), Xe.log("DEBUG", "MIDROW (" + Dn([o, a]) + ")"), !0;
              }
              return !1;
            }, x.prototype.parsePAC = function(o, a) {
              var l = null, f = null, v = (17 <= o && o <= 23 || 25 <= o && o <= 31) && 64 <= a && a <= 127, C = (o === 16 || o === 24) && 64 <= a && a <= 95;
              if (!(v || C))
                return !1;
              if (o === this.lastCmdA && a === this.lastCmdB)
                return this.lastCmdA = null, this.lastCmdB = null, !0;
              l = o <= 23 ? 1 : 2, 64 <= a && a <= 95 ? f = l === 1 ? om[o] : um[o] : f = l === 1 ? lm[o] : cm[o];
              var w = this.interpretPAC(f, a), k = this.channels[l - 1];
              return k.setPAC(w), this.lastCmdA = o, this.lastCmdB = a, this.currChNr = l, !0;
            }, x.prototype.interpretPAC = function(o, a) {
              var l = a, f = { color: null, italics: !1, indent: null, underline: !1, row: o };
              return a > 95 ? l = a - 96 : l = a - 64, f.underline = (l & 1) === 1, l <= 13 ? f.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(l / 2)] : l <= 15 ? (f.italics = !0, f.color = "white") : f.indent = Math.floor((l - 16) / 2) * 4, f;
            }, x.prototype.parseChars = function(o, a) {
              var l = null, f = null, v = null;
              if (o >= 25 ? (l = 2, v = o - 8) : (l = 1, v = o), 17 <= v && v <= 19) {
                var C = a;
                v === 17 ? C = a + 80 : v === 18 ? C = a + 112 : C = a + 144, Xe.log("INFO", "Special char '" + _c(C) + "' in channel " + l), f = [C];
              } else 32 <= o && o <= 127 && (f = a === 0 ? [o] : [o, a]);
              if (f) {
                var w = Dn(f);
                Xe.log("DEBUG", "Char codes =  " + w.join(",")), this.lastCmdA = null, this.lastCmdB = null;
              }
              return f;
            }, x.prototype.parseBackgroundAttributes = function(o, a) {
              var l, f, v, C, w = (o === 16 || o === 24) && 32 <= a && a <= 47, k = (o === 23 || o === 31) && 45 <= a && a <= 47;
              return w || k ? (l = {}, o === 16 || o === 24 ? (f = Math.floor((a - 32) / 2), l.background = dm[f], a % 2 === 1 && (l.background = l.background + "_semi")) : a === 45 ? l.background = "transparent" : (l.foreground = "black", a === 47 && (l.underline = !0)), v = o < 24 ? 1 : 2, C = this.channels[v - 1], C.setBkgData(l), this.lastCmdA = null, this.lastCmdB = null, !0) : !1;
            }, x.prototype.reset = function() {
              for (var o = 0; o < this.channels.length; o++)
                this.channels[o] && this.channels[o].reset();
              this.lastCmdA = null, this.lastCmdB = null;
            }, x.prototype.cueSplitAtTime = function(o) {
              for (var a = 0; a < this.channels.length; a++)
                this.channels[a] && this.channels[a].cueSplitAtTime(o);
            }, x;
          }(), mm = hm;
          function ym(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var bm = function() {
            function x(s, o) {
              ym(this, x), this.timelineController = s, this.track = o, this.startTime = null, this.endTime = null, this.screen = null;
            }
            return x.prototype.dispatchCue = function() {
              this.startTime !== null && (this.timelineController.addCues("textTrack" + this.track, this.startTime, this.endTime, this.screen), this.startTime = null);
            }, x.prototype.newCue = function(o, a, l) {
              (this.startTime === null || this.startTime > o) && (this.startTime = o), this.endTime = a, this.screen = l, this.timelineController.createCaptionsTrack(this.track);
            }, x;
          }(), Sc = bm, bu = function(s, o, a) {
            return s.substr(0, o.length) === o;
          }, gm = function(s) {
            var o = parseInt(s.substr(-3)), a = parseInt(s.substr(-6, 2)), l = parseInt(s.substr(-9, 2)), f = s.length > 9 ? parseInt(s.substr(0, s.indexOf(":"))) : 0;
            return isNaN(o) || isNaN(a) || isNaN(l) || isNaN(f) ? -1 : (o += 1e3 * a, o += 60 * 1e3 * l, o += 60 * 60 * 1e3 * f, o);
          }, gu = function(s) {
            for (var o = 5381, a = s.length; a; )
              o = o * 33 ^ s.charCodeAt(--a);
            return (o >>> 0).toString();
          }, xm = function(s, o, a) {
            var l = s[o], f = s[l.prevCC];
            if (!f || !f.new && l.new) {
              s.ccOffset = s.presentationOffset = l.start, l.new = !1;
              return;
            }
            for (; f && f.new; )
              s.ccOffset += l.start - f.start, l.new = !1, l = f, f = s[l.prevCC];
            s.presentationOffset = a;
          }, Em = {
            parse: function(s, o, a, l, f, v) {
              var C = /\r\n|\n\r|\n|\r/g, w = Object(ut.b)(new Uint8Array(s)).trim().replace(C, `
`).split(`
`), k = "00:00.000", I = 0, M = 0, $ = 0, H = [], le = void 0, ge = !0, Re = new am();
              Re.oncue = function(ve) {
                var Pe = a[l], Be = a.ccOffset;
                Pe && Pe.new && (M !== void 0 ? Be = a.ccOffset = Pe.start : xm(a, l, $)), $ && (Be = $ + a.ccOffset - a.presentationOffset), ve.startTime += Be - M, ve.endTime += Be - M, ve.id = gu(ve.startTime.toString()) + gu(ve.endTime.toString()) + gu(ve.text), ve.text = decodeURIComponent(encodeURIComponent(ve.text)), ve.endTime > 0 && H.push(ve);
              }, Re.onparsingerror = function(ve) {
                le = ve;
              }, Re.onflush = function() {
                if (le && v) {
                  v(le);
                  return;
                }
                f(H);
              }, w.forEach(function(ve) {
                if (ge)
                  if (bu(ve, "X-TIMESTAMP-MAP=")) {
                    ge = !1, ve.substr(16).split(",").forEach(function(Pe) {
                      bu(Pe, "LOCAL:") ? k = Pe.substr(6) : bu(Pe, "MPEGTS:") && (I = parseInt(Pe.substr(7)));
                    });
                    try {
                      o = o < 0 ? o + 8589934592 : o, I -= o, M = gm(k) / 1e3, $ = I / 9e4, M === -1 && (le = new Error("Malformed X-TIMESTAMP-MAP: " + ve));
                    } catch {
                      le = new Error("Malformed X-TIMESTAMP-MAP: " + ve);
                    }
                    return;
                  } else ve === "" && (ge = !1);
                Re.parse(ve + `
`);
              }), Re.flush();
            }
          }, vm = Em;
          function Rm(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Am(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function _m(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          function El(x) {
            if (x && x.cues)
              for (; x.cues.length > 0; )
                x.removeCue(x.cues[0]);
          }
          function wm(x, s) {
            return x && x.label === s.name && !(x.textTrack1 || x.textTrack2);
          }
          function Tm(x, s, o, a) {
            return Math.min(s, a) - Math.max(x, o);
          }
          var Sm = function(x) {
            _m(s, x);
            function s(o) {
              Rm(this, s);
              var a = Am(this, x.call(this, o, d.a.MEDIA_ATTACHING, d.a.MEDIA_DETACHING, d.a.FRAG_PARSING_USERDATA, d.a.FRAG_DECRYPTED, d.a.MANIFEST_LOADING, d.a.MANIFEST_LOADED, d.a.FRAG_LOADED, d.a.LEVEL_SWITCHING, d.a.INIT_PTS_FOUND));
              if (a.hls = o, a.config = o.config, a.enabled = !0, a.Cues = o.config.cueHandler, a.textTracks = [], a.tracks = [], a.unparsedVttFrags = [], a.initPTS = void 0, a.cueRanges = [], a.config.enableCEA708Captions) {
                var l = new Sc(a, 1), f = new Sc(a, 2);
                a.cea608Parser = new mm(0, l, f);
              }
              return a;
            }
            return s.prototype.addCues = function(a, l, f, v) {
              for (var C = this.cueRanges, w = !1, k = C.length; k--; ) {
                var I = C[k], M = Tm(I[0], I[1], l, f);
                if (M >= 0 && (I[0] = Math.min(I[0], l), I[1] = Math.max(I[1], f), w = !0, M / (f - l) > 0.5))
                  return;
              }
              w || C.push([l, f]), this.Cues.newCue(this[a], l, f, v);
            }, s.prototype.onInitPtsFound = function(a) {
              var l = this;
              typeof this.initPTS > "u" && (this.initPTS = a.initPTS), this.unparsedVttFrags.length && (this.unparsedVttFrags.forEach(function(f) {
                l.onFragLoaded(f);
              }), this.unparsedVttFrags = []);
            }, s.prototype.getExistingTrack = function(a) {
              var l = this.media;
              if (l)
                for (var f = 0; f < l.textTracks.length; f++) {
                  var v = l.textTracks[f], C = "textTrack" + a;
                  if (v[C] === !0)
                    return v;
                }
              return null;
            }, s.prototype.sendAddTrackEvent = function(a, l) {
              var f = null;
              try {
                f = new window.Event("addtrack");
              } catch {
                f = document.createEvent("Event"), f.initEvent("addtrack", !1, !1);
              }
              f.track = a, l.dispatchEvent(f);
            }, s.prototype.createCaptionsTrack = function(a) {
              var l = "textTrack" + a;
              if (!this[l]) {
                var f = this.getExistingTrack(a);
                if (f)
                  this[l] = f, El(this[l]), this.sendAddTrackEvent(this[l], this.media);
                else {
                  var v = this.createTextTrack("captions", this.config["captionsTextTrack" + a + "Label"], this.config.captionsTextTrack1LanguageCode);
                  v && (v[l] = !0, this[l] = v);
                }
              }
            }, s.prototype.createTextTrack = function(a, l, f) {
              var v = this.media;
              if (v)
                return v.addTextTrack(a, l, f);
            }, s.prototype.destroy = function() {
              X.prototype.destroy.call(this);
            }, s.prototype.onMediaAttaching = function(a) {
              this.media = a.media, this._cleanTracks();
            }, s.prototype.onMediaDetaching = function() {
              El(this.textTrack1), El(this.textTrack2);
            }, s.prototype.onManifestLoading = function() {
              this.lastSn = -1, this.prevCC = -1, this.vttCCs = { ccOffset: 0, presentationOffset: 0 }, this._cleanTracks();
            }, s.prototype._cleanTracks = function() {
              var a = this.media;
              if (a) {
                var l = a.textTracks;
                if (l)
                  for (var f = 0; f < l.length; f++)
                    El(l[f]);
              }
            }, s.prototype.onManifestLoaded = function(a) {
              var l = this;
              if (this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = void 0, this.cueRanges = [], this.config.enableWebVTT) {
                this.tracks = a.subtitles || [];
                var f = this.media ? this.media.textTracks : [];
                this.tracks.forEach(function(v, C) {
                  var w = void 0;
                  if (C < f.length) {
                    var k = f[C];
                    wm(k, v) && (w = k);
                  }
                  w || (w = l.createTextTrack("subtitles", v.name, v.lang)), w.mode = v.default ? "showing" : "hidden", l.textTracks.push(w);
                });
              }
            }, s.prototype.onLevelSwitching = function() {
              this.enabled = this.hls.currentLevel.closedCaptions !== "NONE";
            }, s.prototype.onFragLoaded = function(a) {
              var l = a.frag, f = a.payload;
              if (l.type === "main") {
                var v = l.sn;
                if (v !== this.lastSn + 1) {
                  var C = this.cea608Parser;
                  C && C.reset();
                }
                this.lastSn = v;
              } else if (l.type === "subtitle")
                if (f.byteLength) {
                  if (typeof this.initPTS > "u") {
                    this.unparsedVttFrags.push(a);
                    return;
                  }
                  var w = l.decryptdata;
                  (w == null || w.key == null || w.method !== "AES-128") && this._parseVTTs(l, f);
                } else
                  this.hls.trigger(d.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: l });
            }, s.prototype._parseVTTs = function(a, l) {
              var f = this.vttCCs;
              f[a.cc] || (f[a.cc] = { start: a.start, prevCC: this.prevCC, new: !0 }, this.prevCC = a.cc);
              var v = this.textTracks, C = this.hls;
              vm.parse(l, this.initPTS, f, a.cc, function(w) {
                var k = v[a.trackId];
                w.forEach(function(I) {
                  if (!k.cues.getCueById(I.id))
                    try {
                      k.addCue(I);
                    } catch {
                      var M = new window.TextTrackCue(I.startTime, I.endTime, I.text);
                      M.id = I.id, k.addCue(M);
                    }
                }), C.trigger(d.a.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: a });
              }, function(w) {
                p.b.log("Failed to parse VTT cue: " + w), C.trigger(d.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: a });
              });
            }, s.prototype.onFragDecrypted = function(a) {
              var l = a.payload, f = a.frag;
              if (f.type === "subtitle") {
                if (typeof this.initPTS > "u") {
                  this.unparsedVttFrags.push(a);
                  return;
                }
                this._parseVTTs(f, l);
              }
            }, s.prototype.onFragParsingUserdata = function(a) {
              if (this.enabled && this.config.enableCEA708Captions)
                for (var l = 0; l < a.samples.length; l++) {
                  var f = this.extractCea608Data(a.samples[l].bytes);
                  this.cea608Parser.addData(a.samples[l].pts, f);
                }
            }, s.prototype.extractCea608Data = function(a) {
              for (var l = a[0] & 31, f = 2, v, C, w, k, I, M = [], $ = 0; $ < l; $++)
                v = a[f++], C = 127 & a[f++], w = 127 & a[f++], k = (4 & v) !== 0, I = 3 & v, !(C === 0 && w === 0) && k && I === 0 && (M.push(C), M.push(w));
              return M;
            }, s;
          }(X), Cm = Sm, Lm = /* @__PURE__ */ function() {
            function x(s, o) {
              for (var a = 0; a < o.length; a++) {
                var l = o[a];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, a) {
              return o && x(s.prototype, o), a && x(s, a), s;
            };
          }();
          function km(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Dm(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function Pm(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          function Cc(x) {
            for (var s = [], o = 0; o < x.length; o++)
              x[o].kind === "subtitles" && s.push(x[o]);
            return s;
          }
          var Bm = function(x) {
            Pm(s, x);
            function s(o) {
              km(this, s);
              var a = Dm(this, x.call(this, o, d.a.MEDIA_ATTACHED, d.a.MEDIA_DETACHING, d.a.MANIFEST_LOADING, d.a.MANIFEST_LOADED, d.a.SUBTITLE_TRACK_LOADED));
              return a.tracks = [], a.trackId = -1, a.media = void 0, a.subtitleDisplay = !1, a;
            }
            return s.prototype._onTextTracksChanged = function() {
              if (this.media) {
                for (var a = -1, l = Cc(this.media.textTracks), f = 0; f < l.length; f++)
                  l[f].mode === "showing" && (a = f);
                this.subtitleTrack = a;
              }
            }, s.prototype.destroy = function() {
              X.prototype.destroy.call(this);
            }, s.prototype.onMediaAttached = function(a) {
              var l = this;
              this.media = a.media, this.media && (this.queuedDefaultTrack !== void 0 && (this.subtitleTrack = this.queuedDefaultTrack, delete this.queuedDefaultTrack), this.trackChangeListener = this._onTextTracksChanged.bind(this), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.subtitlePollingInterval = setInterval(function() {
                l.trackChangeListener();
              }, 500) : this.media.textTracks.addEventListener("change", this.trackChangeListener));
            }, s.prototype.onMediaDetaching = function() {
              this.media && (this.useTextTrackPolling ? clearInterval(this.subtitlePollingInterval) : this.media.textTracks.removeEventListener("change", this.trackChangeListener), this.media = void 0);
            }, s.prototype.onManifestLoading = function() {
              this.tracks = [], this.trackId = -1;
            }, s.prototype.onManifestLoaded = function(a) {
              var l = this, f = a.subtitles || [];
              this.tracks = f, this.trackId = -1, this.hls.trigger(d.a.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: f }), f.forEach(function(v) {
                v.default && (l.media ? l.subtitleTrack = v.id : l.queuedDefaultTrack = v.id);
              });
            }, s.prototype.onTick = function() {
              var a = this.trackId, l = this.tracks[a];
              if (l) {
                var f = l.details;
                (f === void 0 || f.live === !0) && (p.b.log("(re)loading playlist for subtitle track " + a), this.hls.trigger(d.a.SUBTITLE_TRACK_LOADING, { url: l.url, id: a }));
              }
            }, s.prototype.onSubtitleTrackLoaded = function(a) {
              var l = this;
              a.id < this.tracks.length && (p.b.log("subtitle track " + a.id + " loaded"), this.tracks[a.id].details = a.details, a.details.live && !this.timer && (this.timer = setInterval(function() {
                l.onTick();
              }, 1e3 * a.details.targetduration, this)), !a.details.live && this.timer && (clearInterval(this.timer), this.timer = null));
            }, s.prototype.setSubtitleTrackInternal = function(a) {
              if (!(a < -1 || a >= this.tracks.length)) {
                this.timer && (clearInterval(this.timer), this.timer = null);
                var l = Cc(this.media.textTracks);
                if (this.trackId !== -1 && this.subtitleDisplay && (l[this.trackId].mode = "hidden"), this.trackId = a, p.b.log("switching to subtitle track " + a), this.hls.trigger(d.a.SUBTITLE_TRACK_SWITCH, { id: a }), a !== -1) {
                  var f = this.tracks[a];
                  this.subtitleDisplay && (l[a].mode = "showing");
                  var v = f.details;
                  (v === void 0 || v.live === !0) && (p.b.log("(re)loading playlist for subtitle track " + a), this.hls.trigger(d.a.SUBTITLE_TRACK_LOADING, { url: f.url, id: a }));
                }
              }
            }, Lm(s, [{
              key: "subtitleTracks",
              get: function() {
                return this.tracks;
              }
              /** get index of the selected subtitle track (index in subtitle track lists) **/
            }, {
              key: "subtitleTrack",
              get: function() {
                return this.trackId;
              },
              set: function(a) {
                this.trackId !== a && this.setSubtitleTrackInternal(a);
              }
            }]), s;
          }(X), Im = Bm, Um = u(4);
          function Om(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Km(x, s) {
            if (!x)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : x;
          }
          function Mm(x, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            x.prototype = Object.create(s && s.prototype, { constructor: { value: x, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(x, s) : x.__proto__ = s);
          }
          var ui = {
            STOPPED: "STOPPED",
            IDLE: "IDLE",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING"
          }, Nm = function(x) {
            Mm(s, x);
            function s(o) {
              Om(this, s);
              var a = Km(this, x.call(this, o, d.a.MEDIA_ATTACHED, d.a.ERROR, d.a.KEY_LOADED, d.a.FRAG_LOADED, d.a.SUBTITLE_TRACKS_UPDATED, d.a.SUBTITLE_TRACK_SWITCH, d.a.SUBTITLE_TRACK_LOADED, d.a.SUBTITLE_FRAG_PROCESSED));
              return a.config = o.config, a.vttFragSNsProcessed = {}, a.vttFragQueues = void 0, a.currentlyProcessing = null, a.state = ui.STOPPED, a.currentTrackId = -1, a.ticks = 0, a.decrypter = new Um.a(o.observer, o.config), a;
            }
            return s.prototype.destroy = function() {
              X.prototype.destroy.call(this), this.state = ui.STOPPED;
            }, s.prototype.clearVttFragQueues = function() {
              var a = this;
              this.vttFragQueues = {}, this.tracks.forEach(function(l) {
                a.vttFragQueues[l.id] = [];
              });
            }, s.prototype.nextFrag = function() {
              if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
                var a = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
                this.fragCurrent = a, this.hls.trigger(d.a.FRAG_LOADING, { frag: a }), this.state = ui.FRAG_LOADING;
              }
            }, s.prototype.onSubtitleFragProcessed = function(a) {
              a.success && this.vttFragSNsProcessed[a.frag.trackId].push(a.frag.sn), this.currentlyProcessing = null, this.state = ui.IDLE, this.nextFrag();
            }, s.prototype.onMediaAttached = function() {
              this.state = ui.IDLE;
            }, s.prototype.onError = function(a) {
              var l = a.frag;
              l && l.type !== "subtitle" || this.currentlyProcessing && (this.currentlyProcessing = null, this.nextFrag());
            }, s.prototype.tick = function() {
              var a = this;
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(function() {
                a.tick();
              }, 1), this.ticks = 0);
            }, s.prototype.doTick = function() {
              var a = this;
              switch (this.state) {
                case ui.IDLE:
                  var l = this.tracks, f = this.currentTrackId, v = this.vttFragSNsProcessed[f], C = this.vttFragQueues[f], w = this.currentlyProcessing ? this.currentlyProcessing.sn : -1, k = function(H) {
                    return v.indexOf(H.sn) > -1;
                  }, I = function(H) {
                    return C.some(function(le) {
                      return le.sn === H.sn;
                    });
                  };
                  if (!l)
                    break;
                  var M;
                  if (f < l.length && (M = l[f].details), typeof M > "u")
                    break;
                  M.fragments.forEach(function($) {
                    k($) || $.sn === w || I($) || ($.decryptdata && $.decryptdata.uri != null && $.decryptdata.key == null ? (p.b.log("Loading key for " + $.sn), a.state = ui.KEY_LOADING, a.hls.trigger(d.a.KEY_LOADING, { frag: $ })) : ($.trackId = f, C.push($), a.nextFrag()));
                  });
              }
            }, s.prototype.onSubtitleTracksUpdated = function(a) {
              var l = this;
              p.b.log("subtitle tracks updated"), this.tracks = a.subtitleTracks, this.clearVttFragQueues(), this.vttFragSNsProcessed = {}, this.tracks.forEach(function(f) {
                l.vttFragSNsProcessed[f.id] = [];
              });
            }, s.prototype.onSubtitleTrackSwitch = function(a) {
              this.currentTrackId = a.id, this.clearVttFragQueues();
            }, s.prototype.onSubtitleTrackLoaded = function() {
              this.tick();
            }, s.prototype.onKeyLoaded = function() {
              this.state === ui.KEY_LOADING && (this.state = ui.IDLE, this.tick());
            }, s.prototype.onFragLoaded = function(a) {
              var l = this.fragCurrent, f = a.frag.decryptdata, v = a.frag, C = this.hls;
              if (this.state === ui.FRAG_LOADING && l && a.frag.type === "subtitle" && l.sn === a.frag.sn && a.payload.byteLength > 0 && f != null && f.key != null && f.method === "AES-128") {
                var w;
                try {
                  w = performance.now();
                } catch {
                  w = Date.now();
                }
                this.decrypter.decrypt(a.payload, f.key.buffer, f.iv.buffer, function(k) {
                  var I;
                  try {
                    I = performance.now();
                  } catch {
                    I = Date.now();
                  }
                  C.trigger(d.a.FRAG_DECRYPTED, { frag: v, payload: k, stats: { tstart: w, tdecrypt: I } });
                });
              }
            }, s;
          }(X), Vm = Nm, Lr = {
            autoStartLoad: !0,
            // used by stream-controller
            startPosition: -1,
            // used by stream-controller
            defaultAudioCodec: void 0,
            // used by stream-controller
            debug: !1,
            // used by logger
            capLevelOnFPSDrop: !1,
            // used by fps-controller
            capLevelToPlayerSize: !1,
            // used by cap-level-controller
            initialLiveManifestSize: 1,
            // used by stream-controller
            maxBufferLength: 30,
            // used by stream-controller
            maxBufferSize: 60 * 1e3 * 1e3,
            // used by stream-controller
            maxBufferHole: 0.5,
            // used by stream-controller
            maxSeekHole: 2,
            // used by stream-controller
            lowBufferWatchdogPeriod: 0.5,
            // used by stream-controller
            highBufferWatchdogPeriod: 3,
            // used by stream-controller
            nudgeOffset: 0.1,
            // used by stream-controller
            nudgeMaxRetry: 3,
            // used by stream-controller
            maxFragLookUpTolerance: 0.25,
            // used by stream-controller
            liveSyncDurationCount: 3,
            // used by stream-controller
            liveMaxLatencyDurationCount: 1 / 0,
            // used by stream-controller
            liveSyncDuration: void 0,
            // used by stream-controller
            liveMaxLatencyDuration: void 0,
            // used by stream-controller
            liveDurationInfinity: !1,
            // used by buffer-controller
            maxMaxBufferLength: 600,
            // used by stream-controller
            enableWorker: !0,
            // used by demuxer
            enableSoftwareAES: !0,
            // used by decrypter
            manifestLoadingTimeOut: 1e4,
            // used by playlist-loader
            manifestLoadingMaxRetry: 1,
            // used by playlist-loader
            manifestLoadingRetryDelay: 1e3,
            // used by playlist-loader
            manifestLoadingMaxRetryTimeout: 64e3,
            // used by playlist-loader
            startLevel: void 0,
            // used by level-controller
            levelLoadingTimeOut: 1e4,
            // used by playlist-loader
            levelLoadingMaxRetry: 4,
            // used by playlist-loader
            levelLoadingRetryDelay: 1e3,
            // used by playlist-loader
            levelLoadingMaxRetryTimeout: 64e3,
            // used by playlist-loader
            fragLoadingTimeOut: 2e4,
            // used by fragment-loader
            fragLoadingMaxRetry: 6,
            // used by fragment-loader
            fragLoadingRetryDelay: 1e3,
            // used by fragment-loader
            fragLoadingMaxRetryTimeout: 64e3,
            // used by fragment-loader
            fragLoadingLoopThreshold: 3,
            // used by stream-controller
            startFragPrefetch: !1,
            // used by stream-controller
            fpsDroppedMonitoringPeriod: 5e3,
            // used by fps-controller
            fpsDroppedMonitoringThreshold: 0.2,
            // used by fps-controller
            appendErrorMaxRetry: 3,
            // used by buffer-controller
            loader: we,
            //loader: FetchLoader,
            fLoader: void 0,
            pLoader: void 0,
            xhrSetup: void 0,
            fetchSetup: void 0,
            abrController: Ki,
            bufferController: Fr,
            capLevelController: c,
            fpsController: ce,
            stretchShortVideoTrack: !1,
            // used by mp4-remuxer
            maxAudioFramesDrift: 1,
            // used by mp4-remuxer
            forceKeyFrameOnDiscontinuity: !0,
            // used by ts-demuxer
            abrEwmaFastLive: 3,
            // used by abr-controller
            abrEwmaSlowLive: 9,
            // used by abr-controller
            abrEwmaFastVoD: 3,
            // used by abr-controller
            abrEwmaSlowVoD: 9,
            // used by abr-controller
            abrEwmaDefaultEstimate: 5e5,
            // 500 kbps  // used by abr-controller
            abrBandWidthFactor: 0.95,
            // used by abr-controller
            abrBandWidthUpFactor: 0.7,
            // used by abr-controller
            abrMaxWithRealBitrate: !1,
            // used by abr-controller
            maxStarvationDelay: 4,
            // used by abr-controller
            maxLoadingDelay: 4,
            // used by abr-controller
            minAutoBitrate: 0
            // used by hls
          };
          Lr.subtitleStreamController = Vm, Lr.subtitleTrackController = Im, Lr.timelineController = Cm, Lr.cueHandler = y, Lr.enableCEA708Captions = !0, Lr.enableWebVTT = !0, Lr.captionsTextTrack1Label = "English", Lr.captionsTextTrack1LanguageCode = "en", Lr.captionsTextTrack2Label = "Spanish", Lr.captionsTextTrack2LanguageCode = "es", Lr.audioStreamController = tm, Lr.audioTrackController = Z0;
          var Lc = /* @__PURE__ */ function() {
            function x(s, o) {
              for (var a = 0; a < o.length; a++) {
                var l = o[a];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, a) {
              return o && x(s.prototype, o), a && x(s, a), s;
            };
          }();
          function jm(x, s) {
            if (!(x instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var Fm = function() {
            x.isSupported = function() {
              return qt();
            }, Lc(x, null, [{
              key: "version",
              get: function() {
                return "0.8.9";
              }
            }, {
              key: "Events",
              get: function() {
                return d.a;
              }
            }, {
              key: "ErrorTypes",
              get: function() {
                return m.b;
              }
            }, {
              key: "ErrorDetails",
              get: function() {
                return m.a;
              }
            }, {
              key: "DefaultConfig",
              get: function() {
                return x.defaultConfig ? x.defaultConfig : Lr;
              },
              set: function(o) {
                x.defaultConfig = o;
              }
            }]);
            function x() {
              var s = this, o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              jm(this, x);
              var a = x.DefaultConfig;
              if ((o.liveSyncDurationCount || o.liveMaxLatencyDurationCount) && (o.liveSyncDuration || o.liveMaxLatencyDuration))
                throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
              for (var l in a)
                l in o || (o[l] = a[l]);
              if (o.liveMaxLatencyDurationCount !== void 0 && o.liveMaxLatencyDurationCount <= o.liveSyncDurationCount)
                throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
              if (o.liveMaxLatencyDuration !== void 0 && (o.liveMaxLatencyDuration <= o.liveSyncDuration || o.liveSyncDuration === void 0))
                throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
              Object(p.a)(o.debug), this.config = o, this._autoLevelCapping = -1;
              var f = this.observer = new Ot.a();
              f.trigger = function(_t) {
                for (var Ce = arguments.length, zt = Array(Ce > 1 ? Ce - 1 : 0), bt = 1; bt < Ce; bt++)
                  zt[bt - 1] = arguments[bt];
                f.emit.apply(f, [_t, _t].concat(zt));
              }, f.off = function(_t) {
                for (var Ce = arguments.length, zt = Array(Ce > 1 ? Ce - 1 : 0), bt = 1; bt < Ce; bt++)
                  zt[bt - 1] = arguments[bt];
                f.removeListener.apply(f, [_t].concat(zt));
              }, this.on = f.on.bind(f), this.off = f.off.bind(f), this.trigger = f.trigger.bind(f);
              var v = this.abrController = new o.abrController(this), C = new o.bufferController(this), w = new o.capLevelController(this), k = new o.fpsController(this), I = new st(this), M = new it(this), $ = new mt(this), H = new br(this), le = this.levelController = new Lt(this), ge = this.streamController = new nt(this), Re = [le, ge], ve = o.audioStreamController;
              ve && Re.push(new ve(this)), this.networkControllers = Re;
              var Pe = [I, M, $, v, C, w, k, H];
              if (ve = o.audioTrackController, ve) {
                var Be = new ve(this);
                this.audioTrackController = Be, Pe.push(Be);
              }
              if (ve = o.subtitleTrackController, ve) {
                var Ne = new ve(this);
                this.subtitleTrackController = Ne, Pe.push(Ne);
              }
              [o.subtitleStreamController, o.timelineController].forEach(function(et) {
                et && Pe.push(new et(s));
              }), this.coreComponents = Pe;
            }
            return x.prototype.destroy = function() {
              p.b.log("destroy"), this.trigger(d.a.DESTROYING), this.detachMedia(), this.coreComponents.concat(this.networkControllers).forEach(function(o) {
                o.destroy();
              }), this.url = null, this.observer.removeAllListeners(), this._autoLevelCapping = -1;
            }, x.prototype.attachMedia = function(o) {
              p.b.log("attachMedia"), this.media = o, this.trigger(d.a.MEDIA_ATTACHING, { media: o });
            }, x.prototype.detachMedia = function() {
              p.b.log("detachMedia"), this.trigger(d.a.MEDIA_DETACHING), this.media = null;
            }, x.prototype.loadSource = function(o) {
              o = h.a.buildAbsoluteURL(window.location.href, o, { alwaysNormalize: !0 }), p.b.log("loadSource:" + o), this.url = o, this.trigger(d.a.MANIFEST_LOADING, { url: o });
            }, x.prototype.startLoad = function() {
              var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
              p.b.log("startLoad(" + o + ")"), this.networkControllers.forEach(function(a) {
                a.startLoad(o);
              });
            }, x.prototype.stopLoad = function() {
              p.b.log("stopLoad"), this.networkControllers.forEach(function(o) {
                o.stopLoad();
              });
            }, x.prototype.swapAudioCodec = function() {
              p.b.log("swapAudioCodec"), this.streamController.swapAudioCodec();
            }, x.prototype.recoverMediaError = function() {
              p.b.log("recoverMediaError");
              var o = this.media;
              this.detachMedia(), this.attachMedia(o);
            }, Lc(x, [{
              key: "levels",
              get: function() {
                return this.levelController.levels;
              }
              /** Return current playback quality level **/
            }, {
              key: "currentLevel",
              get: function() {
                return this.streamController.currentLevel;
              },
              set: function(o) {
                p.b.log("set currentLevel:" + o), this.loadLevel = o, this.streamController.immediateLevelSwitch();
              }
              /** Return next playback quality level (quality level of next fragment) **/
            }, {
              key: "nextLevel",
              get: function() {
                return this.streamController.nextLevel;
              },
              set: function(o) {
                p.b.log("set nextLevel:" + o), this.levelController.manualLevel = o, this.streamController.nextLevelSwitch();
              }
              /** Return the quality level of current/last loaded fragment **/
            }, {
              key: "loadLevel",
              get: function() {
                return this.levelController.level;
              },
              set: function(o) {
                p.b.log("set loadLevel:" + o), this.levelController.manualLevel = o;
              }
              /** Return the quality level of next loaded fragment **/
            }, {
              key: "nextLoadLevel",
              get: function() {
                return this.levelController.nextLoadLevel;
              },
              set: function(o) {
                this.levelController.nextLoadLevel = o;
              }
              /** Return first level (index of first level referenced in manifest)
              **/
            }, {
              key: "firstLevel",
              get: function() {
                return Math.max(this.levelController.firstLevel, this.minAutoLevel);
              },
              set: function(o) {
                p.b.log("set firstLevel:" + o), this.levelController.firstLevel = o;
              }
              /** Return start level (level of first fragment that will be played back)
                  if not overrided by user, first level appearing in manifest will be used as start level
                  if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
              **/
            }, {
              key: "startLevel",
              get: function() {
                return this.levelController.startLevel;
              },
              set: function(o) {
                p.b.log("set startLevel:" + o);
                var a = this;
                o !== -1 && (o = Math.max(o, a.minAutoLevel)), a.levelController.startLevel = o;
              }
              /** Return the capping/max level value that could be used by automatic level selection algorithm **/
            }, {
              key: "autoLevelCapping",
              get: function() {
                return this._autoLevelCapping;
              },
              set: function(o) {
                p.b.log("set autoLevelCapping:" + o), this._autoLevelCapping = o;
              }
              /* check if we are in automatic level selection mode */
            }, {
              key: "autoLevelEnabled",
              get: function() {
                return this.levelController.manualLevel === -1;
              }
              /* return manual level */
            }, {
              key: "manualLevel",
              get: function() {
                return this.levelController.manualLevel;
              }
              /* return min level selectable in auto mode according to config.minAutoBitrate */
            }, {
              key: "minAutoLevel",
              get: function() {
                for (var o = this, a = o.levels, l = o.config.minAutoBitrate, f = a ? a.length : 0, v = 0; v < f; v++) {
                  var C = a[v].realBitrate ? Math.max(a[v].realBitrate, a[v].bitrate) : a[v].bitrate;
                  if (C > l)
                    return v;
                }
                return 0;
              }
              /* return max level selectable in auto mode according to autoLevelCapping */
            }, {
              key: "maxAutoLevel",
              get: function() {
                var o = this, a = o.levels, l = o.autoLevelCapping, f = void 0;
                return l === -1 && a && a.length ? f = a.length - 1 : f = l, f;
              }
              // return next auto level
            }, {
              key: "nextAutoLevel",
              get: function() {
                var o = this;
                return Math.min(Math.max(o.abrController.nextAutoLevel, o.minAutoLevel), o.maxAutoLevel);
              },
              set: function(o) {
                var a = this;
                a.abrController.nextAutoLevel = Math.max(a.minAutoLevel, o);
              }
              /** get alternate audio tracks list from playlist **/
            }, {
              key: "audioTracks",
              get: function() {
                var o = this.audioTrackController;
                return o ? o.audioTracks : [];
              }
              /** get index of the selected audio track (index in audio track lists) **/
            }, {
              key: "audioTrack",
              get: function() {
                var o = this.audioTrackController;
                return o ? o.audioTrack : -1;
              },
              set: function(o) {
                var a = this.audioTrackController;
                a && (a.audioTrack = o);
              }
            }, {
              key: "liveSyncPosition",
              get: function() {
                return this.streamController.liveSyncPosition;
              }
              /** get alternate subtitle tracks list from playlist **/
            }, {
              key: "subtitleTracks",
              get: function() {
                var o = this.subtitleTrackController;
                return o ? o.subtitleTracks : [];
              }
              /** get index of the selected subtitle track (index in subtitle track lists) **/
            }, {
              key: "subtitleTrack",
              get: function() {
                var o = this.subtitleTrackController;
                return o ? o.subtitleTrack : -1;
              },
              set: function(o) {
                var a = this.subtitleTrackController;
                a && (a.subtitleTrack = o);
              }
            }, {
              key: "subtitleDisplay",
              get: function() {
                var o = this.subtitleTrackController;
                return o ? o.subtitleDisplay : !1;
              },
              set: function(o) {
                var a = this.subtitleTrackController;
                a && (a.subtitleDisplay = o);
              }
            }]), x;
          }();
          n.default = Fm;
        },
        /* 9 */
        /***/
        function(r, n, u) {
          function y(m) {
            var p = {};
            function _(N) {
              if (p[N])
                return p[N].exports;
              var X = p[N] = {
                /******/
                i: N,
                /******/
                l: !1,
                /******/
                exports: {}
                /******/
              };
              return m[N].call(X.exports, X, X.exports, _), X.l = !0, X.exports;
            }
            _.m = m, _.c = p, _.i = function(N) {
              return N;
            }, _.d = function(N, X, te) {
              _.o(N, X) || Object.defineProperty(N, X, {
                /******/
                configurable: !1,
                /******/
                enumerable: !0,
                /******/
                get: te
                /******/
              });
            }, _.n = function(N) {
              var X = N && N.__esModule ? (
                /******/
                function() {
                  return N.default;
                }
              ) : (
                /******/
                function() {
                  return N;
                }
              );
              return _.d(X, "a", X), X;
            }, _.o = function(N, X) {
              return Object.prototype.hasOwnProperty.call(N, X);
            }, _.p = "/", _.oe = function(N) {
              throw console.error(N), N;
            };
            var B = _(_.s = ENTRY_MODULE);
            return B.default || B;
          }
          function b(m) {
            return (m + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
          }
          function h(m) {
            var p = [], _ = m.toString(), B = _.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);
            if (!B) return p;
            for (var N = B[1], X = new RegExp("(\\\\n|\\W)" + b(N) + "\\((/\\*.*?\\*/)?s?.*?([\\.|\\-|\\w|/|@]+).*?\\)", "g"), te; te = X.exec(_); )
              p.push(te[3]);
            return p;
          }
          function d(m, p) {
            for (var _ = [p], B = [], N = {}; _.length; ) {
              var X = _.pop();
              if (!(N[X] || !m[X])) {
                N[X] = !0, B.push(X);
                var te = h(m[X]);
                _ = _.concat(te);
              }
            }
            return B;
          }
          r.exports = function(m, p) {
            p = p || {};
            var _ = u.m, B = p.all ? Object.keys(_) : d(_, m), N = "(" + y.toString().replace("ENTRY_MODULE", JSON.stringify(m)) + ")({" + B.map(function(F) {
              return "" + JSON.stringify(F) + ": " + _[F].toString();
            }).join(",") + "})(self);", X = new window.Blob([N], { type: "text/javascript" });
            if (p.bare)
              return X;
            var te = window.URL || window.webkitURL || window.mozURL || window.msURL, re = te.createObjectURL(X), J = new window.Worker(re);
            return J.objectURL = re, J;
          };
        },
        /* 10 */
        /***/
        function(r, n, u) {
          Object.defineProperty(n, "__esModule", { value: !0 });
          var y = u(7), b = u(1), h = u(0), d = u(5), m = u.n(d), p = function(B) {
            var N = new m.a();
            N.trigger = function(re) {
              for (var J = arguments.length, F = Array(J > 1 ? J - 1 : 0), z = 1; z < J; z++)
                F[z - 1] = arguments[z];
              N.emit.apply(N, [re, re].concat(F));
            }, N.off = function(re) {
              for (var J = arguments.length, F = Array(J > 1 ? J - 1 : 0), z = 1; z < J; z++)
                F[z - 1] = arguments[z];
              N.removeListener.apply(N, [re].concat(F));
            };
            var X = function(re, J) {
              B.postMessage({ event: re, data: J });
            };
            B.addEventListener("message", function(te) {
              var re = te.data;
              switch (re.cmd) {
                case "init":
                  var J = JSON.parse(re.config);
                  B.demuxer = new y.a(N, re.typeSupported, J, re.vendor);
                  try {
                    Object(h.a)(J.debug === !0);
                  } catch {
                    console.warn("demuxerWorker: unable to enable logs");
                  }
                  X("init", null);
                  break;
                case "demux":
                  B.demuxer.push(re.data, re.decryptdata, re.initSegment, re.audioCodec, re.videoCodec, re.timeOffset, re.discontinuity, re.trackSwitch, re.contiguous, re.duration, re.accurateTimeOffset, re.defaultInitPTS);
                  break;
              }
            }), N.on(b.a.FRAG_DECRYPTED, X), N.on(b.a.FRAG_PARSING_INIT_SEGMENT, X), N.on(b.a.FRAG_PARSED, X), N.on(b.a.ERROR, X), N.on(b.a.FRAG_PARSING_METADATA, X), N.on(b.a.FRAG_PARSING_USERDATA, X), N.on(b.a.INIT_PTS_FOUND, X), N.on(b.a.FRAG_PARSING_DATA, function(te, re) {
              var J = [], F = { event: te, data: re };
              re.data1 && (F.data1 = re.data1.buffer, J.push(re.data1.buffer), delete re.data1), re.data2 && (F.data2 = re.data2.buffer, J.push(re.data2.buffer), delete re.data2), B.postMessage(F, J);
            });
          };
          n.default = p;
        }
        /******/
      ]).default
    );
  });
})(q0);
var iU = q0.exports;
const Bu = /* @__PURE__ */ gy(iU), X0 = ({
  post: t,
  reason: e,
  isRoot: r
}) => {
  if (t.$type === "app.bsky.graph.defs#listView" || t.$type === "app.bsky.graph.defs#starterPackViewBasic")
    return {
      username: t.creator.displayName,
      handle: t.creator.handle,
      avatar: t.creator.avatar,
      text: [{
        val: t.description,
        setInnerHtml: !1
      }],
      createdAt: t.indexedAt,
      uri: t.uri,
      images: [],
      card: null,
      replyPost: null,
      isRepost: !1,
      repostBy: null
    };
  const n = t.record?.facets || [], u = t.record?.text, y = new Xu.RichText({
    text: u,
    facets: n
  }), b = [];
  for (const m of y.segments())
    m.isLink() ? b.push({
      val: `<a href="${m.link?.uri}" target="_blank" rel="noopener" class="text-blue-500 underline">${m.text}</a>`,
      setInnerHtml: !0
    }) : m.isMention() ? b.push({
      val: `<a href="https://bsky.app/profile/${m.mention?.did}" target="_blank" rel="noopener" class="text-blue-500 underline">${m.text}</a>`,
      setInnerHtml: !0
    }) : m.isTag() ? b.push({
      val: `<a href="https://bsky.app/hashtag/${m.tag?.tag}" target="_blank" rel="noopener" class="text-blue-500 underline">${m.text}</a>`,
      setInnerHtml: !0
    }) : b.push({
      val: m.text,
      setInnerHtml: !1
    });
  const h = t.embed?.$type === "app.bsky.graph.starterpack" ? void 0 : t.embed?.$type === "app.bsky.embed.record#view" ? t.embed.record : t.embed?.record?.record?.$type === "app.bsky.embed.record#viewRecord" && t.embed.record.record, d = h && {
    ...h,
    record: h?.value,
    embed: (h?.embeds || [])[0]
  };
  return {
    username: t.author.displayName,
    handle: t.author.handle,
    avatar: t.author.avatar,
    // todo fallback
    text: b,
    createdAt: t.record.createdAt,
    uri: t.uri,
    images: [...t.embed?.images || [], ...t.embed?.media?.images || []],
    video: t.embed?.$type === "app.bsky.embed.video#view" && t.embed,
    card: t.embed?.$type === "app.bsky.embed.external#view" && t.embed?.external,
    replyPost: r && d && d.record && X0({
      post: d,
      reason: {
        $type: "",
        by: {
          displayName: ""
        }
      },
      isRoot: !1
    }),
    isRepost: e?.$type === "app.bsky.feed.defs#reasonRepost",
    repostBy: e?.by?.displayName
  };
}, Iu = (t) => (t.feed || []).filter((e) => e.post.record).map((e) => X0({
  ...e,
  isRoot: !0
})), Md = (t) => {
  const e = t.lastIndexOf("/");
  return e !== -1 ? t.substring(e + 1) : t;
}, nU = (t) => {
  const e = /* @__PURE__ */ new Date(), r = 60 * 1e3, n = r * 60, u = n * 24, y = u * 30, b = u * 365, h = e.getTime() - t.getTime();
  return h < r ? Math.floor(h / 1e3) + "s" : h < n ? Math.floor(h / r) + "m" : h < u ? Math.floor(h / n) + "h" : h < y ? Math.floor(h / u) + "d" : h < b ? Math.floor(h / y) + " mo" : Math.floor(h / b) + " yr";
}, aU = async (t, e) => {
  if (!("IntersectionObserver" in window)) {
    console.error("IntersectionObserver not supported");
    return;
  }
  if (!e) {
    console.error("Video element not found");
    return;
  }
  const r = {
    root: null,
    // Viewport is the root by default
    threshold: 0.5
    // 50% of the video must be visible to trigger playback
  }, n = async (y, b) => {
    y.forEach((h) => {
      if (h.isIntersecting) {
        if (Bu.isSupported()) {
          var d = new Bu();
          d.loadSource(t.playlist), d.attachMedia(e), d.on(Bu.Events.MANIFEST_PARSED, () => {
            e.play();
          });
        } else e.canPlayType("application/vnd.apple.mpegurl") && (e.src = t.playlist, e.addEventListener("loadedmetadata", () => {
          e.play();
        }));
        b.unobserve(e);
      }
    });
  };
  new IntersectionObserver(n, r).observe(e);
};
var sU = /* @__PURE__ */ mr('<article class="p-4 border-b border-slate-300 dark:border-slate-800"><div class="flex gap-2"><div class=w-full><div><a class="text-ellipsis overflow-hidden whitespace-nowrap hover:underline dark:text-white"><span class="font-bold dark:text-white"></span><span> </span><span class="text-slate-500 dark:text-slate-400 text-sm">@</span></a><span class="text-slate-500 dark:text-slate-400 text-sm whitespace-nowrap"><span class=mx-1>·</span><a class=hover:underline></a></span></div><p class="whitespace-pre-wrap dark:text-white">'), oU = /* @__PURE__ */ mr('<p class="flex gap-1 items-center ml-10 text-slate-600 dark:text-slate-400"><svg viewBox="0 0 576 512"height=16 width=16 tabindex=-1 class=mr-1><path fill=currentColor d="M272 416c17.7 0 32-14.3 32-32s-14.3-32-32-32H160c-17.7 0-32-14.3-32-32V192h32c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-64-64c-12.5-12.5-32.8-12.5-45.3 0l-64 64c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l32 0 0 128c0 53 43 96 96 96H272zM304 96c-17.7 0-32 14.3-32 32s14.3 32 32 32l112 0c17.7 0 32 14.3 32 32l0 128H416c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l64 64c12.5 12.5 32.8 12.5 45.3 0l64-64c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8l-32 0V192c0-53-43-96-96-96L304 96z"></path></svg><span class="text-sm text-slate-500 font-semibold">Reposted by '), lU = /* @__PURE__ */ mr('<img alt="profile picture"class="w-14 h-14 rounded-full">'), uU = /* @__PURE__ */ mr('<img alt="profile picture"class="w-4 h-4 mr-1 rounded-full">'), Nd = /* @__PURE__ */ mr("<span>"), cU = /* @__PURE__ */ mr("<div>"), dU = /* @__PURE__ */ mr("<a><img class=rounded-md>"), fU = /* @__PURE__ */ mr('<div class="mt-4 w-full"><video width=100% class="rounded-md w-full h-full object-cover"preload=none>'), pU = /* @__PURE__ */ mr('<a target=_blank rel=noopener class="mt-4 rounded-md border border-slate-300 block"><div class=p-3><p class="text-slate-500 dark:text-slate-400 text-sm"></p><p class="font-bold dark:text-white mb-1"></p><p class="whitespace-pre-wrap dark:text-white">'), hU = /* @__PURE__ */ mr('<img class=rounded-t-md alt="Post Thumbnail">'), mU = /* @__PURE__ */ mr('<a target=_blank rel=noopener class="mt-4 rounded-md border border-slate-300 block">');
const z0 = ({
  linkTarget: t = "_self",
  post: e,
  handleModalContent: r,
  isCard: n = !1,
  isReplyPost: u = !1
}) => {
  let y;
  return iy(() => {
    e.video && e.video.cid && aU(e.video, y);
  }), (() => {
    var b = sU(), h = b.firstChild, d = h.firstChild, m = d.firstChild, p = m.firstChild, _ = p.firstChild, B = _.nextSibling, N = B.nextSibling;
    N.firstChild;
    var X = p.nextSibling, te = X.firstChild, re = te.nextSibling, J = m.nextSibling;
    return yt(b, (() => {
      var F = pi(() => !!e.isRepost);
      return () => F() && (() => {
        var z = oU(), ee = z.firstChild, ye = ee.nextSibling;
        return ye.firstChild, yt(ye, () => e.repostBy, null), z;
      })();
    })(), h), yt(h, !n && (() => {
      var F = lU();
      return kr(() => Ht(F, "src", e.avatar)), F;
    })(), d), Ou(m, u ? "flex max-w-[calc(365px-96px)] items-center" : "flex max-w-[calc(390px-96px)] items-center"), yt(m, n && (() => {
      var F = uU();
      return kr(() => Ht(F, "src", e.avatar)), F;
    })(), p), Ht(p, "target", t), Ht(p, "rel", t === "_blank" ? "noopeener" : ""), yt(_, () => e.username), yt(N, () => e.handle, null), Ht(re, "target", t), Ht(re, "rel", t === "_blank" ? "noopeener" : ""), yt(re, () => nU(new Date(e.createdAt))), yt(J, () => e.text.map((F) => F.setInnerHtml ? (() => {
      var z = Nd();
      return kr(() => z.innerHTML = F.val), z;
    })() : (() => {
      var z = Nd();
      return yt(z, () => F.val), z;
    })())), yt(d, (() => {
      var F = pi(() => e.images.length > 0);
      return () => F() && (() => {
        var z = cU();
        return yt(z, () => e.images.map((ee) => (() => {
          var ye = dU(), xe = ye.firstChild;
          return ye.$$click = (Ee) => r(Ee, ee), Ht(ye, "target", t), Ht(ye, "rel", t === "_blank" ? "noopeener" : ""), kr((Ee) => {
            var Ae = `https://bsky.app/profile/${e.handle}/post/${Md(e.uri)}`, De = ee.thumb, Ue = ee.alt;
            return Ae !== Ee.e && Ht(ye, "href", Ee.e = Ae), De !== Ee.t && Ht(xe, "src", Ee.t = De), Ue !== Ee.a && Ht(xe, "alt", Ee.a = Ue), Ee;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          }), ye;
        })())), kr(() => Ou(z, e.images.length > 1 ? "mt-4 grid grid-cols-2 gap-2" : "mt-4")), z;
      })();
    })(), null), yt(d, (() => {
      var F = pi(() => !!e.video);
      return () => F() && (() => {
        var z = fU(), ee = z.firstChild, ye = y;
        return typeof ye == "function" ? Ku(ye, ee) : y = ee, ee.autoplay = !1, ee.controls = !0, ee.muted = !0, kr(() => Ht(ee, "poster", e.video.thumbnail)), z;
      })();
    })(), null), yt(d, (() => {
      var F = pi(() => !!e.card);
      return () => F() && (() => {
        var z = pU(), ee = z.firstChild, ye = ee.firstChild, xe = ye.nextSibling, Ee = xe.nextSibling;
        return yt(z, (() => {
          var Ae = pi(() => !!e.card.thumb);
          return () => Ae() && (() => {
            var De = hU();
            return kr(() => Ht(De, "src", e.card.thumb)), De;
          })();
        })(), ee), yt(ye, () => new URL(e.card.uri).hostname), yt(xe, () => e.card.title), yt(Ee, () => e.card.description), kr(() => Ht(z, "href", e.card.uri)), z;
      })();
    })(), null), yt(d, (() => {
      var F = pi(() => !!e.replyPost);
      return () => F() && (() => {
        var z = mU();
        return yt(z, Wd(z0, cy({
          linkTarget: t,
          handleModalContent: r
        }, {
          get post() {
            return e.replyPost;
          },
          isCard: !0,
          isReplyPost: !0
        }))), kr(() => Ht(z, "href", e.card.uri)), z;
      })();
    })(), null), kr((F) => {
      var z = `https://bsky.app/profile/${e.handle}`, ee = `https://bsky.app/profile/${e.handle}/post/${Md(e.uri)}`;
      return z !== F.e && Ht(p, "href", F.e = z), ee !== F.t && Ht(re, "href", F.t = ee), F;
    }, {
      e: void 0,
      t: void 0
    }), b;
  })();
};
Yd(["click"]);
var yU = /* @__PURE__ */ mr("<style>"), bU = /* @__PURE__ */ mr('<section><dialog class="backdrop:bg-gray-800 backdrop:opacity-90"><form class="fixed top-5 right-5"><button type=submit aria-label=close formmethod=dialog formnovalidate class="bg-gray-900 rounded-full w-10 h-10 text-white flex items-center justify-center">X</button></form><img src=""alt=""class=max-h-[90vh]>'), gU = /* @__PURE__ */ mr("<div class=w-full>"), xU = /* @__PURE__ */ mr('<article class="w-full flex gap-2 p-4 border-b border-slate-300 dark:border-slate-800 animate-pulse"><div class="bg-slate-200 w-14 h-14 rounded-full dark:bg-slate-800"></div><div class="flex-1 space-y-2 py-1"><div class="grid grid-cols-4 gap-4"><div class="h-2 bg-slate-200 rounded col-span-2 dark:bg-slate-800"></div></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800"></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800"></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800">'), EU = /* @__PURE__ */ mr('<div class="mt-8 mb-8"><button id=bsky-load-more class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Load More Posts');
const vU = ({
  username: t,
  feed: e,
  limit: r = 10,
  mode: n = "",
  linkTarget: u = "_self",
  linkImage: y = !1,
  customStyles: b = "",
  search: h,
  loadMore: d = !0
}) => {
  let m = null, p = null;
  const [_, B] = Xa(!1), [N, X] = Xa([]), [te] = Xa(r), [re, J] = Xa(void 0);
  Gd(() => {
    B(!0), F();
  }, [t, e, h, te]);
  const F = async (xe) => {
    t ? Pu.app.bsky.feed.getAuthorFeed({
      limit: te(),
      actor: t,
      filter: "posts_no_replies",
      cursor: xe
    }).then(({
      success: Ee,
      data: Ae
    }) => {
      if (Ee) {
        const De = Iu(Ae);
        ye(De), B(!1), J(Ae.cursor);
      }
    }) : e ? Pu.app.bsky.feed.getFeed({
      limit: te(),
      feed: e,
      cursor: xe
    }).then(({
      success: Ee,
      data: Ae
    }) => {
      if (Ee) {
        const De = Iu(Ae);
        ye(De), B(!1), J(Ae.cursor);
      }
    }) : h && Pu.app.bsky.feed.searchPosts({
      limit: te(),
      q: h,
      cursor: xe
    }).then(({
      success: Ee,
      data: Ae
    }) => {
      if (Ee) {
        const De = {
          ...Ae,
          feed: Ae.posts.map((Ve) => ({
            post: Ve
          }))
        }, Ue = Iu(De);
        ye(Ue), B(!1), J(Ae.cursor);
      }
    });
  }, z = (xe, Ee) => {
    !y && m && p && (xe.preventDefault(), p.src = Ee.fullsize, p.alt = Ee.alt, m.showModal());
  }, ee = () => {
    B(!0), F(re());
  }, ye = (xe) => {
    const Ee = [...N(), ...xe];
    X(Ee);
  };
  return [(() => {
    var xe = yU();
    return yt(xe, by, null), yt(xe, b, null), xe;
  })(), (() => {
    var xe = bU(), Ee = xe.firstChild, Ae = Ee.firstChild, De = Ae.nextSibling;
    return Ou(xe, `${n} max-w-screen-sm mx-auto flex flex-col items-center`), yt(xe, (() => {
      var Ue = pi(() => N().length > 0);
      return () => Ue() && N().map((Ve, tt) => (() => {
        var dt = gU();
        return Ht(dt, "id", `post-${tt}`), yt(dt, Wd(z0, {
          post: Ve,
          handleModalContent: z,
          linkTarget: u
        })), dt;
      })());
    })(), Ee), yt(xe, (() => {
      var Ue = pi(() => !!_());
      return () => Ue() && Array.from(Array(r)).map(() => xU());
    })(), Ee), Ku((Ue) => m = Ue, Ee), Ku((Ue) => p = Ue, De), yt(xe, (() => {
      var Ue = pi(() => !!re());
      return () => Ue() && (() => {
        var Ve = EU(), tt = Ve.firstChild;
        return tt.$$click = ee, Ve;
      })();
    })(), null), xe;
  })()];
};
Yd(["click"]);
yy("bsky-embed", {
  username: "",
  feed: "",
  limit: 10,
  mode: "",
  linkTarget: "_self",
  linkImage: !1,
  customStyles: "",
  search: "",
  loadMore: !1
}, vU);
